--Drops the Procedure abgtDeleteAnnualImport if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[abgtDeleteAnnualImport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE abgtDeleteAnnualImport
GO
CREATE PROCEDURE abgtDeleteAnnualImport
	@IdImport INT
AS

DECLARE @Validation	NVARCHAR(1)
SET @Validation = (SELECT Validation
					FROM ANNUAL_BUDGET_IMPORT_LOGS
					WHERE IdImport = @IdImport)

IF (@Validation = 'G')
BEGIN
	DELETE FROM ANNUAL_BUDGET_DATA_DETAILS_COSTS
	WHERE IdImport = @IdImport

	DELETE FROM ANNUAL_BUDGET_DATA_DETAILS_SALES
	WHERE IdImport = @IdImport

	DELETE FROM ANNUAL_BUDGET_DATA_DETAILS_HOURS
	WHERE IdImport = @IdImport
END

DELETE FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS 
WHERE IdImport = @IdImport

DELETE FROM ANNUAL_BUDGET_IMPORT_LOGS 
WHERE IdImport = @IdImport	

DELETE FROM ANNUAL_BUDGET_IMPORT_DETAILS 
WHERE IdImport = @IdImport

DELETE FROM ANNUAL_BUDGET_IMPORTS 
WHERE IdImport = @IdImport

GO

--Drops the Procedure abgtExtractFromReforcastAndActualData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[abgtExtractFromReforcastAndActualData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE abgtExtractFromReforcastAndActualData
GO
--exec abgtExtractFromReforcastAndActualData -1,-1,2008
CREATE PROCEDURE abgtExtractFromReforcastAndActualData
	@IdCountry INT,
	@IdInergyLocation INT,
	@Year DATETIME
AS



DECLARE @temp table
(
	IdExtract INT  IDENTITY (1, 1) NOT NULL,
	IdProject INT,
	IdPhase INT,
	IdWorkPackage INT,
	IdCostCenter INT,
	YearMonth INT,
	AccountNumber varchar(20),
	Quantity decimal (12,2),
	Value decimal(18,2),
	[Date] smalldatetime,
	IdCountry INT
	PRIMARY KEY (IdCountry, YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber)
)


--GET ALL HOURS RECORDS
INSERT INTO @temp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, ISNULL(SUM(BCD.HoursQty),0), SUM(BCD.HoursVal), BC.ValidationDate, IL.IdCountry 
FROM 	BUDGET_TOCOMPLETION BC
INNER JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON
	BC.IdProject = BCD.IdProject AND
	BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCD.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	BCD.IdCountry = GLA.IdCountry AND
	BCD.IdAccountHours = GLA.Id
WHERE 	BC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND
	(BCD.YearMonth/100) = @Year AND
	(BCD.HoursQty IS NOT NULL OR BCD.HoursVal IS NOT NULL) AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END	
GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BC.ValidationDate, IL.IdCountry


--GET ALL SALES RECORD
INSERT INTO @temp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, 0, SUM(BCD.SalesVal), BC.ValidationDate, IL.IdCountry 
FROM 	BUDGET_TOCOMPLETION BC 
INNER JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON
	BC.IdProject = BCD.IdProject AND
	BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCD.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	BCD.IdCountry = GLA.IdCountry AND
	BCD.IdAccountSales = GLA.Id
WHERE 	BC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND
	(BCD.YearMonth / 100) = @Year AND
	BCD.SalesVal IS NOT NULL AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END
GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BC.ValidationDate, IL.IdCountry


--GET ALL OTHER COSTS
INSERT INTO @temp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)
SELECT 	BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, 0, SUM(BCDC.CostVal), BC.ValidationDate, IL.IdCountry
FROM 	BUDGET_TOCOMPLETION BC
INNER JOIN BUDGET_TOCOMPLETION_DETAIL_COSTS BCDC ON
	BC.IdProject = BCDC.IdProject AND
	BC.IdGeneration = BCDC.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCDC.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	BCDC.IdCountry = GLA.IdCountry AND
	BCDC.IdAccount = GLA.Id
WHERE 	BCDC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND
	(BCDC.YearMonth / 100) = @Year AND
	BCDC.CostVal IS NOT NULL AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END
GROUP BY BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, BC.ValidationDate, IL.IdCountry


DECLARE @actualTemp table
(
	IdExtract INT  IDENTITY (1, 1) NOT NULL,
	IdProject INT,
	IdPhase INT,
	IdWorkPackage INT,
	IdCostCenter INT,
	YearMonth INT,
	AccountNumber varchar(20),
	Quantity decimal(12,2) ,
	Value decimal(18,2),
	[Date] smalldatetime,
	IdCountry INT
 	PRIMARY KEY (IdCountry, YearMonth, IdProject,IdPhase, IdWorkPackage, IdCostCenter, AccountNumber)
)

--GET ALL HOURS RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, ISNULL(SUM(ROUND(AD.HoursQty,0)),0), SUM(AD.HoursVal), A.[Date], IL.IdCountry 
FROM ACTUAL_DATA A
INNER JOIN ACTUAL_DATA_DETAILS_HOURS AD ON
	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC ON
	AD.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
LEFT JOIN BUDGET_TOCOMPLETION BC ON
	A.IdProject = BC.IdProject AND
	dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
WHERE 	(AD.YearMonth / 100) = @Year AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END AND
	AD.YearMonth <= ISNULL(BC.YearMonthActualData, 207901)
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, A.[Date], IL.IdCountry 

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, 0, SUM(AD.SalesVal), A.[Date], IL.IdCountry 
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_SALES AD ON
	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC ON
	AD.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
LEFT JOIN BUDGET_TOCOMPLETION BC ON
	A.IdProject = BC.IdProject AND
	dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
WHERE 	(AD.YearMonth / 100) = @Year AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END AND
	AD.YearMonth <= ISNULL(BC.YearMonthActualData, 207901)
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, A.[Date], IL.IdCountry 

--GET ALL OTHER COSTS
INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, [Date], IdCountry)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, 0,	SUM(ADDC.CostVal), A.[Date],IL.IdCountry
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_COSTS ADDC ON
	A.IdProject = ADDC.IdProject
INNER JOIN COST_CENTERS CC ON
	ADDC.IdCostCenter = CC.Id
INNER JOIN Inergy_Locations IL ON
	IL.Id = CC.IdInergyLocation
INNER JOIN GL_ACCOUNTS GLA ON
	ADDC.IdCountry = GLA.IdCountry AND
	ADDC.IdAccount = GLA.Id
LEFT JOIN BUDGET_TOCOMPLETION BC ON
	A.IdProject = BC.IdProject AND
	dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
WHERE 	(ADDC.YearMonth / 100) = @Year AND
	IL.IdCountry = CASE @IdCountry WHEN -1 THEN IL.IdCountry ELSE @IdCountry END AND
	IL.Id = CASE @IdInergyLocation WHEN -1 THEN IL.Id ELSE @IdInergyLocation END AND
	ADDC.YearMonth <= ISNULL(BC.YearMonthActualData, 207901)
GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, A.[Date],IL.IdCountry

---------------------------------------------------the special case from issue 29608 is treated here------------------------------------------

DECLARE @tempLinesToRemove table
(
	IdLine		INT  IDENTITY (1, 1),
	IdExtract	INT
)

INSERT INTO @tempLinesToRemove (IdExtract)
SELECT t.IdExtract
FROM @temp t
INNER JOIN BUDGET_TOCOMPLETION BT ON
	t.IdProject = BT.IdProject AND
	dbo.fnGetToCompletionBudgetGeneration(t.IdProject,'C') = BT.IdGeneration
INNER JOIN @actualtemp a ON	--on purpose incomplete join
	t.IdProject 	= a.IdProject AND
	t.IdPhase 	= a.IdPhase AND
	t.IdWorkPackage = a.IdWorkPackage AND
	t.IdCostCenter 	= a.IdCostCenter
WHERE t.YearMonth <= BT.YearMonthActualData

DELETE t
FROM @temp t
INNER JOIN (SELECT IdExtract FROM @tempLinesToRemove GROUP BY IdExtract) tempLines
	ON tempLines.IdExtract = t.IdExtract

--------------------------------------------------------------------------------------------------------------------------------------------


-- delete all multiple keys from reforcast if any and overwrite with data from actual

DELETE t
FROM @temp t INNER JOIN @actualTemp a ON
 	t.IdCountry 	= a.IdCountry AND
	t.YearMonth 	= a.YearMonth AND
	t.IdProject 	= a.IdProject AND
	t.IdPhase 	= a.IdPhase AND
	t.IdWorkPackage = a.IdWorkPackage AND
	t.IdCostCenter 	= a.IdCostCenter AND
	t.AccountNumber = a.AccountNumber


INSERT INTO @temp (IdProject, IdPhase,IdWorkPackage,
		   IdCostCenter, YearMonth, AccountNumber,
		   Quantity, Value, [Date], IdCountry)

SELECT 		 IdProject, IdPhase,IdWorkPackage,
		   IdCostCenter, YearMonth, AccountNumber,
		   Quantity, Value, [Date], IdCountry
FROM @actualTemp


--NOW ALL DATA IS IN @temp table all we need is to get the data set


SELECT  C.Code AS 			[Country Code],
	(t.YearMonth/100) AS 		[Year],
	CC.Code AS 			[Cost Center Code],
	P.Code AS			[Project Code],
	WP.Code as 			[WP Code],
	t.AccountNumber as 		[G/L Account],
	sum(t.Quantity) as		[Quantity],
	sum(t.Value) AS			[Yearly Value],
	MAX(CURR.Code) AS 		[Currency Code],
	dbo.fnDate2String(MAX(t.[Date])) AS [Date of Update],
	MAX(F.NAME) as 			[FunctionName],
	MAX(CC.Name) as 		[Cost Center Name],
	MAX(P.Name) as 			[Project Name],
 	MAX(CIT.Name) as 		[COST Type],
 	MAX(IL.Name) as			[Inergy Location Name]--,
 	--MAX(c.Name) as			[Country Name]

FROM @temp t 
INNER JOIN COUNTRIES C 
	ON t.IdCountry = C.Id
INNER JOIN CURRENCIES CURR
	ON C.IdCurrency = CURR.Id
INNER JOIN COST_CENTERS CC
	ON t.IdCostCenter = CC.Id
INNER JOIN PROJECTS P
	ON t.IdProject = P.Id
INNER JOIN WORK_PACKAGES WP
	ON t.IdProject = WP.IdProject
	AND t.IdPhase = WP.IdPhase
	AND t.IdWorkPackage = WP.Id
INNER join Departments D
	ON CC.IdDepartment=D.ID
INNER JOIN [FUNCTIONS] F
	ON D.IdFunction=F.Id
INNER JOIN INERGY_LOCATIONS IL
 	ON CC.IdInergyLocation=IL.Id
INNER JOIN GL_ACCOUNTS GLA 
 	ON t.IdCountry = GLA.IdCountry AND
 	   t.AccountNumber = GLA.Account
INNER JOIN COST_INCOME_TYPES CIT 
 	ON GLA.IdCostType=CIT.Id
group by C.Code, (t.YearMonth/100), CC.Code, P.Code, WP.Code, t.AccountNumber	

GO

--Drops the Procedure abgtSelectAnnualDataLogs if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[abgtSelectAnnualDataLogs]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE abgtSelectAnnualDataLogs
GO
CREATE PROCEDURE abgtSelectAnnualDataLogs
	@CountryCode AS varchar(5) --the code of the country
AS
IF @CountryCode IS NULL
	SELECT 
		IL.[Year]				AS	'Year',
		I.[FileName]			AS	'FileName',
		I.ImportDate			AS	'Date',
		SUBSTRING(I.[FileName],1,3)	AS	'CountryCode',
		[ASC].[Name]			AS	'UserName',
		IL.Validation			AS	'Validation',
		I.IdImport			AS	'IdImport',
		I.IdAssociate			AS	'IdUser'
	FROM ANNUAL_BUDGET_IMPORT_LOGS AS IL
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	ORDER BY IdImport DESC
ELSE
	SELECT 
		IL.[Year]				AS	'Year',
		I.[FileName]			AS	'FileName',
		I.ImportDate			AS	'Date',
		SUBSTRING(I.[FileName],1,3)	AS	'CountryCode',
		[ASC].[Name]			AS	'UserName',
		IL.Validation			AS	'Validation',
		I.IdImport			AS	'IdImport',
		I.IdAssociate			AS	'IdUser'
	FROM ANNUAL_BUDGET_IMPORT_LOGS AS IL
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	WHERE SUBSTRING(I.[FileName],1,3) = @CountryCode
	ORDER BY IdImport DESC

	RETURN 1
GO
	

--Drops the Procedure abgtSelectAnnualDataLogsDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[abgtSelectAnnualDataLogsDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE abgtSelectAnnualDataLogsDetail
GO
CREATE PROCEDURE abgtSelectAnnualDataLogsDetail
	@IdImport INT
AS

DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

SELECT @ROWCOUNTDELETED_CC =ExclusionCostCenterRowsNo,
	@ROWCOUNTDELETED_GL=ExclusionGlAccountsRowsNo
FROM ANNUAL_BUDGET_IMPORTS
WHERE IDIMPORT = @IdImport

	SELECT 
		C.[Name]								AS	'Country',
		I.[FileName]								AS	'FileName',
		I.ImportDate								AS	'Date',
		IL.[Year]									AS	'Year',
		A.Name									AS	'UserName',
		COUNT (DISTINCT AID.IdRow) + @ROWCOUNTDELETED_CC + @ROWCOUNTDELETED_GL	AS	'Lines'
	FROM ANNUAL_BUDGET_IMPORT_LOGS AS IL
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ANNUAL_BUDGET_IMPORT_DETAILS AS AID 
		ON AID.IdImport = I.IdImport
	INNER JOIN ASSOCIATES A
		ON I.IdAssociate = A.Id
	LEFT JOIN COUNTRIES AS C ON SUBSTRING(I.[FileName],1,3)=C.Code
	WHERE IL.IdImport = @IdImport
	GROUP BY C.[Name], I.[FileName], I.ImportDate, IL.[Year], A.Name

	SELECT 	
		ILD.IdRow	AS 'RowNo',
		ILD.Details 	AS 'Details',
		Module		AS 'Module'
	FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS AS ILD
	WHERE ILD.IdImport = @IdImport
	ORDER BY ILD.IdRow

	RETURN 1
GO
--Drops the Procedure abgtSelectAnnualDataStatus if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[abgtSelectAnnualDataStatus]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE abgtSelectAnnualDataStatus
GO
CREATE PROCEDURE [dbo].[abgtSelectAnnualDataStatus]
AS

	DECLARE @CurrentYear INT
	SET @CurrentYear= 2005
	
	DECLARE @Years TABLE  (
		[Year] INT
	)
	DECLARE @DataStatus table
	(
		IdCountry	INT,
		CountryCode	VARCHAR(3),
		Country		VARCHAR(30), 
		[Year]		INT,
		IsImport	BIT,
		IdImport	int
	)

	
	WHILE (@CurrentYear <= DATEPART(yyyy,GETDATE())+10)
	BEGIN
		INSERT INTO @Years ([Year]) VALUES (@CurrentYear)
	
		SET @CurrentYear = @CurrentYear + 1
	END
	
	INSERT INTO @DataStatus (IdCountry, CountryCode,Country, [Year],IsImport, IdImport)
	SELECT 
		C.[Id]		AS	IdCountry,
		C.Code		AS	CountryCode,
		C.[Name]	AS 	Country, 
		Y.[Year]	AS	[Year],
		0		AS	IsImport,
		0		as  IdImport
	
	FROM Countries AS C
	CROSS JOIN @Years AS Y
	WHERE C.IdRegion IS NOT NULL -- only inergy countries
	
	UPDATE DS
	SET DS.IsImport = 1, DS.IdImport =  case when not exists(select x.IdImport from ANNUAL_BUDGET_IMPORT_LOGS x INNER JOIN ANNUAL_BUDGET_IMPORTS y ON y.IdImport = x.IdImport where x.Validation='G' and x.Year > DS.Year and DS.CountryCode = SUBSTRING(y.[FileName],1,3)) then IL.IdImport else 0 end
	FROM @DataStatus DS
	INNER JOIN ANNUAL_BUDGET_IMPORT_LOGS  IL
		ON IL.[Year] = DS.[Year]
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS  IMP 
		ON IL.IdImport = IMP.IdImport
	WHERE IL.Validation = 'G' AND	
	      DS.CountryCode = SUBSTRING(IMP.[FileName],1,3)


	SELECT 
		IdCountry	AS	IdCountry,
		Country		AS	Country,
		[Year]		AS	[Year],
		IdImport
	FROM @DataStatus WHERE IsImport = 1
	


	RETURN 1
GO--Drops the Procedure authDeleteAssociateRole if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authDeleteAssociateRole]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authDeleteAssociateRole
GO
CREATE PROCEDURE authDeleteAssociateRole
	@IdAssociate	INT
AS
	IF EXISTS (
		SELECT 	IdAssociate
		FROM	ASSOCIATE_ROLES
		WHERE 	IdAssociate = @IdAssociate
	)
	BEGIN
		DELETE FROM ASSOCIATE_ROLES
		WHERE	IdAssociate = @IdAssociate
	END
	
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authIsAssociateKeyUserImpersonatingManagerOnProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authIsAssociateKeyUserImpersonatingManagerOnProject
GO



create PROCEDURE [dbo].authIsAssociateKeyUserImpersonatingManagerOnProject
	
@IdProject AS INT,
	
@IdAssociate AS INT,		
	
@IdImpersonated as int

AS	

declare @IdRole int
select @IdRole = IdRole from ASSOCIATE_ROLES where IdAssociate = @IdAssociate

if @IdRole = 8 and exists(select IdAssociate from PROJECT_CORE_TEAMS where IdProject = @IdProject and IdAssociate = @IdImpersonated and IdFunction = 1)
   select 1
else
  select 0

return

Go
--Drops the Procedure authIsAssociateTrainerImpersonatingOnProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authIsAssociateTrainerImpersonatingOnProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authIsAssociateTrainerImpersonatingOnProject
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authIsAssociateKeyUserImpersonatingOnProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authIsAssociateKeyUserImpersonatingOnProject
GO

create PROCEDURE [dbo].authIsAssociateKeyUserImpersonatingOnProject
	@IdProject 		AS INT,
	@IdAssociate       	AS INT,		
	@IdImpersonated		as int
AS	

declare @IdRole int
select @IdRole = IdRole from ASSOCIATE_ROLES where IdAssociate = @IdAssociate

if @IdRole = 8 and exists(select IdAssociate from PROJECT_CORE_TEAMS where IdProject = @IdProject and IdAssociate = @IdImpersonated)
   select 1
else
  select 0

return

Go--Drops the Procedure authIsAssociateTrainerImpersonatingOnProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authIsAssociateTrainerImpersonatingOnProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authIsAssociateTrainerImpersonatingOnProject
GO


create PROCEDURE [dbo].authIsAssociateTrainerImpersonatingOnProject
	@IdProject 		AS INT,
	@IdAssociate       	AS INT,		
	@IdImpersonated		as int
AS	

declare @IdRole int
select @IdRole = IdRole from ASSOCIATE_ROLES where IdAssociate = @IdAssociate

if @IdRole = 8 and exists(select IdAssociate from PROJECT_CORE_TEAMS where IdProject = @IdProject and IdAssociate = @IdImpersonated)
   select 1
else
  select 0

return

Go--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectAssociates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectAssociates
GO
CREATE PROCEDURE authSelectAssociates
AS
	SELECT 	A.[Id]	AS 'Id',
		A.[Name]	AS 'Name',
		A.[InergyLogin] AS 'InergyLogin',
		A.[Name] + ' - '+ C.[Name] AS 'AssociateCountry'
		
	FROM 	ASSOCIATES A
	LEFT JOIN Countries C ON A.[IdCountry] = C.[Id]
	WHERE A.[Id] > 0
	ORDER BY A.[Name]
	
GO

--Drops the Procedure bgtSelectProfile if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectProfile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectProfile
GO
CREATE PROCEDURE authSelectProfile
AS
	--This procedure will return all associates and roles from ASSOCIATE_ROLES table
		SELECT 	A.[Name]	AS 'Associate',
			C.[Name]	AS 'Country',
			A.[InergyLogin] AS 'Inergy Login',
			CASE WHEN (R.[Name] IS NULL) THEN '-' ELSE R.[Name] END AS 'Role'
		FROM ASSOCIATE_ROLES AS AR
		RIGHT JOIN ASSOCIATES AS A
		ON AR.IdAssociate = A.[Id]
		LEFT JOIN ROLES AS R
		ON AR.IdRole = R.[Id]
		LEFT JOIN COUNTRIES C
		ON A.IdCountry = C.Id
		WHERE A.[Id] > 0
		ORDER BY A.[Name]
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectRolePermissions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectRolePermissions
GO
CREATE PROCEDURE authSelectRolePermissions
	@IdRole		INT	--The login name used to log into the application
AS
	SELECT 	RRIGHTS.[CodeModule]	AS 'ModuleCode',
		RRIGHTS.IdOperation	AS 'IdOperation',
		RRIGHTS.[IdPermission]	AS 'IdPermission'
	FROM 	ROLE_RIGHTS 		AS RRIGHTS
	WHERE	RRIGHTS.IdRole = @IdRole
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectRoles]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectRoles
GO
CREATE PROCEDURE authSelectRoles
	@IdAssociate		INT	--The login name used to log into the application
AS
	IF (@IdAssociate = -1)
	BEGIN
		SELECT 	[Id]	AS 'Id',
			[Name]	AS 'Name'
		FROM 	ROLES
		WHERE 	[Id] IN (1,2,3,6,8)	-- do not select Program Manger or Core team member roles but select Functional Manager
	END
	ELSE
	BEGIN
		SELECT 	[Id]	AS 'Id',
			[Name]	AS 'Name'
		FROM 	ROLES
		INNER JOIN ASSOCIATE_ROLES 
			ON 	ROLES.[Id] = ASSOCIATE_ROLES.IdRole AND
				ASSOCIATE_ROLES.IdAssociate = @IdAssociate
	END

GO


--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectUserCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectUserCountries
GO
CREATE PROCEDURE authSelectUserCountries
	@InergyLogin	VARCHAR(50)
AS
	SELECT 	A.IdCountry 	AS 'Id',
		C.[Name]	AS 'Name'
	FROM 	ASSOCIATES AS A
	INNER 	JOIN COUNTRIES AS C
		ON A.IdCountry = C.[Id]
	WHERE	A.InergyLogin = @InergyLogin AND
		A.IsActive = 1
	ORDER BY C.[Name]
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectUserPermissions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectUserPermissions
GO
CREATE PROCEDURE authSelectUserPermissions
	@IdUser		INT	--The login name used to log into the application
AS
	SELECT 		AROLES.IdRole 		AS 'IdRole',
			ROLES.[Name]		AS 'RoleName'
	FROM		ASSOCIATE_ROLES		AS AROLES
	INNER JOIN	ROLES
	ON		AROLES.IdRole = ROLES.[Id]
	WHERE		AROLES.IdAssociate = @IdUser

	SELECT 		RRIGHTS.[CodeModule]	AS 'ModuleCode',
			RRIGHTS.IdOperation	AS 'IdOperation',
			RRIGHTS.[IdPermission]	AS 'IdPermission'
	FROM		ASSOCIATE_ROLES 	AS AROLES
	INNER JOIN 	ROLE_RIGHTS 		AS RRIGHTS
	ON 		AROLES.IdRole = RRIGHTS.IdRole
	WHERE		AROLES.IdAssociate = @IdUser
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authSelectUserProjects]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authSelectUserProjects
GO
CREATE PROCEDURE authSelectUserProjects
	@IdUser		INT	--The login name used to log into the application
AS
	SELECT 	P.Id 		AS 'IdProject',
		P.Name		AS 'ProjectName',
		PCT.IdFunction	AS 'IdFunction',
		PF.Name		AS 'ProjectFunction'
	FROM PROJECTS P (nolock)
	INNER JOIN PROJECT_CORE_TEAMS PCT
		ON P.Id = PCT.IdProject
	INNER JOIN ASSOCIATES A
		ON PCT.IdAssociate = A.[Id]
	INNER JOIN PROJECT_FUNCTIONS PF
		ON PCT.IdFunction = PF.[Id]
	WHERE A.Id = @IdUser AND
	      PCT.IsActive = 1
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authUpdateAssociateRole]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authUpdateAssociateRole
GO
CREATE PROCEDURE authUpdateAssociateRole
	@IdAssociate	INT,
	@IdRole		INT
AS
	IF EXISTS (
		SELECT 	IdAssociate
		FROM	ASSOCIATE_ROLES
		WHERE 	IdAssociate = @IdAssociate
	)
	BEGIN
		UPDATE 	ASSOCIATE_ROLES
		SET	IdAssociate = @IdAssociate,
			IdRole = @IdRole
		WHERE	IdAssociate = @IdAssociate
	END
	ELSE
	BEGIN
		INSERT INTO ASSOCIATE_ROLES
			(IdAssociate, IdRole)
		VALUES	(@IdAssociate, @IdRole)
	END
GO

--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[authVerifyLogin]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE authVerifyLogin
GO
CREATE PROCEDURE authVerifyLogin
	@InergyLogin	VARCHAR(50),	--The login name used to log into the application
	@IdCountry	INT	--If specified, the select statement will include the IdCountry column in the where clause
AS
	SELECT 		A.[Id] 		AS 'IdAssociate',
			A.[Name]	AS 'AssociateName',
			A.IdCountry 	AS 'IdCountry',
			C.[Name] 	AS 'CountryName',
			CUR.Id		AS 'IdCurrency',
			CUR.Code	AS 'CodeCurrency',
			C.Code		AS 'CountryCode'
	FROM		ASSOCIATES 	AS A
	INNER JOIN 	COUNTRIES 	AS C
		ON 	A.IdCountry = C.Id
	INNER JOIN 	CURRENCIES 	AS CUR
		ON 	CUR.Id = C.IdCurrency
	WHERE		InergyLogin = @InergyLogin AND
			IdCountry = CASE WHEN @IdCountry IS NULL THEN IdCountry ELSE @IdCountry END AND
			IsActive = 1
GO

--Drops the Procedure auxSelectErrorMessage_0 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_0]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_0
GO
CREATE PROCEDURE auxSelectErrorMessage_0
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Message	VARCHAR(200) OUTPUT	--The output message
AS
DECLARE	@Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Message
GO

--Drops the Procedure auxSelectErrorMessage_1 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_1]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_1
GO
CREATE PROCEDURE auxSelectErrorMessage_1
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Parameter1	VARCHAR(50),		--First parameter 
	@Message	VARCHAR(200) OUTPUT	--The output message
AS
DECLARE	@Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter1)

	SELECT @Message
GO

--Drops the Procedure auxSelectErrorMessage_2 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_2
GO
CREATE PROCEDURE auxSelectErrorMessage_2
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Parameter1	VARCHAR(50),		--First parameter 
	@Parameter2	VARCHAR(50),		--Second parameter 
	@Message	VARCHAR(200) OUTPUT	--The output message
AS
DECLARE	@Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter1)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter2)
GO

--Drops the Procedure auxSelectErrorMessage_3 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_3]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_3
GO
CREATE PROCEDURE auxSelectErrorMessage_3
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Parameter1	VARCHAR(50),		--First parameter 
	@Parameter2	VARCHAR(50),		--Second parameter
	@Parameter3	VARCHAR(50),		--Third parameter 
	@Message	VARCHAR(200) OUTPUT	--The output message
	 
AS
DECLARE @Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter1)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter2)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter3)

	SELECT @Message
GO

--Drops the Procedure auxSelectErrorMessage_4 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_4]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_4
GO
CREATE PROCEDURE auxSelectErrorMessage_4
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Parameter1	VARCHAR(50),		--First parameter 
	@Parameter2	VARCHAR(50),		--Second parameter
	@Parameter3	VARCHAR(50),		--Third parameter 
	@Parameter4	VARCHAR(50),		--Fourth parameter
	@Message	VARCHAR(200) OUTPUT	--The output message
	 
AS
DECLARE @Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter1)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter2)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter3)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter4)

	SELECT @Message
GO

--Drops the Procedure auxSelectErrorMessage_5 if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[auxSelectErrorMessage_5]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE auxSelectErrorMessage_5
GO
CREATE PROCEDURE auxSelectErrorMessage_5
	@Code 		VARCHAR(50),		--The Code of the selected Error
	@IdLanguage	INT,			--The Language Id
	@Parameter1	VARCHAR(50),		--First parameter 
	@Parameter2	VARCHAR(50),		--Second parameter
	@Parameter3	VARCHAR(50),		--Third parameter 
	@Parameter4	VARCHAR(50),		--Fourth parameter
	@Parameter5	VARCHAR(50),		--Fifth parameter 
	@Message	VARCHAR(200) OUTPUT	--The output message
	 
AS
DECLARE @Position	INT

	SELECT @Message = EM.Message 
	FROM	ERROR_MESSAGES AS EM
	WHERE EM.Code = @Code AND
	      EM.IdLanguage = @IdLanguage

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter1)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter2)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter3)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter4)

	SELECT @Position = CHARINDEX('%s',@Message,1)
	SELECT @Message = STUFF(@Message, @Position, 2, @Parameter5)

	SELECT @Message
GO

--Drops the Procedure bgtAssociateHasCurrentData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtAssociateHasCurrentData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[bgtAssociateHasCurrentData]
GO
create procedure [dbo].[bgtAssociateHasCurrentData]
@IdAssociate int

as

if exists(
	select IdAssociate from ACTUAL_DATA_DETAILS_HOURS where IdAssociate=@IdAssociate
	union
	select IdAssociate from ACTUAL_DATA_DETAILS_COSTS where IdAssociate=@IdAssociate
	union
	select IdAssociate from ACTUAL_DATA_DETAILS_SALES where IdAssociate=@IdAssociate
)
	select 1
else
	select 0


GO


--Drops the Procedure bgtCheckERForReforcastKeys if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtCheckERForReforcastKeys]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtCheckERForReforcastKeys
GO

CREATE  PROCEDURE bgtCheckERForReforcastKeys
	@IdAssociate INT,
	@AssociateCurrency INT,
	@AssociateCurrencyCode VARCHAR(10)
	
AS



DECLARE @WpName VARCHAR(30)
DECLARE @StartYM INT
DECLARE @EndYM	INT
DECLARE @YearMonth INT
DECLARE @CurrencyCode VARCHAR(10)


SELECT TOP 1 	@WpName = WP.Code + ' - ' + WP.Name,
	    	@StartYM = WP.StartYearMonth,
	    	@EndYM = WP.EndYearMonth,
	    	@YearMonth = BDT.YearMonth,
	   	@CurrencyCode = CURR.Code
FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BDT
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = BDT.IdProject AND
	   WP.IdPhase = BDT.IdPhase AND
	   WP.Id = BDT.IdWP	
INNER JOIN COST_CENTERS AS CC
	ON CC.[Id] = BDT.IdCostCenter
INNER JOIN INERGY_LOCATIONS AS IL
	ON IL.[Id] = CC.IdInergyLocation
INNER JOIN COUNTRIES
	ON COUNTRIES.[Id] = IL.IdCountry
INNER JOIN CURRENCIES CURR 
	ON CURR.[Id] = COUNTRIES.IdCurrency
WHERE  dbo.fnGetExchangeRate(@AssociateCurrency, CURR.Id, BDT.YearMonth) IS NULL 



IF @WPName IS NOT NULL
BEGIN
	DECLARE @YM VARCHAR(7)
	DECLARE @SYM VARCHAR(7)
	DECLARE @EYM VARCHAR(7)
	SELECT @YM = dbo.fnGetYMStringRepresentation(@YearMonth)
	SELECT @SYM = dbo.fnGetYMStringRepresentation(@StartYM)
	SELECT @EYM = dbo.fnGetYMStringRepresentation(@EndYM)
	
	RAISERROR('No exchange rate found for %s to %s conversion for YearMonth %s (Work Package %s, period %s - %s).',
		16,1, @AssociateCurrencyCode,@CurrencyCode,@YM, @WpName, @SYM, @EYM )
END



GO



--Drops the Procedure bgtCheckWPPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtCheckWPPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtCheckWPPeriod
GO
CREATE PROCEDURE bgtCheckWPPeriod
	@IdProject 		INT,
	@IdPhase		INT,
	@IdWorkPackage		INT,
	@CachedStartYearMonth 	INT,	--The start ym of the work package, as it has been cached in the application
	@CachedEndYearMonth 	INT	--The end ym of the work package, as it has been cached in the application
AS
	DECLARE @NewStartYearMonth INT
	DECLARE @NewEndYearMonth INT

	SELECT 	@NewStartYearMonth = StartYearMonth,
		@NewEndYearMonth = EndYearMonth
	FROM 	WORK_PACKAGES
	WHERE	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		[Id] = @IdWorkPackage

	--Check if the cached start ym and end ym have changed and show an error message if this is the case
	IF (@NewStartYearMonth <> @CachedStartYearMonth 
		OR @NewStartYearMonth IS NULL 
			OR @NewEndYearMonth <> @CachedEndYearMonth
				OR @NewEndYearMonth IS NULL)
	BEGIN
		RAISERROR('WP check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
	END
GO

--Drops the Procedure bgtCopyProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtCopyProjectCoreTeam]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtCopyProjectCoreTeam
GO

CREATE  PROCEDURE bgtCopyProjectCoreTeam
	@IdProject		INT,
	@IdTargetProject	INT
AS


DECLARE @IdAssociate	INT,
	@IdFunction	INT,
	@IsActive	BIT,
	@retVal		INT

-- Delete old team members from target project
DECLARE DeleteOldCoreTeamCursor CURSOR FAST_FORWARD FOR
SELECT
	IdAssociate,
	IdFunction
FROM PROJECT_CORE_TEAMS
WHERE IdProject = @IdTargetProject

OPEN DeleteOldCoreTeamCursor

FETCH NEXT FROM DeleteOldCoreTeamCursor INTO @IdAssociate, @IdFunction
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC @retVal = bgtDeleteProjectCoreTeam @IdTargetProject, @IdAssociate, @IdFunction
	IF (@@ERROR <> 0 OR @retVal < 0)
		BEGIN
			RETURN -2
		END	

	FETCH NEXT FROM DeleteOldCoreTeamCursor INTO @IdAssociate, @IdFunction
END

CLOSE DeleteOldCoreTeamCursor
DEALLOCATE DeleteOldCoreTeamCursor


-- Insert new core team members
DECLARE InsertCoreTeamCursor CURSOR FAST_FORWARD FOR
SELECT
	IdAssociate,
	IdFunction,
	IsActive
FROM PROJECT_CORE_TEAMS
WHERE IdProject = @IdProject

OPEN InsertCoreTeamCursor

FETCH NEXT FROM InsertCoreTeamCursor INTO @IdAssociate, @IdFunction, @IsActive
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC @retVal = bgtInsertProjectCoreTeam @IdTargetProject, @IdAssociate, @IdFunction, @IsActive
	IF (@@ERROR <> 0 OR @retVal < 0)
		BEGIN
			RETURN -3
		END	

	FETCH NEXT FROM InsertCoreTeamCursor INTO @IdAssociate, @IdFunction, @IsActive
END

CLOSE InsertCoreTeamCursor
DEALLOCATE InsertCoreTeamCursor

GO

--Drops the Procedure bgtDeleteCompletionBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.bgtDeleteCompletionBudgetStates') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteCompletionBudgetStates
GO

CREATE PROCEDURE bgtDeleteCompletionBudgetStates
	@IdProject 		INT,
	@BudVersion		CHAR(1),
	@IdAssociate	INT
AS
BEGIN
	declare @retVal int	

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@IdAssociate < 0 )
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -2
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -3
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)	
	
	DECLARE @IsValidated BIT,
			@IsPMProject BIT,	
			@IsBAOrTA BIT
	
	
	SELECT @IsValidated = IsValidated 
	FROM BUDGET_TOCOMPLETION 
	WHERE IdProject = @IdProject AND
	      IdGeneration = @IdGeneration
	
	SELECT @IsBAOrTA = dbo.fnCheckAssociateIsBaOrTa(@IdAssociate)
	SELECT @IsPMProject = dbo.fnCheckAssociateIsPM(@IdAssociate,@IdProject)
	
	IF((@IsBAOrTA=1 OR @IsPMProject=1) AND @IsValidated=0)
	BEGIN
		--1. delete all the data for the current associate	
		DELETE FROM BUDGET_TOCOMPLETION_DETAIL_COSTS	
		WHERE IdProject = @IdProject AND
		      IdGeneration = @IdGeneration AND
		      IdAssociate = @IdAssociate
	
	
		DELETE FROM BUDGET_TOCOMPLETION_DETAIL	
		WHERE IdProject = @IdProject AND
			  IdAssociate = @IdAssociate AND
			  IdGeneration = @IdGeneration
	
	
		DELETE FROM BUDGET_TOCOMPLETION_PROGRESS	
		WHERE IdProject = @IdProject AND
		      IdGeneration = @IdGeneration AND
		      IdAssociate = @IdAssociate

		DELETE FROM BUDGET_TOCOMPLETION_STATES	
		WHERE IdProject = @IdProject AND
		      IdGeneration = @IdGeneration AND
		      IdAssociate = @IdAssociate

		--2. recreate his data from the previous version
		EXEC @retVal = bgtToCompletionBudgetCreateNewFromCurrent @IdProject, @IdGeneration, @IdAssociate
		IF (@@ERROR <> 0 OR @retVal < 0)
		BEGIN
			raiserror ('There was error re-creating the budget for one active associate.',16,1)
			RETURN -4
		END
	END
	ELSE
	BEGIN
		RAISERROR('Either you do not have rights for this operations or the budget state does not permit it!',16,1)		
		RETURN -5
	END

END
GO






--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteCostCenterFromToCompletionBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteCostCenterFromToCompletionBudget
GO

CREATE  PROCEDURE bgtDeleteCostCenterFromToCompletionBudget
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT
AS
	

	--Get the new generation Id
	DECLARE @NewGeneration		INT
	DECLARE @CurrentGeneration	INT

	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'N')
	
	DECLARE @RetVal INT

	IF (@NewGeneration IS NULL)
	BEGIN
		SET @CurrentGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'C')
		IF (@CurrentGeneration IS NULL)
		BEGIN
			RAISERROR('No released generation found for To Completion budget', 16, 1)
			RETURN -1
		END
		SET @NewGeneration = @CurrentGeneration + 1
		
		EXEC @RetVal = bgtToCompletionBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -2
	END
	
	DELETE FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
	WHERE 	IdProject = @IdProject AND
		IdGeneration = @NewGeneration AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdCostCenter = @IdCostCenter AND
		IdAssociate = @IdAssociate

	DELETE FROM BUDGET_TOCOMPLETION_DETAIL
	WHERE 	IdProject = @IdProject AND
		IdGeneration = @NewGeneration AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdCostCenter = @IdCostCenter AND
		IdAssociate = @IdAssociate

	IF NOT EXISTS
	(
		SELECT 	IdProject FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE 	IdProject = @IdProject AND
			IdGeneration = @NewGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdAssociate = @IdAssociate
	)
	BEGIN
		DELETE 	FROM BUDGET_TOCOMPLETION_PROGRESS
		WHERE 	IdProject = @IdProject AND
			IdGeneration = @NewGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdAssociate = @IdAssociate
	END
GO

--Drops the Procedure bgtDeleteInitialBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteInitialBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteInitialBudgetDetail
GO

CREATE  PROCEDURE bgtDeleteInitialBudgetDetail
	@IdProject	INT,		--The Id of the selected Project
	@IdPhase	INT,		--The Id of a phase from project
	@IdWP		INT,		--The Id of workpackage
	@IdCostCenter	INT,		--The Id of cost center
	@IdAssociate	INT,		--The Id of associate
	@YearMonth	INT
	
AS
BEGIN
	--delete initial budget detail other costs
	DELETE FROM BUDGET_INITIAL_DETAIL_COSTS 
	WHERE IdProject = @IdProject
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdCostCenter = @IdCostCenter
		AND IdAssociate = @IdAssociate
		AND YearMonth = @YearMonth
	
	--delete initial budget detail
	DELETE FROM BUDGET_INITIAL_DETAIL
	WHERE IdProject = @IdProject
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdCostCenter = @IdCostCenter
		AND IdAssociate = @IdAssociate
		AND YearMonth = @YearMonth
END
GO

--Drops the Procedure bgtDeleteInitialBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteInitialBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteInitialBudgetStates
GO

CREATE PROCEDURE bgtDeleteInitialBudgetStates
	@IdProject 		INT, 	-- The Id of the Project
	@IdAssociate 	INT     -- The Id of Associate
	
AS
BEGIN
	IF (@IdProject < 0 )
		BEGIN 
			RAISERROR('No project has been selected',16,1)		
			RETURN -1
		END 
	
	IF (@IdAssociate < 0 )
		BEGIN 
			RAISERROR('No associate has been selected',16,1)		
			RETURN -2
		END 
	
	DECLARE @IsValidated BIT,
		@IsPMProject BIT,	
		@IsBAOrTA BIT
	
	
	SELECT @IsValidated = IsValidated 
	FROM BUDGET_INITIAL 
	WHERE IdProject = @IdProject
	
	SELECT @IsBAOrTA = dbo.fnCheckAssociateIsBaOrTa(@IdAssociate)
	SELECT @IsPMProject = dbo.fnCheckAssociateIsPM(@IdAssociate,@IdProject)
	
	IF((@IsBAOrTA=1 OR @IsPMProject=1) AND @IsValidated=0)
	BEGIN
	
		DELETE FROM BUDGET_INITIAL_DETAIL_COSTS
		WHERE IdProject = @IdProject AND
			IdAssociate = @IdAssociate
		
		DELETE FROM BUDGET_INITIAL_DETAIL
		WHERE IdProject = @IdProject AND
			IdAssociate = @IdAssociate
	
		UPDATE BUDGET_INITIAL_STATES
		SET State = 'N',
			StateDate = GetDate()
		WHERE IdProject = @IdProject AND
			IdAssociate = @IdAssociate
	END
	ELSE
	BEGIN
		RAISERROR('Either you do not have rights for this operations or the budget state does not permit it!',16,1)		
		RETURN -3
	END

END
GO




--Drops the Procedure bgtDeleteIntercoCountryLayout if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteIntercoCountryLayout]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteIntercoCountryLayout
GO
CREATE PROCEDURE bgtDeleteIntercoCountryLayout
	@IdProject		INT	
AS
	DELETE FROM PROJECTS_INTERCO_LAYOUT
	WHERE 	IdProject = @IdProject AND
		IdCountry IN
	(
		SELECT DISTINCT
			PIL.IdCountry		AS	'IdCountry'
		FROM PROJECTS_INTERCO AS [PI]
		INNER JOIN PROJECTS_INTERCO_LAYOUT PIL ON
			[PI].IdProject = PIL.IdProject AND
			[PI].IdCountry = PIL.IdCountry
		INNER JOIN WORK_PACKAGES AS WP ON 	[PI].IdWorkPackage = WP.[Id] AND
							[PI].IdProject = WP.IdProject AND
							[PI].IdPhase = WP.IdPhase
		
		WHERE 	([PI].IdProject = @IdProject) AND
		--The following condition is used to get only the WP that have timing information
			((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)) AND
			([PI].PercentAffected > 0) AND WP.IsActive = 1
	)
GO

--Drops the Procedure bgtDeleteProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteProjectCoreTeam]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteProjectCoreTeam
GO
CREATE PROCEDURE bgtDeleteProjectCoreTeam
	@IdProject 	AS INT, 	--The IdProject of the selected Project Core Team
	@IdAssociate	AS INT,		--The IdAssociate of the selected Project Core Team
	@IdFunction	AS INT		--The @IdFunction of the selected Project Core Team
AS
declare @rowcount int
--validate the FKs
	if 
	exists  (SELECT TOP 1 IdAssociate
		FROM BUDGET_INITIAL_DETAIL 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_INITIAL_DETAIL_COSTS 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_INITIAL_STATES 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
	BEGIN
		RAISERROR('The core team member can not be deleted because he/she has information defined in the Initial Budget',16,1)	
		RETURN
	END



	if 
	exists  (SELECT TOP 1 IdAssociate
		FROM BUDGET_REVISED_DETAIL 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_REVISED_DETAIL_COSTS 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_REVISED_STATES 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
	BEGIN
		RAISERROR('The core team member can not be deleted because he/she has information defined in the Revised Budget',16,1)
		RETURN
	END



	if 
	exists  (SELECT TOP 1 IdAssociate
		FROM BUDGET_TOCOMPLETION_DETAIL 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_TOCOMPLETION_DETAIL_COSTS 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_TOCOMPLETION_STATES 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
		OR
	exists	(SELECT TOP 1 IdAssociate
		FROM BUDGET_TOCOMPLETION_PROGRESS 
		WHERE	IdAssociate = @IdAssociate AND
			IdProject = @IdProject)
	BEGIN
		RAISERROR('The core team member can not be deleted because he/she has information defined in the Reforecast',16,1)
		RETURN
	END
--end validation section

	DELETE FROM PROJECT_CORE_TEAMS
	WHERE 	IdProject = @IdProject AND
		IdAssociate = @IdAssociate AND 
		IdFunction = @IdFunction

	SET @rowcount = @@ROWCOUNT
	RETURN @rowcount
GO
--Drops the Procedure bgtDeleteRevisedBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteRevisedBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteRevisedBudgetDetail
GO

CREATE  PROCEDURE bgtDeleteRevisedBudgetDetail
	@IdProject	INT,		--The Id of the selected Project
	@IdPhase	INT,		--The Id of a phase from project
	@IdWP		INT,		--The Id of workpackage
	@IdCostCenter	INT,		--The Id of cost center
	@IdAssociate	INT,		--The Id of associate
	@YearMonth	INT
	
AS
BEGIN
	DECLARE @CurrentGeneration INT
	DECLARE @CurrentHours INT
	DECLARE @CurrentVal DECIMAL(18, 4)  
	DECLARE @CurrentSales DECIMAL(18, 4)
	DECLARE @CurrentCosts DECIMAL(18, 2)

	SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	IF (@CurrentGeneration IS NULL)
	BEGIN
		RAISERROR('No released generation found for Revised Budget', 16, 1)
		RETURN -1
	END
	
	--isnull works here because the value is used only for checking
	SELECT 	@CurrentHours = SUM(ISNULL(HoursQty, 0)),
		@CurrentVal = SUM(ISNULL(HoursVal, 0)),
		@CurrentSales = SUM(ISNULL(SalesVal, 0))
	FROM 	BUDGET_REVISED_DETAIL
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdCostCenter = @IdCostCenter AND
		IdAssociate = @IdAssociate AND
		IdGeneration = @CurrentGeneration

	SELECT 	@CurrentCosts = SUM(ISNULL(CostVal, 0))
	FROM 	BUDGET_REVISED_DETAIL_COSTS
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdCostCenter = @IdCostCenter AND
		IdAssociate = @IdAssociate AND
		IdGeneration = @CurrentGeneration

	IF (	ISNULL(@CurrentHours, 0) <> 0 OR
		ISNULL(@CurrentVal, 0) <> 0 OR
		ISNULL(@CurrentSales, 0) <> 0 OR
		ISNULL(@CurrentCosts, 0) <> 0)
	BEGIN
		DECLARE @ccName varchar(70)
		DECLARE @err varchar(255)

		SELECT @ccName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
		FROM COST_CENTERS CC
		INNER JOIN DEPARTMENTS DP
			ON DP.[Id] = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		WHERE CC.Id = @IdCostCenter

		SEt @err ='Cost Center '+@ccName+' cannot be deleted because it is used in Released version.' 
		RAISERROR(@err, 16, 1)
		RETURN -2
	END
	
	
	DECLARE @IdGeneration INT
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	IF (@IdGeneration IS NULL)
	BEGIN
		RAISERROR('No new generation found for Revised Budget', 16, 1)
		RETURN -3
	END		

	--delete initial budget detail other costs
	DELETE FROM BUDGET_REVISED_DETAIL_COSTS 
	WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdCostCenter = @IdCostCenter
		AND IdAssociate = @IdAssociate
		AND YearMonth = @YearMonth
	
	--delete initial budget detail
	DELETE FROM BUDGET_REVISED_DETAIL
	WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdCostCenter = @IdCostCenter
		AND IdAssociate = @IdAssociate
		AND YearMonth = @YearMonth
END
GO

--Drops the Procedure bgtDeleteRevisedBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteRevisedBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteRevisedBudgetStates
GO

CREATE PROCEDURE bgtDeleteRevisedBudgetStates
	@IdProject 				INT,
	@BudVersion				CHAR(1),
	@IdAssociate			INT
AS
BEGIN	
	declare @retVal int	

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END

	IF (@IdAssociate < 0 )
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -2
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -3
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	DECLARE @IsValidated BIT,
			@IsPMProject BIT,	
			@IsBAOrTA BIT

	SELECT @IsValidated = IsValidated 
	FROM BUDGET_REVISED 
	WHERE IdProject = @IdProject AND
	      IdGeneration = @IdGeneration

	SELECT @IsBAOrTA = dbo.fnCheckAssociateIsBaOrTa(@IdAssociate)
	SELECT @IsPMProject = dbo.fnCheckAssociateIsPM(@IdAssociate,@IdProject)

	IF((@IsBAOrTA=1 OR @IsPMProject=1) AND @IsValidated=0)
	BEGIN
		--1. delete all the data for the current associate
		DELETE FROM BUDGET_REVISED_DETAIL_COSTS
		WHERE IdProject = @IdProject AND
		      IdGeneration = @IdGeneration AND
		      IdAssociate = @IdAssociate

		DELETE FROM BUDGET_REVISED_DETAIL
		WHERE IdProject = @IdProject AND
			  IdGeneration = @IdGeneration AND
			  IdAssociate = @IdAssociate
		
		DELETE BUDGET_REVISED_STATES 
		WHERE IdProject = @IdProject AND
			  IdGeneration = @IdGeneration AND
			  IdAssociate = @IdAssociate

		--2. recreate his data from the previous version
		EXEC @retVal = bgtRevisedBudgetCreateNewFromCurrent @IdProject, @IdGeneration, @IdAssociate
		IF (@@ERROR <> 0 or @retVal < 0)
		BEGIN
			RAISERROR ('There was error re-creating the budget for one active associate.',16,1)
			RETURN -4
		END		
	END
	ELSE
	BEGIN
		RAISERROR('Either you do not have rights for this operations or the budget state does not permit it!',16,1)		
		RETURN -5
	END
END
GO


--Drops the Procedure bgtDeleteWPTimingAndInterco if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtDeleteWPTimingAndInterco]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtDeleteWPTimingAndInterco
GO
CREATE PROCEDURE bgtDeleteWPTimingAndInterco
	@IdProject	AS INT, --The Id representing the Project connected to the selected Work Package
	@IdPhase	AS INT,	--The Id representing the Phase connected to the selected Work Package
	@Id 		AS INT 	--The Id of the selected Work Package
AS
	DECLARE @Rowcount 	INT,
	@ErrorMessage		VARCHAR(255),
	@MasterName  		VARCHAR(100),
	@ChildName		VARCHAR(100),	
	@ValidationResult	INT

	
	Select @ValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnCheckWPHasBudgetData(@IdProject, @IdPhase, @Id)

	if (@ValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end


	--DELETE first all entries in interco table
	DELETE FROM PROJECTS_INTERCO
	WHERE 	(IdProject = @IdProject) AND
		(IdPhase = @IdPhase) AND
		(IdWorkPackage = @Id)
	SET @Rowcount = @@ROWCOUNT

	IF @Rowcount=0
	BEGIN
		SET @ErrorMessage = 'Key information about at least one of project''s WPs was changed by another user. Please refresh your information.'	
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -2
	END

	UPDATE WORK_PACKAGES
	SET
		StartYearMonth = NULL,
		EndYearMonth = NULL
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		[Id] = @Id
	SET @Rowcount = @@ROWCOUNT
	
	
	
	RETURN @Rowcount
GO


--Drops the Procedure bgtFillExchangeRateCache if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtFillExchangeRateCache]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtFillExchangeRateCache
GO
CREATE PROCEDURE bgtFillExchangeRateCache
	@CurrencyFrom		INT,	--The CurrencyFrom of the selected Exchange Rate
	@CurrencyTo			INT,	--The CurrencyTo of the selected Exchange Rate
	@StartYearMonth		INT,	--The Start Year and Month on which Exchange Rates will be selected
	@EndYearMonth		INT		--The End Year and Month on which Exchange Rates will be selected
AS
	DECLARE @CurrentYearMonth INT,
			@ConversionRate   DECIMAL(10,4)

	CREATE TABLE #ER_TEMP
	(YearMonth 		   INT 			  NOT NULL, 
	 ExchangeRateValue DECIMAL(10, 4) NOT NULL)



	DECLARE YearMonthCursor CURSOR FAST_FORWARD FOR
	SELECT DISTINCT YearMonth
	FROM EXCHANGE_RATES
	WHERE 	(IdCurrencyTo = @CurrencyFrom OR
			IdCurrencyTo = @CurrencyTo) AND
			YearMonth BETWEEN @StartYearMonth AND @EndYearMonth
	ORDER BY YearMonth

	OPEN YearMonthCursor
	
	FETCH NEXT FROM YearMonthCursor
	INTO @CurrentYearMonth

	WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @ConversionRate = dbo.fnGetExchangeRate(@CurrencyFrom, @CurrencyTo, @CurrentYearMonth)

		IF (@ConversionRate IS NOT NULL)
		BEGIN
			INSERT INTO #ER_TEMP (YearMonth, ExchangeRateValue)
			VALUES (@CurrentYearMonth, @ConversionRate)
		END

		FETCH NEXT FROM YearMonthCursor
		INTO @CurrentYearMonth
	END
	CLOSE YearMonthCursor
	DEALLOCATE YearMonthCursor

	SELECT * FROM #ER_TEMP

GO

--Drops the Procedure bgtGetAffectedWPInterco if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetAffectedWPInterco]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetAffectedWPInterco
GO
CREATE PROCEDURE bgtGetAffectedWPInterco
	@IdProject 		AS INT 	--The Id of the Project
AS
	--TODO: Remove null values
	--Get's the master table for the Period TAB (from GUI). This table contains only information
	-- about the phases. 
	SELECT DISTINCT
		NULL 		AS	'IdProject',
		[PH].[Id]	AS	'IdPhase',
		[PH].Code	AS	'PhaseCode',
		[PH].[Name]	AS	'PhaseName',
		NULL		AS	'IdWP',
		NULL		AS	'WPCode'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.[Id]
	--The following join is used to get only the WP that have interco information
	INNER JOIN PROJECTS_INTERCO AS [PI] ON 	([PI].IdProject = WP.IdProject) AND
						([PI].IdPhase = WP.IdPhase) AND
						([PI].IdWorkPackage = WP.[Id]) 
	WHERE 	(WP.IdProject = @IdProject) AND
	--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)
		AND WP.IsActive = 1)
	ORDER BY [PH].Code	

	CREATE TABLE #IntercoTemp
	(
		IdProject	INT,
		IdPhase		INT,
		IdWP		INT,
		WPCode		VARCHAR(3),
		WPName		VARCHAR(30),
		PhaseCode	VARCHAR(3),
		HasBudget	BIT DEFAULT 0
		PRIMARY KEY (IdProject,IdPhase,IdWP)
	)

	--Get's the base structure of the detail table. This table will have additional columns build
	--on server from the third recordset returned by this procedure
	INSERT INTO #IntercoTemp  (IdProject, IdPhase, IdWP,WPCode,WPName,PhaseCode)
	SELECT DISTINCT
		[WP].IdProject 		AS	'IdProject',
		[WP].IdPhase		AS	'IdPhase',
		[WP].[Id]		AS	'IdWP',
		[WP].Code 		AS	'WPCode',
		[WP].[Name]		AS	'WPName',
		[PH].Code		AS	'PhaseCode'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.[Id]
	--The following join is used to get only the WP that have interco information
	INNER JOIN PROJECTS_INTERCO AS [PI] ON 	([PI].IdProject = WP.IdProject) AND
						([PI].IdPhase = WP.IdPhase) AND
						([PI].IdWorkPackage = WP.[Id]) 
	WHERE 	(WP.IdProject = @IdProject) AND
		--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)
		AND WP.IsActive = 1)	
	--DO NOT modify this ORDER BY as it is used in the upper layers
	ORDER BY PH.[Code], WP.[Id]
	
	UPDATE #IntercoTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_INITIAL_DETAIL AS BID
		WHERE  	BID.IdProject = #IntercoTemp.IdProject AND
			BID.IdPhase = #IntercoTemp.IdPhase AND
			BID.IdWorkPackage = #IntercoTemp.IdWP
	)

	UPDATE #IntercoTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_REVISED_DETAIL AS BRD
		WHERE  	BRD.IdProject = #IntercoTemp.IdProject AND
			BRD.IdPhase = #IntercoTemp.IdPhase AND
			BRD.IdWorkPackage = #IntercoTemp.IdWP
	)
	
	UPDATE #IntercoTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_TOCOMPLETION_DETAIL AS BTD
		WHERE  	BTD.IdProject = #IntercoTemp.IdProject AND
			BTD.IdPhase = #IntercoTemp.IdPhase AND
			BTD.IdWorkPackage = #IntercoTemp.IdWP
	)

	SELECT 
		IdProject 	AS 	'IdProject',
		IdPhase		AS	'IdPhase',
		IdWP		AS	'IdWP',
		WPCode		AS	'WPCode',
		WPName		AS	'WPName',
		PhaseCode	AS	'PhaseCode',
		HasBudget	AS	'HasBudget'
	FROM #IntercoTemp

	--Get's the data from the PROJECTS_INTERCO table needed to create the additional columns for
	--for the detail table
	SELECT
		[PI].IdProject		AS	'IdProject',
		[PI].IdPhase		AS	'IdPhase',
		[PP].Code		AS	'PhaseName',
		[PI].IdWorkPackage	AS	'IdWP',
		[WP].Code		AS	'WPName',
		[PI].IdCountry		AS	'IdCountry',
		[PI].PercentAffected	AS	'Percent'
	FROM PROJECTS_INTERCO AS [PI]
	INNER JOIN PROJECT_PHASES AS PP ON [PI].IdPhase = PP.[Id]
	INNER JOIN WORK_PACKAGES AS WP ON 	[PI].IdWorkPackage = WP.[Id] AND
						[PI].IdProject = WP.IdProject AND
						[PI].IdPhase = WP.IdPhase
	WHERE 	([PI].IdProject = @IdProject) AND
	--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)) AND
		([PI].PercentAffected > 0) AND WP.IsActive = 1
	--DO NOT modify this ORDER BY as it is used in the upper layers
	ORDER BY [PI].IdPhase, [PI].IdWorkPackage
GO

--Drops the Procedure bgtGetAffectedWPTiming if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetAffectedWPTiming]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetAffectedWPTiming
GO
CREATE PROCEDURE bgtGetAffectedWPTiming
	@IdProject 		AS INT 	--The Id of the Project
AS
	--Get's the master table for the Timing TAB (from GUI). This table contains only information
	-- about the phases. 
	SELECT DISTINCT
		[WP].IdProject	AS	'IdProject',
		[PH].[Id]	AS	'IdPhase',
		[PH].Code	AS	'PhaseCode',
		[PH].[Name]	AS	'PhaseName',
		NULL		AS	'IdWP',
		NULL		AS	'WPCode',
		NULL		AS	'StartYearMonth',
		NULL		AS	'EndYearMonth'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.[Id]
	--The following join is used to get only the WP that have interco information
	INNER JOIN PROJECTS_INTERCO AS [PI] ON 	([PI].IdProject = WP.IdProject) AND
						([PI].IdPhase = WP.IdPhase) AND
						([PI].IdWorkPackage = WP.[Id]) 
	WHERE 	(WP.IdProject = @IdProject) AND
		--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)
		AND WP.IsActive = 1)
	ORDER BY PH.Code	

	CREATE TABLE #TimingTemp
	(
		IdProject	INT,
		IdPhase		INT,
		PhaseCode	VARCHAR(3),
		IdWP		INT,
		WPCode		VARCHAR(3),
		WPName		VARCHAR(30),
		StartYearMonth	INT,
		EndYearMonth	INT,
		LastUserUpdate	VARCHAR(50),
		LastUpdate	DATETIME,
		HasBudget	BIT DEFAULT 0
		PRIMARY KEY (IdProject,IdPhase,IdWP)
	)

	INSERT INTO #TimingTemp  (IdProject, IdPhase, PhaseCode,IdWP,WPCode,WPName,StartYearMonth,EndYearMonth,LastUserUpdate, LastUpdate)
	--Gets the detail table for Timing functionality
	SELECT DISTINCT
		[WP].IdProject 		AS	'IdProject',
		[WP].IdPhase		AS	'IdPhase',
		[PH].Code		AS	'PhaseCode',
		[WP].[Id]		AS	'IdWP',
		WP.Code			AS	'WPCode',
		WP.[Name]		AS	'WPName',
		WP.StartYearMonth	AS	'StartYearMonth',
		WP.EndYearMonth		AS	'EndYearMonth',
		ASOC.[Name]		AS	'LastUserUpdate',
		WP.LastUpdate		AS	'LastUpdate'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.[Id]
	--The following join is used to get only the WP that have interco information
	INNER JOIN PROJECTS_INTERCO AS [PI] ON 	([PI].IdProject = WP.IdProject) AND
						([PI].IdPhase = WP.IdPhase) AND
						([PI].IdWorkPackage = WP.[Id])
	INNER JOIN ASSOCIATES AS ASOC ON ASOC.[Id] = WP.LastUserUpdate 
	WHERE 	(WP.IdProject = @IdProject) AND
		--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)
		AND WP.IsActive = 1)	
	ORDER BY PH.Code, WP.Code

	UPDATE #TimingTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_INITIAL_DETAIL AS BID
		WHERE  	BID.IdProject = #TimingTemp.IdProject AND
			BID.IdPhase = #TimingTemp.IdPhase AND
			BID.IdWorkPackage = #TimingTemp.IdWP
	)

	UPDATE #TimingTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_REVISED_DETAIL AS BRD
		WHERE  	BRD.IdProject = #TimingTemp.IdProject AND
			BRD.IdPhase = #TimingTemp.IdPhase AND
			BRD.IdWorkPackage = #TimingTemp.IdWP
	)
	
	UPDATE #TimingTemp 
	SET HasBudget = 1
	WHERE EXISTS
	(
		SELECT TOP 1 IdWorkPackage FROM BUDGET_TOCOMPLETION_DETAIL AS BTD
		WHERE  	BTD.IdProject = #TimingTemp.IdProject AND
			BTD.IdPhase = #TimingTemp.IdPhase AND
			BTD.IdWorkPackage = #TimingTemp.IdWP
	)


	SELECT 
		IdProject 		AS	'IdProject',
		IdPhase			AS	'IdPhase',
		PhaseCode		AS	'PhaseCode',
		IdWP			AS	'IdWP',
		WPCode			AS	'WPCode',
		WPName			AS	'WPName',
		StartYearMonth		AS	'StartYearMonth',
		EndYearMonth		AS	'EndYearMonth',
		LastUserUpdate		AS	'LastUserUpdate',
		LastUpdate		AS	'LastUpdate',
		HasBudget		As	'HasBudget'
	FROM #TimingTemp

	
GO

--Drops the Procedure bgtGetCompletionBudgetStateForEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetCompletionBudgetStateForEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetCompletionBudgetStateForEvidence
GO



-- bgtGetRevisedBudgetStateForEvidence 7,'P',4

CREATE        PROCEDURE bgtGetCompletionBudgetStateForEvidence
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1), 
	@IdAssociate		AS INT 			
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END	

	IF(@IdAssociate<0)
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -3
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)

	
	SELECT 	
		ISNULL(State,'N') AS 'StateCode'

	FROM BUDGET_TOCOMPLETION_STATES 
 	WHERE IdProject = @IdProject AND IdGeneration = @IdGeneration AND IdAssociate = @IdAssociate 




GO

--Drops the Procedure bgtGetCompletionBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetCompletionBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetCompletionBudgetStates
GO


-- sp_helptext bgtGetCompletionBudgetStates
-- bgtGetCompletionBudgetStates 2,'N'

CREATE        PROCEDURE bgtGetCompletionBudgetStates
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)	
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)
	
	DECLARE @temptable table
	(
		IDPROJECT INT,
		IDASSOCIATE INT,
		IDGENERATION INT,
		AssociateName VARCHAR(50),
		AssociatePF VARCHAR(50),
		IsActive BIT,
		Rank INT
	)	

--Get's the table for Revised FollowUp Budget (from GUI). 

	INSERT INTO @temptable (IDPROJECT, IDASSOCIATE, IDGENERATION, AssociateName, AssociatePF, IsActive, Rank)		
	SELECT PCT.IDPROJECT, PCT.IDASSOCIATE,  BC.IDGENERATION , A.Name, PF.Name, PCT.IsActive, PF.Rank
	FROM PROJECT_CORE_TEAMS PCT 
	LEFT JOIN BUDGET_TOCOMPLETION BC 
		ON  PCT.IDPROJECT = BC.IDPROJECT
	LEFT JOIN ASSOCIATES A 
		ON PCT.IDAssociate = A.ID
	LEFT JOIN PROJECT_FUNCTIONS PF
		ON PCT.IDFunction = PF.ID
	WHERE 	PCT.IDPROJECT = @IdProject AND 
		BC.IDGENERATION = @IdGeneration AND 
		ISNULL(A.IsActive,0) = 1


	SELECT t.IdProject  			AS 'IDProject',
		t.IdAssociate			AS 'IDAssociate',
		t.IdGeneration			AS 'IDGeneration',
		t.AssociateName			AS 'Associate',
		t.AssociatePF			AS 'Project Function',
		BCS.StateDate			AS 'StateDate',
		ISNULL(BCS.State,'N')		AS 'StateCode',
		BS.Description			AS 'State',
		case when BCS.State is null then 0 else 1 end	AS 'HasData'

		
	FROM @temptable t 
	LEFT JOIN BUDGET_TOCOMPLETION_STATES BCS
		ON t.IdProject = BCS.IdProject
		AND t.IDAssociate = BCS.IdAssociate
		AND t.IdGeneration = BCS.IdGeneration
	LEFT JOIN BUDGET_STATES BS
		ON ISNULL(BCS.State,'N')  = BS.StateCode
	WHERE 	t.IDProject = @IdProject AND 
		t.IdGeneration = @IdGeneration AND 
		ISNULL(t.IsActive,0) = 1
	ORDER BY t.Rank, t.AssociateName




GO





--Drops the Procedure bgtGetCompletionScalarValidState if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetCompletionScalarValidState]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetCompletionScalarValidState
GO



-- bgtGetCompletionScalarValidState 7,'C'

CREATE        PROCEDURE bgtGetCompletionScalarValidState
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)		
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)

	
	SELECT 	
		ISNULL(IsValidated,0) AS 'IsValidated'

	FROM BUDGET_TOCOMPLETION 
	WHERE IdProject = @IdProject AND IdGeneration = @IdGeneration 



GO


--Drops the Procedure bgtGetCopyTeamTargetProjectsForPM if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetCopyTeamTargetProjectsForPM]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetCopyTeamTargetProjectsForPM
GO

CREATE  PROCEDURE bgtGetCopyTeamTargetProjectsForPM
	@IdProject		INT,
	@IdAssociate		INT
AS

DECLARE @IdFunction INT --Project Manager
SET @IdFunction = 1

SELECT
	P.Id		AS 'IdProject',
	P.Code		AS 'ProjectCode',
	P.Name		AS 'ProjectName',
	T.TeamMembers 	AS 'TeamMembers'
FROM PROJECTS P
INNER JOIN PROJECT_CORE_TEAMS PCT
	ON PCT.IdProject = P.Id
INNER JOIN (SELECT IdProject, COUNT(IdAssociate) AS 'TeamMembers' FROM PROJECT_CORE_TEAMS GROUP BY IdProject) T
	ON T.IdProject = P.Id
LEFT JOIN BUDGET_INITIAL_DETAIL BID
	ON BID.IdProject = P.Id
LEFT JOIN BUDGET_INITIAL_DETAIL_COSTS BIDC
	ON BIDC.IdProject = P.Id
LEFT JOIN BUDGET_INITIAL_STATES BIS
	ON BIS.IdProject = P.Id
LEFT JOIN BUDGET_REVISED_DETAIL BRD
	ON BRD.IdProject = P.Id
LEFT JOIN BUDGET_REVISED_DETAIL_COSTS BRDC
	ON BRDC.IdProject = P.Id
LEFT JOIN BUDGET_REVISED_STATES BRS
	ON BRS.IdProject = P.Id
LEFT JOIN BUDGET_TOCOMPLETION_DETAIL BCD
	ON BCD.IdProject = P.Id
LEFT JOIN BUDGET_TOCOMPLETION_DETAIL_COSTS BCDC
	ON BCDC.IdProject = P.Id
LEFT JOIN BUDGET_TOCOMPLETION_STATES BCS
	ON BCS.IdProject = P.Id
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP
	ON BCP.IdProject = P.Id
WHERE 	P.Id <> @IdProject AND
	PCT.IdAssociate = @IdAssociate AND
	PCT.IsActive = 1 AND
	PCT.IdFunction = @IdFunction AND
	(BID.IdProject IS NULL AND BIDC.IdProject IS NULL AND BIS.IdProject IS NULL) AND
	(BRD.IdProject IS NULL AND BRDC.IdProject IS NULL AND BRS.IdProject IS NULL) AND
	(BCD.IdProject IS NULL AND BCDC.IdProject IS NULL AND BCS.IdProject IS NULL AND BCP.IdProject IS NULL)

GO

--Drops the Procedure bgtGetInitialBudgetEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.bgtGetInitialBudgetEvidence') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetInitialBudgetEvidence
GO

CREATE  PROCEDURE bgtGetInitialBudgetEvidence
	@IdProject				INT,
	@IdAssociate			INT, --The Id of associate that the budget belongs to
	@IdAssociateViewer		INT, --The Id of the associate viewing the budget
	@IsAssociateCurrency	BIT,
	@IdCountry		INT,
	@IdCurrencyDisplay		int = 0		
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.Id = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)
	
	--Find out the associate currency of the viewer
	if @IdCurrencyDisplay <= 0 
	   begin
	   -- if Currency wasn't specified on the page, then relies on the currency of the viewer
			SELECT  @AssociateCurrency = CTR.IdCurrency,
					@AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES AS ASOC
			INNER JOIN COUNTRIES AS CTR ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES AS CRR ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
	   begin
	   -- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
					@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay

	   end

	--Selects the data for the third table and put it in a temportary table that will be used for 
	--JOINS for the first 2 tables

	
	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_INITIAL
	WHERE	IdProject = @IdProject

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		DECLARE BudgetCursor CURSOR FAST_FORWARD FOR
		SELECT 
			BPT.IdProject	AS 	'IdProject',
			BPT.IdPhase		AS	'IdPhase',
			BPT.IdWP		AS 	'IdWP',
			CURR.Id 		AS	'IdCurrency',
			CURR.Code		AS	'CurrencyCode',
			BID.YearMonth	AS	'YearMonth'
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.Id = BPT.IdWP
		LEFT JOIN BUDGET_INITIAL_DETAIL AS BID
			ON BID.IdProject = BPT.IdProject
			AND BID.IdPhase = BPT.IdPhase
			AND BID.IdWorkPackage = BPT.IdWP  
			AND BID.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BID.IdAssociate ELSE @IdAssociate END
		INNER JOIN PROJECT_CORE_TEAMS CTM
			ON CTM.IdProject = BID.IdProject
			AND CTM.IdAssociate = BID.IdAssociate		
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BID.IdCostCenter
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.Id = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.Id = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
				ON CURR.Id = COUNTRIES.IdCurrency
		WHERE  CTM.IsActive = CASE WHEN (@IdAssociate =-1  AND @IsBudgetValidated = 0) THEN 1 ELSE CTM.IsActive END


		OPEN BudgetCursor
		DECLARE @CheckIdProject INT
		DECLARE @CheckIdPhase INT
		DECLARE @CheckIdWP 	INT
		DECLARE @IdCurrency INT
		DECLARE @YearMonth INT
		DECLARE @CurrencyCode VARCHAR(10)
		DECLARE @ER DECIMAL(12,6) = 0
	
		FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
		WHILE @@FETCH_STATUS = 0
		BEGIN

			SELECT @ER = dbo.fnGetExchangeRate(@AssociateCurrency, 	@IdCurrency, @YearMonth)

			IF (@ER IS NULL)
			BEGIN
				DECLARE @WpName VARCHAR(30)
				DECLARE @StartYM INT
				DECLARE @EndYM	INT
				SELECT 	@WpName = Code + ' - ' + Name,
					@StartYM = StartYearMonth,
					@EndYM = EndYearMonth
				FROM 	WORK_PACKAGES
				WHERE	IdProject = @CheckIdProject AND
					IdPhase = @CheckIdPhase AND
					Id = @CheckIdWP

				DECLARE @YM VARCHAR(7)
				DECLARE @SYM VARCHAR(7)
				DECLARE @EYM VARCHAR(7)
				SELECT @YM = dbo.fnGetYMStringRepresentation(@YearMonth)
				SELECT @SYM = dbo.fnGetYMStringRepresentation(@StartYM)
				SELECT @EYM = dbo.fnGetYMStringRepresentation(@EndYM)
				RAISERROR('No exchange rate found for %s to %s conversion for YearMonth %s (Work Package %s, period %s - %s).',
					16,1, @AssociateCurrencyCode,@CurrencyCode, @YM, @WpName, @SYM, @EYM )
				CLOSE BudgetCursor
				DEALLOCATE BudgetCursor
				RETURN -2
			END
		   	FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
			
		END
		CLOSE BudgetCursor
		DEALLOCATE BudgetCursor
	END

	
	SELECT 
		BPT.IdProject							AS 'IdProject',
		BPT.IdPhase 							AS 'IdPhase',
		BPT.IdWP								AS 'IdWP',
		CC.Id									AS 'IdCostCenter',
		DP.Name+'-'+IL.Code+'-'+CC.Code			AS 'CostCenterName',
		SUM(BID.HoursQty)						AS 'HoursQty',
		CAST(0 as Decimal(18,4))				AS 'Averate',
		SUM(CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.Id,@AssociateCurrency,BID.YearMonth) ELSE 1	END 
			* BID.HoursVal)						AS 'HoursVal',
		SUM(CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0  THEN dbo.fnGetExchangeRate(CURR.Id,@AssociateCurrency,BID.YearMonth) ELSE 1	END 
			* ISNULL(dbo.fnGetInitialOtherCosts(BID.IdProject,BID.IdPhase,BID.IdWorkPackage	,BID.IdCostCenter,BID.IdAssociate,BID.YearMonth),0)) 									
												AS 'OtherCosts',
		SUM(CASE WHEN @IsAssociateCurrency = 1   or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.Id,@AssociateCurrency,BID.YearMonth) ELSE 1	END 
			* BID.SalesVal)						AS 'SalesVal',	
		CAST(0 as Decimal(19,4))				AS 'NetCosts',
		CURR.Id									AS 'IdCurrency',
		CURR.Code								AS 'CurrencyCode',
		DP.Rank									AS 'DeptRank'
	INTO #BUDGET_INITIAL_DETAIL_TEMP
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	LEFT JOIN BUDGET_INITIAL_DETAIL AS BID
		ON BID.IdProject = BPT.IdProject AND
			BID.IdPhase = BPT.IdPhase AND
			BID.IdWorkPackage = BPT.IdWP AND 
			BID.IdAssociate = CASE 	WHEN @IdAssociate = -1 THEN BID.IdAssociate ELSE @IdAssociate	END
	INNER JOIN PROJECT_CORE_TEAMS CTM
		ON CTM.IdProject = BID.IdProject AND
		   CTM.IdAssociate = BID.IdAssociate	
	INNER JOIN COST_CENTERS CC
		ON CC.Id = BID.IdCostCenter
	INNER JOIN DEPARTMENTS DP
		ON DP.Id = CC.IdDepartment
	INNER JOIN INERGY_LOCATIONS IL
		ON IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES
		ON COUNTRIES.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR 
		ON CURR.Id = COUNTRIES.IdCurrency
	WHERE CTM.IsActive = CASE  WHEN (@IdAssociate = -1 AND @IsBudgetValidated = 0) THEN  1 ELSE CTM.IsActive END
		AND COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, CC.Id, CC.Code, CURR.Id, CURR.Code, DP.Name, Il.Code, DP.Rank
	

	--update phrase for differences (other cost is always non null - because of the 0 link necessary in the interface)
	UPDATE #BUDGET_INITIAL_DETAIL_TEMP
	SET NetCosts = ISNULL(HoursVal, 0) + ISNULL(OtherCosts,0) + ISNULL(SalesVal,0),
		Averate = CASE WHEN ISNULL(HoursQty,0)=0 THEN NULL ELSE HoursVal/HoursQty END

	--first select for phases
	SELECT 
		BPT.IdProject 					AS 'IdProject',
		PP.Id 							AS 'IdPhase',
		PP.Code + ' - ' + PP.Name 		AS 'PhaseName',
		SUM(BID.HoursQty)				AS 'TotalHours',
		CASE WHEN ISNULL(SUM(BID.HoursQty),0) = 0 THEN NULL
				ELSE ROUND(SUM(ROUND(BID.HoursVal, 0)) / SUM(BID.HoursQty), 0) END AS 'Averate',
		SUM(ROUND(BID.HoursVal, 0))		AS 'ValuedHours',
		SUM(ROUND(BID.OtherCosts, 0)) 	AS 'OtherCosts',
		SUM(ROUND(BID.SalesVal, 0)) 	AS 'Sales',
		SUM(ROUND(BID.NetCosts, 0))		AS 'NetCosts'
	FROM #BUDGET_PRESELECTION_TEMP BPT 
	INNER JOIN PROJECT_PHASES PP
		ON PP.Id = BPT.IdPhase
	LEFT JOIN #BUDGET_INITIAL_DETAIL_TEMP BID
		 ON BID.IdProject = BPT.IdProject AND
			BID.IdPhase = BPT.IdPhase AND
			BID.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, PP.Id, PP.Name, PP.Code

	--second select for workpackages
	SELECT 
		BPT.IdProject					AS 'IdProject',
		BPT.IdPhase 					AS 'IdPhase',
		BPT.IdWP						AS 'IdWP',
		WP.Code					AS 'WPCode',	
		WP.Code + ' - ' + WP.Name		AS 'WPName',
		WP.StartYearMonth				AS 'StartYearMonth',
		WP.EndYearMonth					AS 'EndYearMonth',
		SUM(BID.HoursQty)				AS 'TotalHours',
		CASE WHEN ISNULL(SUM(BID.HoursQty),0) = 0 THEN NULL
			ELSE ROUND(SUM(ROUND(BID.HoursVal, 0))/SUM(BID.HoursQty), 0) END AS 'Averate',
		SUM(ROUND(BID.HoursVal, 0))		AS 'ValuedHours',
		SUM(ROUND(BID.OtherCosts, 0)) 	AS 'OtherCosts',
		SUM(ROUND(BID.SalesVal, 0)) 	AS 'Sales',
		SUM(ROUND(BID.NetCosts, 0))		AS 'NetCosts',
		WP.IsActive						AS 'IsActive'
	FROM #BUDGET_PRESELECTION_TEMP BPT 
	INNER JOIN WORK_PACKAGES WP 
		ON WP.IdProject = BPT.IdProject AND
		   WP.IdPhase = BPT.IdPhase AND
		   WP.Id = BPT.IdWP
	LEFT JOIN #BUDGET_INITIAL_DETAIL_TEMP BID 
		ON 	BID.IdProject = BPT.IdProject AND
			BID.IdPhase = BPT.IdPhase AND
			BID.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, WP.Name, WP.StartYearMonth, WP.EndYearMonth, WP.Code, WP.IsActive
	
	--third select for costcenters
	SELECT 
		IdProject			AS	'IdProject',
		IdPhase				AS	'IdPhase',
		IdWP				AS	'IdWP',
		IdCostCenter		AS	'IdCostCenter',
		CostCenterName		AS	'CostCenterName',
		HoursQty			AS	'TotalHours',
		Averate				AS	'Averate',
		HoursVal			AS	'ValuedHours',
		OtherCosts			AS	'OtherCosts',
		SalesVal			AS	'Sales',
		NetCosts			AS	'NetCosts',
		IdCurrency			AS	'IdCurrency',
		CurrencyCode		AS	'CurrencyCode'
	FROM 	#BUDGET_INITIAL_DETAIL_TEMP
	ORDER BY DeptRank, CostCenterName


GO


--Drops the Procedure bgtGetInitialBudgetOtherCost if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetInitialBudgetOtherCost]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetInitialBudgetOtherCost
GO

CREATE  PROCEDURE bgtGetInitialBudgetOtherCost
	@IdProject				INT,		--The Id of the selected Project
	@IdPhase				INT,		--The Id of a phase from project
	@IdWP					INT,		--The Id of workpackage
	@IdCostCenter			INT,		--The Id of cost center
	@IdAssociate			INT,		--The Id of associate the budget belongs to
	@IdAssociateViewer		INT,		--The Id of associate viewing the budget
	@IsAssociateCurrency 	BIT,			--Specifies whether the values will be converted from the cost center
									--currency to the associate currency
	@IdCurrencyDisplay		int = 0
	
AS
BEGIN

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0


	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	--Find out the associate currency
	if @IdCurrencyDisplay <= 0
	   begin
			SELECT 	@AssociateCurrency = CTR.IdCurrency,
					@AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES ASOC
			INNER JOIN COUNTRIES CTR 
				ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES AS CRR 
				ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
	   begin
	   -- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
					@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
	   end


	SELECT 	BID_SUM.IdProject	AS 'IdProject',
		BID_SUM.IdPhase		AS 'IdPhase',
		BID_SUM.IdWorkPackage	AS 'IdWP',
		BID_SUM.IdCostcenter	AS 'IdCostCenter',
		BCT.[Id]		AS 'IdOtherCost',
		BCT.[Name]		AS 'OtherCostType',
		BID_SUM.AllOtherCosts   AS 'OtherCostVal',
		CURR.[Id]		AS 'IdCurrency',
		CURR.[Name]		AS 'CurrencyName'
		
	FROM (	SELECT 	BID.IdProject,
			BID.IdPhase,
			BID.IdWorkPackage,
			BID.IdCostCenter,
			BID.IdAssociate,
			BIDC.IdCostType,
			SUM(
				CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0
				THEN
					dbo.fnGetExchangeRate(CURR.Id, @AssociateCurrency, BIDC.YearMonth)
				ELSE
					1
				END * BIDC.CostVal
			)	AS 'AllOtherCosts'
		FROM 	BUDGET_INITIAL_DETAIL BID
		LEFT JOIN BUDGET_INITIAL_DETAIL_COSTS BIDC
			ON BIDC.IdProject = BID.IdProject
				AND BIDC.IdPhase = BID.IdPhase
				AND BIDC.IdWorkPackage = BID.IdWorkPackage
				AND BIDC.IdCostCenter = BID.IdCostCenter
				AND BIDC.IdAssociate = BID.IdAssociate
				AND BIDC.YearMonth = BID.YearMonth
		INNER JOIN COST_CENTERS CC 
			ON CC.Id = BID.IdCostCenter
		INNER JOIN INERGY_LOCATIONS IL 
			ON IL.Id = CC.IdInergyLocation
		INNER JOIN COUNTRIES 
			ON COUNTRIES.Id = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.Id=COUNTRIES.IdCurrency
		WHERE	BID.IdProject = @IdProject
			AND BID.IdPhase = @IdPhase
			AND BID.IdWorkPackage = @IdWP
			AND BID.IdCostCenter = @IdCostCenter
			AND BID.IdAssociate = @IdAssociate
		GROUP BY BID.IdProject,BID.IdPhase,BID.IdWorkPackage,
			BID.IdCostCenter,BID.IdAssociate,BIDC.IdCostType			
	)AS BID_SUM
	INNER JOIN BUDGET_COST_TYPES BCT
		ON BCT.Id = BID_SUM.IdCostType
	INNER JOIN COST_CENTERS CC 
		ON CC.Id = BID_SUM.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL 
		ON CC.IdInergyLocation = IL.Id
	INNER JOIN COUNTRIES
		ON IL.IdCountry = COUNTRIES.Id
	INNER JOIN CURRENCIES CURR 
		ON CURR.Id=COUNTRIES.IdCurrency
END

GO

--Drops the Procedure bgtGetInitialBudgetStateForEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetInitialBudgetStateForEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetInitialBudgetStateForEvidence
GO



CREATE      PROCEDURE bgtGetInitialBudgetStateForEvidence

	@IdProject 		AS INT,
	@IdAssociate		AS INT
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 

	IF(@IdAssociate<0)
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -2
	END 
	--Get the state for Budget Initial Evidence


-- 	--the Role of BA or TA has special access rights - they may see all the projects
	IF NOT EXISTS 
	(
		SELECT 	ISNULL(BIS.State,'N') AS 'StateCode',
			BS.Description as 'Description'			
		FROM Project_Core_Teams CTM
			LEFT JOIN  Budget_Initial_States BIS
				ON 	CTM.IdProject = BIS.IdProject AND
					CTM.IdAssociate = BIS.IdAssociate			
			LEFT JOIN BUDGET_STATES BS 
				ON BIS.STATE = BS.StateCode	
		WHERE CTM.IdProject = @IdProject AND CTM.IdAssociate = @IdAssociate
	)
	BEGIN

		-- THIS IS FOR EXCEPTION CASE WHEN THERE ARE DATA IN BUDGET_INITIAL_DETAIL BUT
		--FEATURE FOR INSERTING BUDGET_STATE WAS NOT IMPLEMENTED
		IF EXISTS(SELECT * FROM BUDGET_INITIAL_DETAIL WHERE IdProject = @IdProject 
				AND IdAssociate = @IdAssociate)
		BEGIN
			SELECT TOP 1 'O' as 'StateCode', 'Open' as 'Description' FROM BUDGET_STATES
		END
		ELSE
		BEGIN
			SELECT TOP 1 'N' AS 'StateCode', 'None' as 'Description' FROM BUDGET_STATES
		END

	END
	ELSE
	BEGIN
		SELECT 	ISNULL(BIS.State,'N') AS 'StateCode',
			BS.Description as 'Description'			
		FROM Project_Core_Teams CTM
			LEFT JOIN  Budget_Initial_States BIS
				ON 	CTM.IdProject = BIS.IdProject AND
					CTM.IdAssociate = BIS.IdAssociate			
			LEFT JOIN BUDGET_STATES BS 
				ON BIS.STATE = BS.StateCode	
		WHERE CTM.IdProject = @IdProject AND CTM.IdAssociate = @IdAssociate
	END






GO



--Drops the Procedure bgtGetInitialBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetInitialBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetInitialBudgetStates
GO



-- bgtGetInitialBudgetStates 1

CREATE        PROCEDURE bgtGetInitialBudgetStates
	@IdProject 		AS INT
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	--Get's the table for Initial FollowUp Budget (from GUI). 

	DECLARE @IsValidated BIT
	
	SELECT 	@IsValidated = IsValidated
	FROM	BUDGET_INITIAL
	WHERE 	IdProject = @IdProject

	IF (@IsValidated = 0)
	BEGIN
		SELECT 	
			BIS.StateDate	AS	'StateDate',		
			CTM.IdAssociate AS	'IdAssociate',
			Associates.Name as	'Associate',
			PF.Name			AS	'Project Function',
			ISNULL(BS.Description,'None') AS 'State',
			ISNULL(BS.StateCode,'N') AS 'StateCode',
			CTM.IDProject,
			case when BIS.State is null then 0 else 1 end	AS 'HasData'
		FROM PROJECT_CORE_TEAMS AS CTM 							
		LEFT JOIN Budget_Initial_States BIS
			ON CTM.IdProject = BIS.IdProject AND
			CTM.IdAssociate = BIS.IdAssociate
		LEFT JOIN BUDGET_STATES BS 
			ON BIS.STATE = BS.StateCode				
		LEFT JOIN Associates 
			ON CTM.IdAssociate = Associates.ID
		LEFT JOIN PROJECT_FUNCTIONS PF
			ON PF.ID = CTM.IDFunction
		WHERE 	CTM.IdProject = @IdProject AND
			ISNULL(CTM.IsActive,0) = 1
		ORDER BY PF.Rank
	END
	ELSE
	BEGIN
		SELECT
			BIS.StateDate	AS	'StateDate',		
			CTM.IdAssociate AS	'IdAssociate',
			Associates.Name as	'Associate',
			PF.Name			AS	'Project Function',
			ISNULL(BS.Description,'None') AS 'State',
			ISNULL(BS.StateCode,'N') AS 'StateCode',
			CTM.IDProject,
			case when BIS.State is null then 0 else 1 end	AS 'HasData'
		FROM PROJECT_CORE_TEAMS AS CTM 							
		LEFT JOIN BUDGET_INITIAL_STATES BIS
			ON CTM.IdProject = BIS.IdProject AND
			CTM.IdAssociate = BIS.IdAssociate
		LEFT JOIN BUDGET_STATES BS 
			ON BIS.STATE = BS.StateCode				
		LEFT JOIN ASSOCIATES
			ON CTM.IdAssociate = Associates.ID
		LEFT JOIN PROJECT_FUNCTIONS PF
			ON PF.ID = CTM.IDFunction
		WHERE CTM.IdProject = @IdProject AND
			  StateCode <> 'N' -- filter only team members that have data in the initial budget
		ORDER BY PF.Rank
	END
GO



--Drops the Procedure bgtGetInitialBudget_IsValidated if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetInitialBudget_IsValidated]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetInitialBudget_IsValidated
GO


CREATE        PROCEDURE bgtGetInitialBudget_IsValidated
	@IdProject 		AS INT
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	

	
		SELECT IsValidated FROM BUDGET_INITIAL
			WHERE IdProject = @IdProject


		





GO



IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtGetLastValidatedReforecastVersion') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetLastValidatedReforecastVersion
GO

CREATE  PROCEDURE bgtGetLastValidatedReforecastVersion
(
	@IdProject INT
)
AS
declare @IdGeneration int
declare @IsValidated bit

		select top 1 @IdGeneration = IdGeneration, @IsValidated = IsValidated
		from BUDGET_TOCOMPLETION TABLOCKX
		WHERE 	IdProject = @IdProject
		order by IdGeneration desc
		
		if @IsValidated = 1
			select @IdGeneration
		else
			select 0

GO
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtGetLastValidatedRevisedVersion') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetLastValidatedRevisedVersion
GO

CREATE  PROCEDURE bgtGetLastValidatedRevisedVersion
(
	@IdProject INT
)
AS

declare @IdGeneration int
declare @IsValidated bit

		select top 1 @IdGeneration = IdGeneration, @IsValidated = IsValidated
		from BUDGET_REVISED TABLOCKX
		WHERE 	IdProject = @IdProject
		order by IdGeneration desc
		
		if @IsValidated = 1
			select @IdGeneration
		else
			select 0
GO
--Drops the Procedure bgtGetReforecastVersionNo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetReforecastVersionNo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetReforecastVersionNo
GO
CREATE  PROCEDURE bgtGetReforecastVersionNo
	@IdProject INT,
	@Version CHAR(1)
AS
	DECLARE @BudgetVersion INT
	--Specifies whether the version returned is the actual requested version (it happens when the new version 
	--is requested and it does not exist, the released one will be returned and @ActualVersionNumber will be 0)
	DECLARE @ActualVersionNumber BIT
	SET @ActualVersionNumber = 1

	IF (@Version = 'N')
	BEGIN
		SELECT @BudgetVersion = MAX(IdGeneration) 
		FROM BUDGET_TOCOMPLETION TABLOCKX
		WHERE 	IdProject = @IdProject AND
			IsValidated = 0
		--If no new version of the budget exists, the released version will be selected so get the
		--released version number
		IF (@BudgetVersion IS NULL)
		BEGIN
			SELECT @BudgetVersion = MAX(IdGeneration) 
			FROM BUDGET_TOCOMPLETION TABLOCKX
			WHERE 	IdProject = @IdProject AND
				IsValidated = 1
			SET @ActualVersionNumber = 0
		END
	END
	IF (@Version = 'C' OR @Version = 'P')
	BEGIN
		SELECT @BudgetVersion = MAX(IdGeneration) 
		FROM BUDGET_TOCOMPLETION TABLOCKX
		WHERE 	IdProject = @IdProject AND
			IsValidated = 1
		IF (@Version = 'P')
		BEGIN
			IF (@BudgetVersion IS NOT NULL)
			BEGIN
				SET @BudgetVersion = @BudgetVersion - 1
				IF (@BudgetVersion <= 0)
				BEGIN
					SET @BudgetVersion = NULL
				END
			END
		END
	END
	
	
	SELECT 	@BudgetVersion AS 'BudgetVersion',
		@ActualVersionNumber AS 'IsVersionActual'
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtGetReforecastVersions') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetReforecastVersions
GO

CREATE  PROCEDURE bgtGetReforecastVersions
(
	@IdProject INT,
	@Version CHAR(1)
)
AS

		select IdGeneration
		from BUDGET_TOCOMPLETION TABLOCKX
		WHERE 	IdProject = @IdProject
		
GO




--Drops the Procedure bgtGetRevisedBudgetCostSales if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.bgtGetRevisedBudgetCostSales') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedBudgetCostSales
GO

CREATE  PROCEDURE bgtGetRevisedBudgetCostSales
	@IdProject				INT,
	@IdAssociate			INT,	--The Id of associate
	@IdAssociateViewer		INT,	--The Id of associate viewing the budget
	@IsAssociateCurrency 	BIT,	--Specifies whether the values will be converted from the cost center
	@Version				CHAR(1),
	@IdCountry				INT,
	@IdCurrencyDisplay		int = 0
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

	declare @CurrencyDisplayBit bit = 0
	if @IdCurrencyDisplay > 0
		set @CurrencyDisplayBit = 1

	-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.Id = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key Information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @CurrentGeneration	INT
	DECLARE @LastGeneration		INT
	
	IF (@Version = 'N')
	BEGIN
		SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, 'C')
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@CurrentGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No released version found for this budget', 16, 1)
			RETURN -1
		END

		SELECT @LastGeneration = ISNULL(dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version),@CurrentGeneration)
	
		
		DECLARE @MaxGeneration INT
		SELECT 	@MaxGeneration = MAX(IdGeneration)
		FROM	BUDGET_REVISED_DETAIL BRD
		WHERE 	BRD.IdProject = @IdProject AND
			BRD.IdAssociate = @IdAssociate
		
		IF (@LastGeneration <> @MaxGeneration)
		BEGIN
			SET @LastGeneration = @CurrentGeneration
		END
	END

	IF (@Version = 'C')
	BEGIN
		SELECT @LastGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version)
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@LastGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No released version found for this budget', 16, 1)
			RETURN -2
		END

		SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, 'P')
	END

	IF (@Version = 'P')
	BEGIN
		SELECT @LastGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version)
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@LastGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No previous version found for this budget', 16, 1)
			RETURN -3
		END

		SELECT @CurrentGeneration = CASE WHEN @LastGeneration > 1 THEN @LastGeneration - 1 ELSE NULL END
	END
	
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	if @IdCurrencyDisplay <= 0 
	   begin
	   -- if Currency wasn't specified on the page, then relies on the currency of the viewer
			--Find out the associate currency
			SELECT 	@AssociateCurrency = CTR.IdCurrency,
					@AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES ASOC
			INNER JOIN COUNTRIES CTR 
				ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES CRR 
				ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
	   begin
	   -- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
					@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay

	   end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_REVISED
	WHERE	IdProject = @IdProject AND
		IdGeneration = @LastGeneration

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		DECLARE BudgetCursor CURSOR FAST_FORWARD FOR
		SELECT DISTINCT	BPT.IdProject		AS 	'IdProject',
						BPT.IdPhase			AS	'IdPhase',
						BPT.IdWP			AS 	'IdWP',
						CURR.Id 			AS	'IdCurrency',
						CURR.Code			AS	'CurrencyCode',
						BRD.YearMonth		AS	'YearMonth'
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		INNER JOIN BUDGET_REVISED_DETAIL AS BRD
			ON BRD.IdProject = BPT.IdProject
			AND BRD.IdPhase = BPT.IdPhase
			AND BRD.IdWorkPackage = BPT.IdWP  
			AND BRD.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BRD.IdAssociate ELSE @IdAssociate	END
		INNER JOIN PROJECT_CORE_TEAMS CTM
			ON CTM.IdProject = BRD.IdProject
			AND CTM.IdAssociate = BRD.IdAssociate	
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BRD.IdCostCenter
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.Id = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.Id = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
				ON CURR.Id = COUNTRIES.IdCurrency
		WHERE  CTM.IsActive = CASE WHEN (@IdAssociate =-1  AND @IsBudgetValidated = 0) THEN 1 ELSE CTM.IsActive END AND
			(BRD.IdGeneration = @CurrentGeneration OR BRD.IdGeneration = @LastGeneration)

		OPEN BudgetCursor
		DECLARE @CheckIdProject INT
		DECLARE @CheckIdPhase INT
		DECLARE @CheckIdWP 	INT
		DECLARE @IdCurrency INT
		DECLARE @YearMonth INT
		DECLARE @CurrencyCode VARCHAR(10)
		DECLARE @ER DECIMAL(12,6)
	
		FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @ER = dbo.fnGetExchangeRate(@AssociateCurrency, 	@IdCurrency, @YearMonth)
	
			IF (@ER IS NULL)
			BEGIN
				DECLARE @WpName VARCHAR(30)
				DECLARE @StartYM INT
				DECLARE @EndYM	INT
				SELECT 	@WpName = Code + ' - ' + Name,
					@StartYM = StartYearMonth,
					@EndYM = EndYearMonth
				FROM 	WORK_PACKAGES
				WHERE	IdProject = @CheckIdProject AND
					IdPhase = @CheckIdPhase AND
					Id = @CheckIdWP
				DECLARE @YM VARCHAR(7)
				DECLARE @SYM VARCHAR(7)
				DECLARE @EYM VARCHAR(7)
				SELECT @YM = dbo.fnGetYMStringRepresentation(@YearMonth)
				SELECT @SYM = dbo.fnGetYMStringRepresentation(@StartYM)
				SELECT @EYM = dbo.fnGetYMStringRepresentation(@EndYM)
				RAISERROR('No exchange rate found for %s to %s conversion for YearMonth %s (Work Package %s, period %s - %s).',
						16,1, @AssociateCurrencyCode,@CurrencyCode,@YM, @WpName, @SYM, @EYM )
				CLOSE BudgetCursor
				DEALLOCATE BudgetCursor
				RETURN -1
			END
		   	FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
			
		END
		CLOSE BudgetCursor
		DEALLOCATE BudgetCursor
	END

	SELECT
		BPT.IdProject 							AS 'IdProject',
		BPT.IdPhase 							AS 'IdPhase',
		BPT.IdWP	 							AS 'IdWP',
		CC.Id 									AS 'IdCostCenter',
		DP.Name+'-'+IL.Code+'-'+CC.Code			AS 'CostCenterName',
		dbo.fnGetRevisedBudgetOtherCosts(BPT.IdProject,	@CurrentGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_CURRENT.IdCostCenter), @IdAssociate, @IsAssociateCurrency | @CurrencyDisplayBit, @AssociateCurrency) AS 'CurrentCost',
		CAST (0 as Decimal(19,4))				AS 'UpdateCost',
		dbo.fnGetRevisedBudgetOtherCosts(BPT.IdProject,	@LastGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_NEW.IdCostCenter), @IdAssociate, @IsAssociateCurrency | @CurrencyDisplayBit, @AssociateCurrency) AS 'NewCost',
		dbo.fnGetRevisedBudgetSales(BPT.IdProject,	@CurrentGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_CURRENT.IdCostCenter), @IdAssociate, @IsAssociateCurrency | @CurrencyDisplayBit, @AssociateCurrency) AS 'CurrentSales',
		CAST (0 as Decimal(18,4))				AS 'UpdateSales',
		dbo.fnGetRevisedBudgetSales(BPT.IdProject,	@LastGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_NEW.IdCostCenter), @IdAssociate, @IsAssociateCurrency, @AssociateCurrency) AS 'NewSales',
		CURR.Id									AS 'IdCurrency',
		CURR.Code								AS 'CurrencyCode',
		DP.Rank									AS 'DeptRank'
	INTO #BUDGET_REVISED_DETAIL_TEMP
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	LEFT JOIN BUDGET_REVISED_DETAIL AS BRD_NEW
		ON BRD_NEW.IdProject = BPT.IdProject
		AND BRD_NEW.IdGeneration = @LastGeneration
		AND BRD_NEW.IdPhase = BPT.IdPhase
		AND BRD_NEW.IdWorkPackage = BPT.IdWP  
		AND BRD_NEW.IdAssociate = CASE 	WHEN @IdAssociate = -1 THEN BRD_NEW.IdAssociate ELSE @IdAssociate END
	LEFT JOIN BUDGET_REVISED_DETAIL AS BRD_CURRENT
		ON BRD_CURRENT.IdProject = BRD_NEW.IdProject
		AND BRD_CURRENT.IdGeneration = @CurrentGeneration
		AND BRD_CURRENT.IdPhase = BRD_NEW.IdPhase
		AND BRD_CURRENT.IdCostCenter = BRD_NEW.IdCostCenter
		AND BRD_CURRENT.IdWorkPackage = BRD_NEW.IdWorkPackage
		AND BRD_CURRENT.YearMonth = BRD_NEW.YearMonth
		AND BRD_CURRENT.IdAssociate = BRD_NEW.IdAssociate
	INNER JOIN PROJECT_CORE_TEAMS CTM
		ON CTM.IdProject = BRD_NEW.IdProject AND
		   CTM.IdAssociate = BRD_NEW.IdAssociate
	INNER JOIN COST_CENTERS AS CC 
		ON CC.Id = BRD_NEW.IdCostCenter
	INNER JOIN INERGY_LOCATIONS AS IL
		ON IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP
		ON DP.Id = CC.IdDepartment
	INNER JOIN COUNTRIES
		ON COUNTRIES.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR 
		ON CURR.Id=COUNTRIES.IdCurrency
	WHERE  CTM.IsActive = CASE WHEN (@IdAssociate =-1  AND @IsBudgetValidated = 0) THEN 1 ELSE CTM.IsActive END
		AND COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, CC.Id, CC.Code, CURR.Id, CURR.Code, DP.Name, Il.Code, DP.Rank

	--update the differences
	UPDATE #BUDGET_REVISED_DETAIL_TEMP
	SET UpdateCost = case when (NewCost IS NULL AND CurrentCost IS NULL) OR @CurrentGeneration IS NULL THEN 0
					  else ISNULL(NewCost,0) - ISNULL(CurrentCost,0) end,
		UpdateSales = case when (NewSales IS NULL AND CurrentSales IS NULL) OR @CurrentGeneration IS NULL THEN NULL
					  else ISNULL(NewSales,0) - ISNULL(CurrentSales,0) end
	
	--first select with phases
	SELECT
		BPT.IdProject 							AS 'IdProject',
		PP.Id 									AS 'IdPhase',
		PP.Code + ' - ' + PP.Name				AS 'PhaseName',
		SUM(ROUND(BRDT.CurrentCost, 0))			AS 'CurrentCost',
		SUM(ROUND(BRDT.UpdateCost, 0))			AS 'UpdateCost',
		SUM(ROUND(BRDT.NewCost, 0))				AS 'NewCost',
		SUM(ROUND(BRDT.CurrentSales, 0))		AS 'CurrentSales',
		SUM(ROUND(BRDT.UpdateSales, 0))		 	AS 'UpdateSales',
		SUM(ROUND(BRDT.NewSales, 0))			AS 'NewSales'
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	INNER JOIN PROJECT_PHASES AS PP
		ON PP.Id = BPT.IdPhase
	LEFT JOIN #BUDGET_REVISED_DETAIL_TEMP AS BRDT
		ON BRDT.IdProject = BPT.IdProject AND
			BRDT.IdPhase = BPT.IdPhase AND
			BRDT.IdWP = BPT.IdWP	
	GROUP BY BPT.IdProject, PP.Id, PP.Name, PP.Code
	
	--second select with workpackages
	SELECT
		BPT.IdProject 							AS 'IdProject',
		BPT.IdPhase 							AS 'IdPhase',
		BPT.IdWP	 							AS 'IdWP',
		WP.Code						AS 'WPCode',
		WP.Code + ' - ' + WP.Name 				AS 'WPName',
		WP.StartYearMonth 						AS 'StartYearMonth',
		WP.EndYearMonth 						AS 'EndYearMonth',
		SUM(ROUND(BRDT.CurrentCost, 0))			AS 'CurrentCost',
		SUM(ROUND(BRDT.UpdateCost, 0))			AS 'UpdateCost',
		SUM(ROUND(BRDT.NewCost, 0))				AS 'NewCost',
		SUM(ROUND(BRDT.CurrentSales, 0))		AS 'CurrentSales',
		SUM(ROUND(BRDT.UpdateSales, 0)) 		AS 'UpdateSales',
		SUM(ROUND(BRDT.NewSales, 0))			AS 'NewSales',
		WP.IsActive								AS 'IsActive'
	FROM #BUDGET_PRESELECTION_TEMP BPT
	INNER JOIN WORK_PACKAGES WP
		ON WP.IdProject = BPT.IdProject AND
		   WP.IdPhase = BPT.IdPhase AND
		   WP.Id = BPT.IdWP
	LEFT JOIN #BUDGET_REVISED_DETAIL_TEMP BRDT
		ON	BRDT.IdProject = BPT.IdProject AND
			BRDT.IdPhase = BPT.IdPhase AND
			BRDT.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, WP.Name, WP.StartYearMonth, WP.EndYearMonth, WP.Code, WP.IsActive
	
	--third select for costsenters
	SELECT
		IdProject,
		IdPhase,
		IdWP,
		IdCostCenter,
		CostCenterName,
		CurrentCost,
		UpdateCost,
		NewCost,
		CurrentSales,
		UpdateSales,
		NewSales,
		IdCurrency,
		CurrencyCode
	FROM #BUDGET_REVISED_DETAIL_TEMP
	ORDER BY DeptRank, CostCenterName

GO

--Drops the Procedure bgtGetRevisedBudgetHours if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.bgtGetRevisedBudgetHours') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedBudgetHours
GO

CREATE  PROCEDURE bgtGetRevisedBudgetHours
	@IdProject				INT,
	@IdAssociate			INT,	--The Id of associate
	@IdAssociateViewer		INT,	--The Id of associate
	@IsAssociateCurrency 	BIT,	--Specifies whether the values will be converted from the cost center
	@Version				CHAR(1),
	@IdCountry				INT,
	@IdCurrencyDisplay		int =0
AS
	DECLARE @CurrentGeneration	INT
	DECLARE @LastGeneration		INT
	

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 1

	declare @CurrencyDisplayBit bit = 0
	if @IdCurrencyDisplay > 0
		set @CurrencyDisplayBit = 1

	-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.Id = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END
		
	IF (@Version = 'N')
	BEGIN
		SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, 'C')
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@CurrentGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No released version found for this budget', 16, 1)
			RETURN -2
		END
	
		SELECT @LastGeneration = ISNULL(dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version),@CurrentGeneration)
	
		DECLARE @MaxGeneration INT
		SELECT 	@MaxGeneration = MAX(IdGeneration)
		FROM	BUDGET_REVISED_DETAIL BRD
		WHERE 	BRD.IdProject = @IdProject AND
			BRD.IdAssociate = @IdAssociate
		
		IF (@LastGeneration <> @MaxGeneration)
		BEGIN
			SET @LastGeneration = @CurrentGeneration
		END
	END

	IF (@Version = 'C')
	BEGIN
		SELECT @LastGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version)
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@LastGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No released version found for this budget', 16, 1)
			RETURN -3
		END

		SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, 'P')
	END

	IF (@Version = 'P')
	BEGIN
		SELECT @LastGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject, @Version)
		--The error message should be displayed only if @IdProject is not null (there was at least 1 row in #BUDGET_PRESELECTION_TEMP).
		--If #BUDGET_PRESELECTION_TEMP has no row, it means that the budget is viewed from follow-up and there are no active wp's for
		--this project. In that case, an empty budget will be displayed and no error message.
		IF (@LastGeneration IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			RAISERROR('No previous version found for this budget', 16, 1)
			RETURN -4
		END

		SELECT @CurrentGeneration = CASE WHEN @LastGeneration > 1 THEN @LastGeneration - 1 ELSE NULL END
	END
	
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	--Find out the associate currency
	if @IdCurrencyDisplay <= 0
	   begin
	   -- if Currency wasn't specified on the page, then relies on the currency of the viewer
			SELECT @AssociateCurrency = CTR.IdCurrency,
				   @AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES ASOC
			INNER JOIN COUNTRIES CTR 
				ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES CRR 
				ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
	   begin
	   -- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
					@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
	   end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_REVISED
	WHERE	IdProject = @IdProject AND
		IdGeneration = @LastGeneration

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		DECLARE BudgetCursor CURSOR FAST_FORWARD FOR
		SELECT DISTINCT
			BPT.IdProject	AS 	'IdProject',
			BPT.IdPhase		AS	'IdPhase',
			BPT.IdWP		AS 	'IdWP',
			CURR.Id 		AS	'IdCurrency',
			CURR.Code		AS	'CurrencyCode',
			BRD.YearMonth	AS	'YearMonth'
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		INNER JOIN BUDGET_REVISED_DETAIL AS BRD
			ON BRD.IdProject = BPT.IdProject
			AND BRD.IdPhase = BPT.IdPhase
			AND BRD.IdWorkPackage = BPT.IdWP  
			AND BRD.IdAssociate = CASE WHEN (@IdAssociate = -1) THEN BRD.IdAssociate ELSE @IdAssociate END
		INNER JOIN PROJECT_CORE_TEAMS CTM
			ON CTM.IdProject = BRD.IdProject
			AND CTM.IdAssociate = BRD.IdAssociate	
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BRD.IdCostCenter
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.Id = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.Id = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
				ON CURR.Id = COUNTRIES.IdCurrency
		WHERE  CTM.IsActive = CASE WHEN (@IdAssociate =-1  AND @IsBudgetValidated = 0) THEN 1 ELSE CTM.IsActive END AND
			(BRD.IdGeneration = @CurrentGeneration OR BRD.IdGeneration = @LastGeneration)

		OPEN BudgetCursor
		DECLARE @CheckIdProject INT
		DECLARE @CheckIdPhase INT
		DECLARE @CheckIdWP 	INT
		DECLARE @IdCurrency INT
		DECLARE @YearMonth INT
		DECLARE @CurrencyCode VARCHAR(10)
		DECLARE @ER DECIMAL(12,6)
	
		FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @ER = dbo.fnGetExchangeRate(@AssociateCurrency, 	@IdCurrency, @YearMonth)
	
			IF (@ER IS NULL)
			BEGIN
				DECLARE @WpName VARCHAR(30)
				DECLARE @StartYM INT
				DECLARE @EndYM	INT
				SELECT 	@WpName = Code + ' - ' + Name,
						@StartYM = StartYearMonth,
						@EndYM = EndYearMonth
				FROM 	WORK_PACKAGES
				WHERE	IdProject = @CheckIdProject AND
						IdPhase = @CheckIdPhase AND
						Id = @CheckIdWP
				DECLARE @YM VARCHAR(7)
				DECLARE @SYM VARCHAR(7)
				DECLARE @EYM VARCHAR(7)
				SELECT @YM = dbo.fnGetYMStringRepresentation(@YearMonth)
				SELECT @SYM = dbo.fnGetYMStringRepresentation(@StartYM)
				SELECT @EYM = dbo.fnGetYMStringRepresentation(@EndYM)
				RAISERROR('No exchange rate found for %s to %s conversion for YearMonth %s (Work Package %s, period %s - %s).',
						16,1, @AssociateCurrencyCode,@CurrencyCode,@YM, @WpName, @SYM, @EYM )
				CLOSE BudgetCursor
				DEALLOCATE BudgetCursor
				RETURN -5
			END
		   	FETCH NEXT FROM BudgetCursor INTO @CheckIdProject,@CheckIdPhase,@CheckIdWP,@IdCurrency,@CurrencyCode,@YearMonth
			
		END
		CLOSE BudgetCursor
		DEALLOCATE BudgetCursor
	END

	DECLARE @UseHourlyRates BIT
	SET @UseHourlyRates = case when @Version IN ('P','C') then 0 else 1 end

	SELECT
	BPT.IdProject 						AS 'IdProject',
	BPT.IdPhase 						AS 'IdPhase',
	BPT.IdWP	 						AS 'IdWP',
	CC.Id 								AS 'IdCostCenter',
	DP.Name+'-'+IL.Code+'-'+CC.Code		AS 'CostCenterName',
	dbo.fnGetRevisedBudgetHoursQty(BPT.IdProject, @CurrentGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_CURRENT.IdCostCenter), @IdAssociate) AS 'CurrentHours',
	CAST(0 as int)						AS 'UpdateHours',
	dbo.fnGetRevisedBudgetHoursQty(BPT.IdProject, @LastGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_NEW.IdCostCenter), @IdAssociate) AS 'NewHours',	
	dbo.fnGetRevisedBudgetHoursVal(BPT.IdProject, @CurrentGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_CURRENT.IdCostCenter), @IdAssociate, 0, @IsAssociateCurrency | @CurrencyDisplayBit, @AssociateCurrency) AS 'CurrentVal',
	CAST(0 as Decimal(18,2))			AS 'UpdateVal',
	dbo.fnGetRevisedBudgetHoursVal(BPT.IdProject, @LastGeneration, BPT.IdPhase, BPT.IdWP, MAX(BRD_NEW.IdCostCenter), @IdAssociate, @UseHourlyRates, @IsAssociateCurrency | @CurrencyDisplayBit, @AssociateCurrency) AS 'NewVal',
	CURR.Id								AS 'IdCurrency',
	CURR.Code							AS 'CurrencyCode',
	DP.Rank								AS 'DeptRank'
	INTO #BUDGET_REVISED_DETAIL_TEMP
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	LEFT JOIN BUDGET_REVISED_DETAIL AS BRD_NEW
		ON BRD_NEW.IdProject = BPT.IdProject
		AND BRD_NEW.IdGeneration = @LastGeneration
		AND BRD_NEW.IdPhase = BPT.IdPhase
		AND BRD_NEW.IdWorkPackage = BPT.IdWP  
		AND BRD_NEW.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRD_NEW.IdAssociate ELSE @IdAssociate END
	LEFT JOIN BUDGET_REVISED_DETAIL AS BRD_CURRENT
		ON BRD_CURRENT.IdProject = BRD_NEW.IdProject
		AND BRD_CURRENT.IdGeneration = @CurrentGeneration
		AND BRD_CURRENT.IdPhase = BRD_NEW.IdPhase
		AND BRD_CURRENT.IdCostCenter = BRD_NEW.IdCostCenter
		AND BRD_CURRENT.IdWorkPackage = BRD_NEW.IdWorkPackage
		AND BRD_CURRENT.YearMonth = BRD_NEW.YearMonth
		AND BRD_CURRENT.IdAssociate = BRD_NEW.IdAssociate
	INNER JOIN PROJECT_CORE_TEAMS CTM
		ON CTM.IdProject = BRD_NEW.IdProject
		AND CTM.IdAssociate = BRD_NEW.IdAssociate
	INNER JOIN COST_CENTERS AS CC 
		ON CC.Id = BRD_NEW.IdCostCenter
	INNER JOIN DEPARTMENTS DP
		ON DP.Id = CC.IdDepartment
	INNER JOIN INERGY_LOCATIONS AS IL
		ON IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES
		ON COUNTRIES.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR 
		ON CURR.Id=COUNTRIES.IdCurrency
	WHERE  CTM.IsActive = CASE WHEN (@IdAssociate =-1  AND @IsBudgetValidated = 0) THEN 1 ELSE CTM.IsActive END
		AND COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, CC.Id, CC.Code, CURR.Id, CURR.Code, DP.Name, Il.Code, DP.Rank

	--update phrase for the differences taking care of cases in which one of the values is null
	UPDATE #BUDGET_REVISED_DETAIL_TEMP
	SET UpdateHours = case when (NewHours IS NULL AND CurrentHours IS NULL) OR @CurrentGeneration IS NULL THEN NULL
					  else ISNULL(NewHours,0) - ISNULL(CurrentHours,0) end,
		UpdateVal = case when (NewVal IS NULL AND CurrentVal IS NULL) OR @CurrentGeneration IS NULL THEN NULL
					  else ISNULL(NewVal,0) - ISNULL(CurrentVal,0) end
	
	--first select with phases
	SELECT
		BPT.IdProject 					AS 'IdProject',
		PP.Id 							AS 'IdPhase',
		PP.Code + ' - ' + PP.Name 		AS 'PhaseName',
		SUM(BRDT.CurrentHours)			AS 'CurrentHours',
		SUM(BRDT.UpdateHours)			AS 'UpdateHours',
		SUM(BRDT.NewHours)				AS 'NewHours',
		SUM(ROUND(BRDT.CurrentVal, 0))	AS 'CurrentVal',
		SUM(ROUND(BRDT.UpdateVal, 0))	AS 'UpdateVal',
		SUM(ROUND(BRDT.NewVal, 0))		AS 'NewVal'
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	INNER JOIN PROJECT_PHASES AS PP
		ON PP.Id = BPT.IdPhase
	LEFT JOIN #BUDGET_REVISED_DETAIL_TEMP AS BRDT ON 
			BRDT.IdProject = BPT.IdProject AND
			BRDT.IdPhase = BPT.IdPhase AND
			BRDT.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, PP.Id, PP.Name, PP.Code
	
	-- second select with workpackages
	SELECT
		BPT.IdProject 					AS 'IdProject',
		BPT.IdPhase 					AS 'IdPhase',
		BPT.IdWP	 					AS 'IdWP',
		WP.Code					AS 'WPCode',
		WP.Code + ' - ' + WP.Name 		AS 'WPName',
		WP.StartYearMonth 				AS 'StartYearMonth',
		WP.EndYearMonth 				AS 'EndYearMonth',
		SUM(BRDT.CurrentHours)			AS 'CurrentHours',
		SUM(BRDT.UpdateHours)			AS 'UpdateHours',
		SUM(BRDT.NewHours)				AS 'NewHours',
		SUM(ROUND(BRDT.CurrentVal, 0))	AS 'CurrentVal',
		SUM(ROUND(BRDT.UpdateVal, 0))	AS 'UpdateVal',
		SUM(ROUND(BRDT.NewVal, 0))		AS 'NewVal',
		WP.IsActive						AS 'IsActive'
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	INNER JOIN WORK_PACKAGES AS WP
		ON WP.IdProject = BPT.IdProject
		AND WP.IdPhase = BPT.IdPhase
		AND WP.Id = BPT.IdWP
	LEFT JOIN #BUDGET_REVISED_DETAIL_TEMP AS BRDT ON 
			BRDT.IdProject = BPT.IdProject AND
			BRDT.IdPhase = BPT.IdPhase AND
			BRDT.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, WP.Name, WP.StartYearMonth, WP.EndYearMonth, WP.Code, WP.IsActive
	
	--third select with cost centers
	SELECT
		IdProject,
		IdPhase,
		IdWP,
		IdCostCenter,
		CostCenterName,
		CurrentHours,
		UpdateHours,
		NewHours,
		CurrentVal,
		UpdateVal,
		NewVal,
		IdCurrency,
		CurrencyCode
	FROM #BUDGET_REVISED_DETAIL_TEMP
	ORDER BY DeptRank, CostCenterName

GO

--Drops the Procedure bgtGetRevisedBudgetOtherCosts if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetRevisedBudgetOtherCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedBudgetOtherCosts
GO

CREATE  PROCEDURE bgtGetRevisedBudgetOtherCosts
	@IdProject				INT,		--The Id of the selected Project
	@IdPhase				INT,		--The Id of a phase from project
	@IdWP					INT,		--The Id of workpackage
	@IdCostCenter			INT,		--The Id of cost center
	@IdAssociate			INT,		--The Id of associate
	@IdAssociateViewer		INT,		--The Id of associate viewing the budget
	@IsAssociateCurrency 	BIT,		--Specifies whether the values will be converted from the cost center
						--currency to the associate currency
	@IdCurrencyDisplay int = 0
AS
BEGIN

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

	declare @CurrencyDisplayBit bit = 0
	if @IdCurrencyDisplay > 0
		set @CurrencyDisplayBit = 1

	-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.Id = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END


	DECLARE @CurrentGeneration	INT
	DECLARE @LastGeneration		INT
	
	SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')

	SELECT @LastGeneration = ISNULL(dbo.fnGetRevisedBudgetGeneration(@IdProject,'N'), @CurrentGeneration)

	
	DECLARE @MaxGeneration INT
	SELECT 	@MaxGeneration = MAX(IdGeneration)
	FROM	BUDGET_REVISED_DETAIL BRD
	WHERE 	BRD.IdProject = @IdProject AND
		BRD.IdAssociate = @IdAssociate
	
	IF (@LastGeneration <> @MaxGeneration)
	BEGIN
		SET @LastGeneration = @CurrentGeneration
	END

	
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	--Find out the associate currency
	if @IdCurrencyDisplay <= 0 
	   begin
	   -- if Currency wasn't specified on the page, then relies on the currency of the viewer
			SELECT 	@AssociateCurrency = CTR.IdCurrency,
					@AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES ASOC
			INNER JOIN COUNTRIES CTR 
				ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES CRR 
				ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
	   begin
	   -- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
					@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
	   end


	SELECT 	@IdProject									AS 'IdProject',
			@IdPhase									AS 'IdPhase',
			@IdWP										AS 'IdWP',
			@IdCostcenter								AS 'IdCostCenter',
			BCT.[Name]									AS 'OtherCostType',
			BRD_SUM_CURRENT.AllOtherCosts		   		AS 'CurrentCost',
			CASE WHEN (BRD_SUM_NEW.AllOtherCosts IS NULL AND BRD_SUM_CURRENT.AllOtherCosts IS NULL) THEN NULL
				 ELSE ISNULL(BRD_SUM_NEW.AllOtherCosts,0) - ISNULL(BRD_SUM_CURRENT.AllOtherCosts,0)	END	AS 'UpdateCost',
			BRD_SUM_NEW.AllOtherCosts					AS 'NewCost',
			CURR.Id										AS 'IdCurrency',
			CURR.[Name]									AS 'CurrencyName'
	FROM (	SELECT 	BRD.IdProject	AS 'IdProject',
			BRD.IdPhase,
			BRD.IdWorkPackage,
			BRD.IdCostCenter,
			BRD.IdAssociate,
			BRDC.IdCostType,
			SUM(CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN	dbo.fnGetExchangeRate(CURR.Id, @AssociateCurrency, BRDC.YearMonth) ELSE 1	END
				 * BRDC.CostVal)	AS 'AllOtherCosts'
		FROM 	BUDGET_REVISED_DETAIL BRD
			INNER JOIN BUDGET_REVISED_DETAIL_COSTS BRDC
				ON BRDC.IdProject = @IdProject
				AND BRDC.IdGeneration = @LastGeneration
				AND BRDC.IdPhase = @IdPhase
				AND BRDC.IdWorkPackage = @IdWP
				AND BRDC.IdCostCenter = @IdCostCenter
				AND BRDC.IdAssociate = @IdAssociate
				AND BRDC.YearMonth = BRD.YearMonth
			INNER JOIN COST_CENTERS AS CC 
				ON CC.Id = BRD.IdCostCenter
			INNER JOIN INERGY_LOCATIONS AS IL
				ON IL.Id = CC.IdInergyLocation
			INNER JOIN COUNTRIES
				ON COUNTRIES.Id = IL.IdCountry
			INNER JOIN CURRENCIES CURR 
				ON CURR.Id=COUNTRIES.IdCurrency
		WHERE	BRD.IdProject = @IdProject
			AND BRD.IdGeneration = @LastGeneration
			AND BRD.IdPhase = @IdPhase
			AND BRD.IdWorkPackage = @IdWP
			AND BRD.IdCostCenter = @IdCostCenter
			AND BRD.IdAssociate = @IdAssociate
		GROUP BY BRD.IdProject,BRD.IdPhase,BRD.IdWorkPackage,
			BRD.IdCostCenter,BRD.IdAssociate,BRDC.IdCostType			
	)AS BRD_SUM_NEW 
	LEFT JOIN (	SELECT 	BRD.IdProject AS 'IdProject',
			BRD.IdPhase,
			BRD.IdWorkPackage,
			BRD.IdCostCenter,
			BRD.IdAssociate,
			BRDC.IdCostType,
			SUM(CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN	dbo.fnGetExchangeRate(CURR.Id, @AssociateCurrency, BRDC.YearMonth) ELSE 1	END 
					* BRDC.CostVal)	AS 'AllOtherCosts'
		FROM 	BUDGET_REVISED_DETAIL BRD
			INNER JOIN BUDGET_REVISED_DETAIL_COSTS BRDC
				ON BRDC.IdProject = @IdProject
				AND BRDC.IdGeneration = @CurrentGeneration
				AND BRDC.IdPhase = @IdPhase
				AND BRDC.IdWorkPackage = @IdWP
				AND BRDC.IdCostCenter = @IdCostCenter
				AND BRDC.IdAssociate = @IdAssociate
				AND BRDC.YearMonth = BRD.YearMonth
			INNER JOIN COST_CENTERS AS CC 
				ON CC.Id = BRD.IdCostCenter
			INNER JOIN INERGY_LOCATIONS AS IL
				ON IL.Id = CC.IdInergyLocation
			INNER JOIN COUNTRIES
				ON COUNTRIES.Id = IL.IdCountry
			INNER JOIN CURRENCIES CURR 
				ON CURR.Id=COUNTRIES.IdCurrency
		WHERE	BRD.IdProject = @IdProject
			AND BRD.IdGeneration = @CurrentGeneration
			AND BRD.IdPhase = @IdPhase
			AND BRD.IdWorkPackage = @IdWP
			AND BRD.IdCostCenter = @IdCostCenter
			AND BRD.IdAssociate = @IdAssociate
		GROUP BY BRD.IdProject,BRD.IdPhase,BRD.IdWorkPackage,
			BRD.IdCostCenter,BRD.IdAssociate,BRDC.IdCostType			
	)AS BRD_SUM_CURRENT
	ON BRD_SUM_NEW.IdProject = BRD_SUM_CURRENT.IdProject
		AND BRD_SUM_NEW.IdPhase = BRD_SUM_CURRENT.IdPhase
		AND BRD_SUM_NEW.IdWorkPackage = BRD_SUM_CURRENT.IdWorkPackage
		AND BRD_SUM_NEW.IdCostCenter = BRD_SUM_CURRENT.IdCostCenter
		AND BRD_SUM_NEW.IdAssociate = BRD_SUM_CURRENT.IdAssociate
		AND BRD_SUM_NEW.IdCostType = BRD_SUM_CURRENT.IdCostType
	INNER JOIN BUDGET_COST_TYPES AS BCT
		ON BCT.Id = BRD_SUM_NEW.IdCostType
	INNER JOIN COST_CENTERS AS CC 
		ON CC.Id = BRD_SUM_NEW.IdCostCenter
	INNER JOIN INERGY_LOCATIONS AS IL
		ON IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES
		ON COUNTRIES.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR 
		ON CURR.Id=COUNTRIES.IdCurrency

END

GO

--Drops the Procedure bgtGetRevisedBudgetStateForEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetRevisedBudgetStateForEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedBudgetStateForEvidence
GO



-- bgtGetRevisedBudgetStateForEvidence 7,'P',4

CREATE        PROCEDURE bgtGetRevisedBudgetStateForEvidence
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1), 
	@IdAssociate		AS INT 			
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END	

	IF(@IdAssociate<0)
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -3
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	
	SELECT 	
		ISNULL(State,'N') AS 'StateCode'

	FROM BUDGET_REVISED_STATES 
 	WHERE IdProject = @IdProject AND IdGeneration = @IdGeneration AND IdAssociate = @IdAssociate 




GO






--Drops the Procedure bgtGetRevisedBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetRevisedBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedBudgetStates
GO


-- sp_helptext bgtGetRevisedBudgetStates
-- bgtGetRevisedBudgetStates 14,'N'

CREATE        PROCEDURE bgtGetRevisedBudgetStates
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)	
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	DECLARE @temptable table
	(
		IDPROJECT INT,
		IDASSOCIATE INT,
		IDGENERATION INT,
		AssociateName VARCHAR(50),
		AssociatePF VARCHAR(50),
		IsActive BIT,
		Rank INT
	)	


--Get's the table for Revised FollowUp Budget (from GUI). 

	INSERT INTO @temptable (IDPROJECT, IDASSOCIATE, IDGENERATION, AssociateName, AssociatePF, IsActive, Rank)
	SELECT PCT.IDPROJECT, PCT.IDASSOCIATE,  BR.IDGENERATION , A.Name, PF.Name, PCT.IsActive, PF.Rank
	FROM PROJECT_CORE_TEAMS PCT 
	LEFT JOIN BUDGET_REVISED BR 
		ON  PCT.IDPROJECT = BR.IDPROJECT
	LEFT JOIN ASSOCIATES A 
		ON PCT.IDAssociate = A.ID
	LEFT JOIN PROJECT_FUNCTIONS PF
		ON PCT.IDFunction = PF.ID
	WHERE 	PCT.IDPROJECT = @IdProject AND 
		BR.IDGENERATION = @IdGeneration AND
		ISNULL(A.IsActive,0) = 1
	
	SELECT  t.IdProject  			AS 'IDProject',
		t.IdAssociate			AS 'IDAssociate',
		t.IdGeneration			AS 'IDGeneration',
		t.AssociateName			AS 'Associate',
		t.AssociatePF			AS 'Project Function',
		BRS.StateDate			AS 'StateDate',
		ISNULL(BRS.State,'N')		AS 'StateCode',
		BS.Description			AS 'State',
		case when BRS.State is null then 0 else 1 end	AS 'HasData'
	FROM @temptable t 
	LEFT JOIN BUDGET_REVISED_STATES BRS
		ON t.IdProject = BRS.IdProject
		AND t.IDAssociate = BRS.IdAssociate
		AND t.IdGeneration = BRS.IdGeneration
	LEFT JOIN BUDGET_STATES BS
		ON ISNULL(BRS.State,'N')  = BS.StateCode
	WHERE t.IDProject = @IdProject AND
	      t.IdGeneration = @IdGeneration AND
	      ISNULL(t.IsActive,0) = 1
	ORDER BY t.Rank, t.AssociateName


GO





--Drops the Procedure bgtGetRevisedScalarValidState if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetRevisedScalarValidState]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedScalarValidState
GO



-- bgtGetRevisedScalarValidState 7,'C'

CREATE        PROCEDURE bgtGetRevisedScalarValidState
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)		
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	
	SELECT 	
		ISNULL(IsValidated,0) AS 'IsValidated'

	FROM BUDGET_REVISED 
	WHERE IdProject = @IdProject AND IdGeneration = @IdGeneration 



GO






--Drops the Procedure bgtGetRevisedVersionNo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetRevisedVersionNo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedVersionNo
GO
CREATE  PROCEDURE bgtGetRevisedVersionNo
	@IdProject INT,
	@Version CHAR(1)
AS
	DECLARE @BudgetVersion INT
	--Specifies whether the version returned is the actual requested version (it happens when the new version 
	--is requested and it does not exist, the released one will be returned and @ActualVersionNumber will be 0)
	DECLARE @ActualVersionNumber BIT
	SET @ActualVersionNumber = 1

	IF (@Version = 'N')
	BEGIN
		SELECT @BudgetVersion = MAX(IdGeneration) 
		FROM BUDGET_REVISED TABLOCKX
		WHERE 	IdProject = @IdProject AND
			IsValidated = 0
		--If no new version of the budget exists, the released version will be selected so get the
		--released version number
		IF (@BudgetVersion IS NULL)
		BEGIN
			SELECT @BudgetVersion = MAX(IdGeneration) 
			FROM BUDGET_REVISED TABLOCKX
			WHERE 	IdProject = @IdProject AND
				IsValidated = 1
			SET @ActualVersionNumber = 0
		END
	END
	IF (@Version = 'C' OR @Version = 'P')
	BEGIN
		SELECT @BudgetVersion = MAX(IdGeneration) 
		FROM BUDGET_REVISED TABLOCKX
		WHERE 	IdProject = @IdProject AND
			IsValidated = 1
		IF (@Version = 'P')
		BEGIN
			IF (@BudgetVersion IS NOT NULL)
			BEGIN
				SET @BudgetVersion = @BudgetVersion - 1
				IF (@BudgetVersion <= 0)
				BEGIN
					SET @BudgetVersion = NULL
				END
			END
		END
	END
	
	
	SELECT 	@BudgetVersion AS 'BudgetVersion',
		@ActualVersionNumber AS 'IsVersionActual'
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtGetRevisedVersions') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetRevisedVersions
GO

CREATE  PROCEDURE bgtGetRevisedVersions
(
	@IdProject INT,
	@Version CHAR(1)
)
AS

		select IdGeneration
		from BUDGET_REVISED TABLOCKX
		WHERE 	IdProject = @IdProject
GO
--Drops the Procedure bgtGetToCompletionActualDataTimestamp if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionActualDataTimestamp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionActualDataTimestamp
GO

CREATE PROCEDURE bgtGetToCompletionActualDataTimestamp
AS
	SELECT 	GETDATE()
GO

--Drops the Procedure bgtGetToCompletionBudgetOtherCostsEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetGrossCostsEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetGrossCostsEvidence
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetGrossCostsEvidence
	@IdProject 				INT,
	@IdAssociate			INT,
	@IdAssociateViewer		INT,
	@Version				CHAR(1), -- First version of budget
	@IsAssociateCurrency 	BIT,
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry		INT,
	@IdCurrencyDisplay		int = 0
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT

	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @RetVal INT
	
	
	---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -2
	END

	--Find out the associate currency
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)
	
	if @IdCurrencyDisplay <= 0 
		begin
		-- if Currency wasn't specified on the page, then relies on the currency of the viewer
			IF (@IsAssociateCurrency = 1)
			BEGIN
				SELECT @AssociateCurrency = CTR.IdCurrency,
					   @AssociateCurrencyCode = CRR.Code
				FROM ASSOCIATES ASOC
				INNER JOIN COUNTRIES CTR 
					ON CTR.Id = ASOC.IdCountry
				INNER JOIN CURRENCIES CRR 
					ON CRR.Id = CTR.IdCurrency
				WHERE ASOC.Id = @IdAssociateViewer
			END
		end
	else
		begin
			-- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
			@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
		end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
		IdGeneration = @ToCompletionCurrentGenerationNo

	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id int identity(1,1),
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous DECIMAL(21, 6),
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff DECIMAL(21, 6),
		[Current] DECIMAL(21, 6),
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff DECIMAL(21, 6),
		New DECIMAL(21, 6),
		IsNewActual BIT NOT NULL,
		NewRevisedDiff DECIMAL(21, 6),
		Revised DECIMAL(21, 6),
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		EXEC @RetVal = bgtCheckERForReforcastKeys @IdAssociate = @IdAssociate, @AssociateCurrency = @AssociateCurrency, @AssociateCurrencyCode = @AssociateCurrencyCode
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -3
	END

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		/*
		COALESCE(dbo.fnGetActualOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1),
			 dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth)
			) IS NULL
		*/
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment

	--Add new values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
			*
			CASE WHEN (@Version = 'P' OR @Version = 'C')
			THEN
				CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1) IS NULL AND
				     BCD.HoursVal IS NULL
				) THEN NULL ELSE 
				(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1), 0) 
				+ ISNULL(BCD.HoursVal, 0))
			  	END
			ELSE
				CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1) IS NULL AND
				     dbo.fnGetValuedHours(BTD.IdCostCenter, BCD.HoursQty, BTD.YearMonth) IS NULL
				) THEN NULL ELSE 
				(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1), 0) 
				+ ISNULL(dbo.fnGetValuedHours(BTD.IdCostCenter, BCD.HoursQty, BTD.YearMonth), 0))
			  	END
			END
			  
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)

	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* (ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
				+ ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth)	, 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				*
				  CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionCurrentGenerationNo, BTD.YearMonth, -1) IS NULL AND
					     BCD.HoursVal IS NULL
					) THEN NULL ELSE 
					(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionCurrentGenerationNo, BTD.YearMonth, -1), 0) 
					+ ISNULL(BCD.HoursVal, 0))
				  END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* (ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
				+ ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth)	, 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				*
				  CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionPreviousGenerationNo, BTD.YearMonth, -1) IS NULL AND
					     BCD.HoursVal IS NULL
					) THEN NULL ELSE 
					(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionPreviousGenerationNo, BTD.YearMonth, -1), 0) 
					+ ISNULL(BCD.HoursVal, 0))
				  END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* (ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
				+ ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth)	, 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsPreviousActual = 1


-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END 
				* 
			      CASE WHEN dbo.fnGetToCompletionRevisedOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @RevisedGenerationNo, BTD.YearMonth, -1) IS NULL AND
				BRD.HoursVal IS NULL
			      THEN NULL
			      ELSE ISNULL(dbo.fnGetToCompletionRevisedOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @RevisedGenerationNo, BTD.YearMonth, -1), 0) + ISNULL(BRD.HoursVal, 0)
			      END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BRD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency

	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND([Current], 0), 0) END
	END

	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND(Revised, 0), 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL(ROUND([Current], 0), 0) - ISNULL(ROUND(Previous, 0), 0) END	
	END


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		DECIMAL(21, 6),
		CurrentPreviousDiff	DECIMAL(21, 6),
		[Current]		DECIMAL(21, 6),
		NewCurrentDiff		DECIMAL(21, 6),
		New			DECIMAL(21, 6),
		NewRevisedDiff		DECIMAL(21, 6),
		Revised			DECIMAL(21, 6),
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL	
		ORDER BY DP.Rank, BTD.CostCenterName
	END



	--Select the first table
	SELECT 	BPT.IdProject 			AS	'IdProject',
		BPT.IdPhase			AS	'IdPhase',
		BPT.IdWP			AS	'IdWP',
		WP.Code				AS	'PhaseWPCode',
		WP.Code + ' - ' + WP.Name	AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END AS 	'Progress',
		WP.StartYearMonth		AS	'StartYearMonth',
		WP.EndYearMonth			AS	'EndYearMonth',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Previous, 0), 0)) ELSE NULL END		AS	'Previous',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.CurrentPreviousDiff, 0), 0)) ELSE NULL END 	AS	'CurrentPreviousDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.[Current], 0), 0)) ELSE NULL END		AS 	'Current',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewCurrentDiff, 0), 0)) ELSE NULL END	AS	'NewCurrentDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.New, 0), 0)) ELSE NULL END			AS	'New',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewRevisedDiff, 0), 0)) ELSE NULL END	AS	'NewRevisedDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Revised, 0), 0)) ELSE NULL END		AS 	'Revised',
		WP.IsActive			AS 	'IsActive'
	FROM 	#BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON 
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, BCP.[Percent], WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the second table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE


	--Select the third table
	SELECT	BTD.IdProject		AS	'IdProject',
		BTD.IdPhase			AS	'IdPhase',
		BTD.IdWP			AS	'IdWP',
		BTD.IdCostCenter		AS	'IdCostCenter',
		BTD.YearMonth		AS	'YearMonth',
		SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
		BTD.IsPreviousActual	AS	'IsPreviousActual',
		SUM(ROUND(BTD.CurrentPreviousDiff, 0))	AS	'CurrentPreviousDiff',
		SUM(ROUND(BTD.[Current], 0))		AS	'Current',
		BTD.IsCurrentActual		AS	'IsCurrentActual',
		SUM(ROUND(BTD.NewCurrentDiff, 0))		AS	'NewCurrentDiff',
		SUM(ROUND(BTD.New, 0))			AS	'New',
		BTD.IsNewActual		AS	'IsNewActual',
		SUM(ROUND(BTD.NewRevisedDiff, 0))		AS	'NewRevisedDiff',
		SUM(ROUND(BTD.Revised, 0))			AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth

GO

--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetHoursEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetHoursEvidence
GO

CREATE  PROCEDURE [dbo].[bgtGetToCompletionBudgetHoursEvidence]
	@IdProject 		INT,
	@IdAssociate		INT,
	@IdAssociateViewer	INT,
	@Version		CHAR(1), -- Version of budget
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry		INT
AS

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT
	
	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)
	

---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -1
	END

	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id INT identity(1,1),
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous INT,
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff INT,
		[Current] INT,
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff INT,
		New INT,
		IsNewActual BIT NOT NULL,
		NewRevisedDiff INT,
		Revised INT
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	
	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		--dbo.fnGetActualHoursQty(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth) IS NULL
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment
	
	--Add new values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.New = BCD.HoursQty
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.New = ROUND(ISNULL(dbo.fnGetActualHoursQty(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0), 0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = BCD.HoursQty
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = ROUND(ISNULL(dbo.fnGetActualHoursQty(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0), 0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = BCD.HoursQty
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = ROUND(ISNULL(dbo.fnGetActualHoursQty(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0), 0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.IsPreviousActual = 1

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = BRD.HoursQty
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BRD.YearMonth = BTD.YearMonth

	-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id

	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(New, 0) - ISNULL([Current], 0) END
	END

	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(New, 0) - ISNULL(Revised, 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL([Current], 0) - ISNULL(Previous, 0) END
	END


	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
		IdGeneration = @ToCompletionCurrentGenerationNo
/*		
	--Select the Phase table
	SELECT
		BPT.IdProject		 	AS 'IdProject',
		PP.Id 				AS 'IdPhase',
		PP.Code + ' - ' + PP.Name 	AS 'PhaseName',
		SUM(BTD.Previous) 		AS 'Previous',
		SUM(BTD.CurrentPreviousDiff) 	AS 'CurrentPreviousDiff',
		SUM(BTD.[Current]) 		AS 'Current',
		SUM(BTD.NewCurrentDiff) 	AS 'NewCurrentDiff',
		SUM(BTD.New) 			AS 'New',
		SUM(BTD.NewRevisedDiff)		AS 'NewRevisedDiff',
		SUM(BTD.Revised)		AS 'Revised'
	FROM #BUDGET_PRESELECTION_TEMP AS BPT
	INNER JOIN PROJECT_PHASES AS PP
		ON PP.Id = BPT.IdPhase
	LEFT JOIN #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD ON 
			BTD.IdProject = BPT.IdProject AND
			BTD.IdPhase = BPT.IdPhase AND
			BTD.IdWP = BPT.IdWP
	GROUP BY BPT.IdProject, PP.Id, PP.Name, PP.Code		
*/


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		INT,
		CurrentPreviousDiff	INT,
		[Current]		INT,
		NewCurrentDiff		INT,
		New			INT,
		NewRevisedDiff		INT,
		Revised			INT,
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(BTD.Previous)		AS	'Previous',
			SUM(BTD.CurrentPreviousDiff) 	AS	'CurrentPreviousDiff',
			SUM(BTD.[Current])		AS 	'Current',
			SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
			SUM(BTD.New)			AS	'New',
			SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
			SUM(BTD.Revised)		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(BTD.Previous)		AS	'Previous',
			SUM(BTD.CurrentPreviousDiff) 	AS	'CurrentPreviousDiff',
			SUM(BTD.[Current])		AS 	'Current',
			SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
			SUM(BTD.New)			AS	'New',
			SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
			SUM(BTD.Revised)		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL	
		ORDER BY DP.Rank, BTD.CostCenterName	
	END



	--Select the WP level table
	SELECT 	BPT.IdProject 				AS	'IdProject',
		BPT.IdPhase				AS	'IdPhase',
		BPT.IdWP				AS	'IdWP',
		WP.Code					AS	'PhaseWPCode',
		WP.Code + ' - ' + WP.Name		AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END 	AS 	'Progress',
		WP.StartYearMonth			AS	'StartYearMonth',
		WP.EndYearMonth				AS	'EndYearMonth',
		SUM(ISNULL(CC.Previous, 0))		AS	'Previous',
		SUM(ISNULL(CC.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
		SUM(ISNULL(CC.[Current], 0))		AS 	'Current',
		SUM(ISNULL(CC.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
		SUM(ISNULL(CC.New, 0))			AS	'New',
		SUM(ISNULL(CC.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
		SUM(ISNULL(CC.Revised, 0))		AS 	'Revised',
		WP.IsActive				AS 	'IsActive'
	FROM #BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the COST CENTER level table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE


	--Select the YEARMONTH level table
	SELECT	BTD.IdProject		AS	'IdProject',
		BTD.IdPhase			AS	'IdPhase',
		BTD.IdWP			AS	'IdWP',
		BTD.IdCostCenter		AS	'IdCostCenter',
		BTD.YearMonth		AS	'YearMonth',
		SUM(BTD.Previous)		AS	'Previous',
		BTD.IsPreviousActual	AS	'IsPreviousActual',
		SUM(BTD.CurrentPreviousDiff)	AS	'CurrentPreviousDiff',
		SUM(BTD.[Current])		AS	'Current',
		BTD.IsCurrentActual		AS	'IsCurrentActual',
		SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
		SUM(BTD.New)			AS	'New',
		BTD.IsNewActual		AS	'IsNewActual',
		SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
		SUM(BTD.Revised)			AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth

GO

--Drops the Procedure bgtGetToCompletionBudgetKeysTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetKeysTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetKeysTable
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetKeysTable
	@IdProject		INT,
	@IdAssociate		INT,
	@Version		CHAR(1) -- Version of budget
AS
	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT	
	DECLARE @ToCompletionNewGenerationNo INT

	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @IsNewValidated				BIT,
			@YearMonthActualDataForNew  int
	
---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	SELECT @IsNewValidated = IsValidated,
		   @YearMonthActualDataForNew = YearMonthActualData 
	FROM BUDGET_TOCOMPLETION
	WHERE IdProject = @IdProject and 
		  IdGeneration = @ToCompletionNewGenerationNo

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -1
	END

----------Create and populate months table
	CREATE TABLE #WPMonths
	(
		IdProject 	INT NOT NULL,
		IdPhase 	INT NOT NULL,
		IdWP		INT NOT NULL,
		YearMonth	INT NOT NULL
		PRIMARY KEY (IdProject, IdPhase, IdWP, YearMonth)
	)

	DECLARE PreselectionCursor CURSOR FAST_FORWARD FOR

	--Get the work packages selected in wp preselection + work packages in actual data (for this project)
	SELECT 
		WPM.IdProject	AS	'IdProject',
		WPM.IdPhase	AS	'IdPhase',	
		WPM.IdWP	AS	'IdWP'
	FROM #BUDGET_PRESELECTION_TEMP AS WPM
	WHERE WPM.IdProject = @IdProject

	OPEN PreselectionCursor
	DECLARE @IdPhase INT
	DECLARE @IdWP INT
	
	--Insert months into #WPMonths table for every work package from the above union
	FETCH NEXT FROM PreselectionCursor INTO @IdProject, @IdPhase, @IdWP	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		INSERT INTO #WPMonths 
			(IdProject, IdPhase, IdWP, YearMonth)
		SELECT
			IdProject, IdPhase, IdWP, YearMonth
		FROM dbo.fnGetWPMonths(@IdProject, @IdPhase, @IdWP)
		UNION -- on purpose eliminate duplicates
		SELECT IdProject, IdPhase, IdWorkPackage, YearMonth
		FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE IdProject = @IdProject and
			  IdPhase = @IdPhase and
			  IdWorkPackage = @IdWP and
			  IdGeneration in (@ToCompletionPreviousGenerationNo, @ToCompletionCurrentGenerationNo, @ToCompletionNewGenerationNo)
		
		FETCH NEXT FROM PreselectionCursor INTO @IdProject, @IdPhase,@IdWP	
	END

	CLOSE PreselectionCursor
	DEALLOCATE PreselectionCursor

	

-- 	select * from #WPMonths
--CREATE Table with keys
 
	DECLARE @TableKeysFinal table
	(
		IdProject 	INT,
		IdPhase	  	INT,
		IdWorkPackage 	INT,
		IdCostCenter	INT,
		IdAssociate	INT,
		YearMonth	INT,
		IsNewActual	BIT,
		IsCurrentActual BIT,
		IsPreviousActual BIT
		PRIMARY KEY (IdProject, IdPhase, IdWorkPackage,IdCostCenter,IdAssociate, YearMonth)
	)

	DECLARE @TableKeysTemp table
	(
		IdProject 	INT,
		IdPhase	  	INT,
		IdWorkPackage 	INT,
		IdCostCenter	INT,
		IdAssociate	INT,
		YearMonth	INT
		PRIMARY KEY (IdProject, IdPhase, IdWorkPackage,IdCostCenter,IdAssociate, YearMonth)
	)
-- populate table with keys from tocompletion generation new
	INSERT INTO @TableKeysFinal (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	SELECT  
		WPM.IdProject,
		WPM.IdPhase,
		WPM.IdWP,
		BCDN.IdCostCenter,
		BCDN.IdAssociate,
		WPM.YearMonth,
		0,0,0
	FROM  #WPMONTHS WPM
	INNER JOIN BUDGET_TOCOMPLETION_DETAIL BCDN
	ON 	BCDN.IdProject = WPM.IdProject AND		
		BCDN.IdPhase = WPM.IdPhase AND
		BCDN.IdWorkPackage = WPM.IdWP AND
		BCDN.YearMonth = WPM.YearMonth AND
		BCDN.IdGeneration = @ToCompletionNewGenerationNo AND
	      	BCDN.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BCDN.IdAssociate
						ELSE @IdAssociate
						END
		

-- 	populate table with keys from revised

	INSERT INTO @TableKeysTemp (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth)
	SELECT
		WPM.IdProject,
		WPM.IdPhase,
		WPM.IdWP,
		BRD.IdCostCenter,
		BRD.IdAssociate,
		WPM.YearMonth
	FROM #WPMONTHS WPM	
	INNER JOIN BUDGET_REVISED_DETAIL AS BRD 
	ON	BRD.IdProject = WPM.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = WPM.IdPhase AND
		BRD.IdWorkPackage = WPM.IdWP AND
		BRD.YearMonth = WPM.YearMonth AND
		BRD.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BRD.IdAssociate
							ELSE @IdAssociate
						END
-- 	delete the final table with keys from temp table to evoid duplicates

	DELETE @TableKeysFinal
	FROM @TableKeysFinal tf
	INNER JOIN @TableKeysTemp tt
	ON 	tf.IdProject = tt.IdProject AND
		tf.IdPhase = tt.IdPhase AND
		tf.IdWorkPackage = tt.IdWorkPackage AND
		tf.IdCostCenter = tt.IdCostCenter AND
		tf.IdAssociate = tt.IdAssociate AND
		tf.YearMonth = tt.YearMonth

-- 	insert rows from revised into the final table

	INSERT INTO @TableKeysFinal (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	SELECT 	IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		YearMonth,
		0, 0, 0
	FROM @TableKeysTemp



-- add eventul keys from released version of the tocompletion budget

	DELETE FROM @TableKeysTemp

	INSERT INTO @TableKeysTemp (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth)
	SELECT  
		WPM.IdProject,
		WPM.IdPhase,
		WPM.IdWP,
		BCDN.IdCostCenter,
		BCDN.IdAssociate,
		WPM.YearMonth
	FROM  #WPMONTHS WPM
	INNER JOIN BUDGET_TOCOMPLETION_DETAIL BCDN
	ON 	BCDN.IdProject = WPM.IdProject AND		
		BCDN.IdPhase = WPM.IdPhase AND
		BCDN.IdWorkPackage = WPM.IdWP AND
		BCDN.YearMonth = WPM.YearMonth AND
		BCDN.IdGeneration = @ToCompletionCurrentGenerationNo AND
	      	BCDN.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BCDN.IdAssociate
						ELSE @IdAssociate
						END

	DELETE @TableKeysFinal
	FROM @TableKeysFinal tf
	INNER JOIN @TableKeysTemp tt
	ON 	tf.IdProject = tt.IdProject AND
		tf.IdPhase = tt.IdPhase AND
		tf.IdWorkPackage = tt.IdWorkPackage AND
		tf.IdCostCenter = tt.IdCostCenter AND
		tf.IdAssociate = tt.IdAssociate AND
		tf.YearMonth = tt.YearMonth

	INSERT INTO @TableKeysFinal  (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	SELECT 	IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		YearMonth,
		0, 0, 0
	FROM @TableKeysTemp

-- 	add eventual keys from previous version from tocompletion budget

	DELETE FROM @TableKeysTemp

	INSERT INTO @TableKeysTemp (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth)
	SELECT  
		WPM.IdProject,
		WPM.IdPhase,
		WPM.IdWP,
		BCDN.IdCostCenter,
		BCDN.IdAssociate,
		WPM.YearMonth
	FROM  #WPMONTHS WPM
	INNER JOIN BUDGET_TOCOMPLETION_DETAIL BCDN
	ON 	BCDN.IdProject = WPM.IdProject AND		
		BCDN.IdPhase = WPM.IdPhase AND
		BCDN.IdWorkPackage = WPM.IdWP AND
		BCDN.YearMonth = WPM.YearMonth AND
		BCDN.IdGeneration = @ToCompletionPreviousGenerationNo AND
	      	BCDN.IdAssociate = CASE 	WHEN (@IdAssociate = -1) THEN BCDN.IdAssociate
						ELSE @IdAssociate
						END

	DELETE @TableKeysFinal
	FROM @TableKeysFinal tf
	INNER JOIN @TableKeysTemp tt
	ON 	tf.IdProject = tt.IdProject AND
		tf.IdPhase = tt.IdPhase AND
		tf.IdWorkPackage = tt.IdWorkPackage AND
		tf.IdCostCenter = tt.IdCostCenter AND
		tf.IdAssociate = tt.IdAssociate AND
		tf.YearMonth = tt.YearMonth

	INSERT INTO @TableKeysFinal  (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	SELECT 	IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		YearMonth,
		0,0,0
	FROM @TableKeysTemp

--delete the temp table to reuse it for actual data

	DELETE FROM @TableKeysTemp

-- populate table with keys from actual data

	--Create a table which will hold all keys from the 3 actual tables (ACTUAL_DATA_DETAILS_HOURS, ACTUAL_DATA_DETAILS_SALES,
	--ACTUAL_DATA_DETAILS_COSTS)
	CREATE TABLE #ACTUAL_DATA_KEYS
	(
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWorkPackage INT NOT NULL,
		IdCostCenter INT NOT NULL,
		YearMonth INT NOT NULL
		PRIMARY KEY (IdProject, IdPhase, IdWorkPackage, IdCostCenter, YearMonth)
	)
	
	--Insert the actual keys in the #ACTUAL_DATA_KEYS table
	INSERT INTO #ACTUAL_DATA_KEYS (IdProject, IdPhase, IdWorkPackage, IdCostCenter, YearMonth)
	SELECT  DISTINCT
		AD.IdProject,
		AD.IdPhase, 
		AD.IdWorkPackage, 
		AD.IdCostCenter,		
		AD.YearMonth
	FROM ACTUAL_DATA_DETAILS_HOURS AD
	INNER JOIN  #BUDGET_PRESELECTION_TEMP BPT ON
		AD.IdProject = BPT.IdProject AND
		AD.IdPhase = BPT.IdPhase AND
		AD.IdWorkPackage = BPT.IdWP
	UNION
	SELECT  DISTINCT
		AD.IdProject,
		AD.IdPhase, 
		AD.IdWorkPackage, 
		AD.IdCostCenter,		
		AD.YearMonth
	FROM ACTUAL_DATA_DETAILS_SALES AD
	INNER JOIN  #BUDGET_PRESELECTION_TEMP BPT ON
		AD.IdProject = BPT.IdProject AND
		AD.IdPhase = BPT.IdPhase AND
		AD.IdWorkPackage = BPT.IdWP
	UNION
	SELECT  DISTINCT
		AD.IdProject,
		AD.IdPhase, 
		AD.IdWorkPackage, 
		AD.IdCostCenter,		
		AD.YearMonth
	FROM ACTUAL_DATA_DETAILS_COSTS AD
	INNER JOIN  #BUDGET_PRESELECTION_TEMP BPT ON
		AD.IdProject = BPT.IdProject AND
		AD.IdPhase = BPT.IdPhase AND
		AD.IdWorkPackage = BPT.IdWP

	INSERT INTO @TableKeysTemp (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth)
	SELECT  IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		-1,
		YearMonth
	FROM	#ACTUAL_DATA_KEYS

--insert into final table the keys from actual for months that not exists

	INSERT INTO @TableKeysFinal  (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual)
	SELECT 	tt.IdProject,
		tt.IdPhase,
		tt.IdWorkPackage,
		tt.IdCostCenter,
		-1,
		tt.YearMonth,
		1
	FROM @TableKeysTemp tt
	LEFT JOIN @TableKeysFinal tf
	ON 	tt.IdProject = tf.IdProject AND
		tt.IdPhase = tf.IdPhase AND
		tt.IdWorkPackage = tf.IdWorkPackage AND
		tt.IdCostCenter = tf.IdCostCenter AND
		tt.YearMonth = tf.YearMonth
	WHERE 1 = CASE WHEN @IsNewValidated=1 AND ISNULL(@ToCompletionCurrentGenerationNo,-1) <> @ToCompletionNewGenerationNo THEN
					CASE WHEN tt.YearMonth <= ISNULL(@YearMonthActualDataForNew, 190001) 
						then 1 
					else 
						0 END
			 ELSE 1	END
		AND tf.IdProject IS NULL

	--------------------------------------------------------------------------------------------------------------------------------------

	--This code is for the special case when a cost center is found only in actual data. In this case, we must artificially fill in
	--all months from the period of the wp to which the cc belongs even if these records are not found in any table (to completionl, revised
	--actual data). The user must always see the entire period of the wp, for all cost centers that belong to that wp
	
	DELETE FROM @TableKeysTemp

	--For each cost center in the final table, cross join with the period of the wp it belongs to. We will have all periods
	--for all cost centers in @TableKeysTemp
	INSERT INTO @TableKeysTemp(IdProject, IdPhase, IdWorkPackage,IdCostCenter,IdAssociate, YearMonth)
	SELECT DISTINCT
		tf.IdProject, 
		tf.IdPhase,
		tf.IdWorkPackage,
		tf.IdCostCenter,
		0, --The artificially inserted records will have 0 for id associate
		WPM.YearMonth
	FROM 	@TableKeysFinal tf
	CROSS JOIN #WPMonths WPM
	WHERE 	tf.IdProject = WPM.IdProject AND
		tf.IdPhase = WPM.IdPhase AND
		tf.IdWorkPackage = WPM.IdWP

	--Delete the months which are already in the final table. What remains will be the cost center months which are missing (for the
	--cost centers that had only actual data - they were present only in actual_data_details table)
	DELETE @TableKeysTemp
	FROM @TableKeysTemp tt
	INNER JOIN @TableKeysFinal tf ON --On purpose incomplete join. The IdAssociate in @TableKeysTemp is 0
		tf.IdProject = tt.IdProject AND
		tf.IdPhase = tt.IdPhase AND
		tf.IdWorkPackage = tt.IdWorkPackage AND
		tf.IdCostCenter = tt.IdCostCenter AND
		tf.YearMonth = tt.YearMonth

	--Fill in the missing months
	INSERT INTO @TableKeysFinal  (IdProject,IdPhase,IdWorkPackage,IdCostCenter,IdAssociate,YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	SELECT 	IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		YearMonth,
		0, 0, 0
	FROM @TableKeysTemp
	--------------------------------------------------------------------------------------------------------------------------------------

	IF (@ToCompletionCurrentGenerationNo IS NOT NULL)
	BEGIN
		-- 	update flag to mark actual data for previous and released versions
		UPDATE 	tf
		SET 	tf.IsCurrentActual = CASE WHEN tf.YearMonth<=BTC.YearMonthActualData THEN 1 ELSE 0 END
		FROM 	@TableKeysFinal tf
		INNER JOIN BUDGET_TOCOMPLETION BTC
		ON 	BTC.IdProject = tf.IdProject AND
			BTC.IdGeneration = @ToCompletionCurrentGenerationNo
		INNER JOIN #ACTUAL_DATA_KEYS AD
		ON	AD.IdProject = tf.IdProject AND
			AD.IdPhase = tf.IdPhase AND
			AD.IdWorkPackage = tf.IdWorkPackage AND
			AD.IdCostCenter = tf.IdCostCenter AND
			AD.YearMonth  = tf.YearMonth
	END
	ELSE
	BEGIN
		--If the previous generation does not exist, set all IsPreviousActual flags to 0
		UPDATE 	@TableKeysFinal
		SET 	IsCurrentActual = 0
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL)
	BEGIN
		UPDATE 	tf
		SET 	tf.IsPreviousActual = CASE WHEN tf.YearMonth<=BTC.YearMonthActualData THEN 1 ELSE 0 END
		FROM 	@TableKeysFinal tf
		INNER JOIN BUDGET_TOCOMPLETION BTC
		ON 	BTC.IdProject = tf.IdProject AND
			BTC.IdGeneration = @ToCompletionPreviousGenerationNo
		INNER JOIN #ACTUAL_DATA_KEYS AD
		ON	AD.IdProject = tf.IdProject AND
			AD.IdPhase = tf.IdPhase AND
			AD.IdWorkPackage = tf.IdWorkPackage AND
			AD.IdCostCenter = tf.IdCostCenter AND
			AD.YearMonth  = tf.YearMonth
	END
	ELSE
	BEGIN
		--If the previous generation does not exist, set all IsPreviousActual flags to 0
		UPDATE 	@TableKeysFinal
		SET 	IsPreviousActual = 0
	END


-------------------------------------------------------------------------------------------------------------------------------------------
/*For all months prior to the earliest month from actual data (for each wp) or to YearMonthActualData from BUDGET_TOCOMPLETION, mark the respective
rows as if they were from actual (they will appear in blue and empty)*/

----------Create YearMonth for current date
	DECLARE @YearMonthOfPreviousMonth INT
	Set @YearMonthOfPreviousMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate())

	--All months before the smallest month from actual or before the YearMonthActualData from BUDGET_TOCOMPLETION (whichever comes first) for new generation
	--for each work package will be marked as if they had actual data, so that they appear with blue in the interface and with empty
	--values -- for new is different
	UPDATE tf
	SET IsNewActual = 1
	FROM @TableKeysFinal tf
	WHERE tf.YearMonth <= CASE WHEN @IsNewValidated=1 AND ISNULL(@ToCompletionCurrentGenerationNo,-1) <> @ToCompletionNewGenerationNo
						 THEN ISNULL(@YearMonthActualDataForNew, 190001) ELSE @YearMonthOfPreviousMonth END

	--All months before the smallest month from actual or before the YearMonthActualData from BUDGET_TOCOMPLETION (whichever comes first) for released generation
	--for each work package will be marked as if they had actual data, so that they appear with blue in the interface and with empty
	--values
	UPDATE tf
	SET IsCurrentActual = 1
	FROM @TableKeysFinal tf
	INNER JOIN BUDGET_TOCOMPLETION BC
	ON	BC.IdProject = tf.IdProject AND
		BC.IdGeneration = @ToCompletionCurrentGenerationNo
	WHERE 	BC.YearMonthActualData IS NOT NULL AND
		tf.YearMonth <= BC.YearMonthActualData 


	--All months before the smallest month from actual or before the YearMonthActualData from BUDGET_TOCOMPLETION (whichever comes first) for previous generation
	--for each work package will be marked as if they had actual data, so that they appear with blue in the interface and with empty
	--values
	UPDATE tf
	SET IsPreviousActual = 1
	FROM @TableKeysFinal tf
	INNER JOIN BUDGET_TOCOMPLETION BC
	ON	BC.IdProject = tf.IdProject AND
		BC.IdGeneration = @ToCompletionPreviousGenerationNo
	WHERE 	BC.YearMonthActualData IS NOT NULL AND
			tf.YearMonth <= BC.YearMonthActualData

-------------------------------------------------------------------------------------------------------------------------------------------
-- make the final select
	
	SELECT	IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		YearMonth,
		IsNewActual,
		IsCurrentActual,
		IsPreviousActual
	FROM @TableKeysFinal
	ORDER BY IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth

GO

--Drops the Procedure bgtGetToCompletionBudgetNetCostsEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetNetCostsEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetNetCostsEvidence
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetNetCostsEvidence
	@IdProject 				INT,
	@IdAssociate			INT,
	@IdAssociateViewer		INT,
	@IsAssociateCurrency 	BIT,
	@Version				CHAR(1), -- version of budget
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry		INT,
	@IdCurrencyDisplay		int = 0
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT

	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @RetVal INT
	

	---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -1
	END

	--Find out the associate currency
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	if @IdCurrencyDisplay <= 0 
		begin
		-- if Currency wasn't specified on the page, then relies on the currency of the viewer
			IF (@IsAssociateCurrency = 1)
			BEGIN
				SELECT @AssociateCurrency = CTR.IdCurrency,
					   @AssociateCurrencyCode = CRR.Code
				FROM ASSOCIATES AS ASOC
				INNER JOIN COUNTRIES AS CTR 
					ON CTR.Id = ASOC.IdCountry
				INNER JOIN CURRENCIES AS CRR 
					ON CRR.Id = CTR.IdCurrency
				WHERE ASOC.Id = @IdAssociateViewer
			END
		end
	else
		begin
			-- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
			@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
		end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
		IdGeneration = @ToCompletionCurrentGenerationNo


	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id INT identity(1,1),
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous DECIMAL(21, 6),
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff DECIMAL(21, 6),
		[Current] DECIMAL(21, 6),
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff DECIMAL(21, 6),
		New DECIMAL(21, 6),
		IsNewActual BIT NOT NULL,
		NewRevisedDiff DECIMAL(21, 6),
		Revised DECIMAL(21, 6),
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		EXEC @RetVal = bgtCheckERForReforcastKeys @IdAssociate = @IdAssociate, @AssociateCurrency = @AssociateCurrency, @AssociateCurrencyCode = @AssociateCurrencyCode
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -2
	END

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		/*
		COALESCE(dbo.fnGetActualOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1),
			 dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),
			 dbo.fnGetActualSalesVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth)
			) IS NULL
		*/
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment

	--Add new values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
			*
			CASE WHEN (@Version = 'P' OR @Version = 'C')
			THEN
				CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1) IS NULL AND
				     BCD.HoursVal IS NULL AND BCD.SalesVal IS NULL
				) THEN NULL ELSE 
				(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1), 0) 
				+ ISNULL(BCD.HoursVal, 0) + ISNULL(BCD.SalesVal, 0))
			  	END
			ELSE
				CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1) IS NULL AND
				     dbo.fnGetValuedHours(BTD.IdCostCenter, BCD.HoursQty, BTD.YearMonth) IS NULL AND BCD.SalesVal IS NULL
				) THEN NULL ELSE 
				(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionNewGenerationNo, BTD.YearMonth, -1), 0) 
				+ ISNULL(dbo.fnGetValuedHours(BTD.IdCostCenter, BCD.HoursQty, BTD.YearMonth), 0) + ISNULL(BCD.SalesVal, 0))
			  	END
			END
			  
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
					*	(ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
						+ ISNULL(dbo.fnGetActualHoursVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0) 
						+ ISNULL(dbo.fnGetActualSalesVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				*
				  CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionCurrentGenerationNo, BTD.YearMonth, -1) IS NULL AND
					     BCD.HoursVal IS NULL AND BCD.SalesVal IS NULL
					) THEN NULL ELSE 
					(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionCurrentGenerationNo, BTD.YearMonth, -1), 0) 
					+ ISNULL(BCD.HoursVal, 0) + ISNULL(BCD.SalesVal, 0))
				  END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
					*	(ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
						+ ISNULL(dbo.fnGetActualHoursVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0) 
						+ ISNULL(dbo.fnGetActualSalesVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				*
				  CASE WHEN (dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionPreviousGenerationNo, BTD.YearMonth, -1) IS NULL AND
					     BCD.HoursVal IS NULL AND BCD.SalesVal IS NULL
					) THEN NULL ELSE 
					(ISNULL(dbo.fnGetToCompletionOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @ToCompletionPreviousGenerationNo, BTD.YearMonth, -1), 0) 
					+ ISNULL(BCD.HoursVal, 0) + ISNULL(BCD.SalesVal, 0))
				  END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
					*	(ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1), 0) 
						+ ISNULL(dbo.fnGetActualHoursVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0) 
						+ ISNULL(dbo.fnGetActualSalesVal (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth), 0))
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsPreviousActual = 1

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END 
				* 
			      CASE WHEN dbo.fnGetToCompletionRevisedOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @RevisedGenerationNo, BTD.YearMonth, -1) IS NULL AND
				BRD.HoursVal IS NULL AND BRD.SalesVal IS NULL
			      THEN NULL
			      ELSE ISNULL(dbo.fnGetToCompletionRevisedOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @RevisedGenerationNo, BTD.YearMonth, -1), 0) 
			 	+ ISNULL(BRD.HoursVal, 0) + ISNULL(BRD.SalesVal, 0)
			      END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BRD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency

	-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id


	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND([Current], 0), 0) END
	END

	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND(Revised, 0), 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL(ROUND([Current], 0), 0) - ISNULL(ROUND(Previous, 0), 0) END	
	END


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		DECIMAL(21, 6),
		CurrentPreviousDiff	DECIMAL(21, 6),
		[Current]		DECIMAL(21, 6),
		NewCurrentDiff		DECIMAL(21, 6),
		New			DECIMAL(21, 6),
		NewRevisedDiff		DECIMAL(21, 6),
		Revised			DECIMAL(21, 6),
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL			
		ORDER BY DP.Rank, BTD.CostCenterName
	END



	--Select the first table
	SELECT 	BPT.IdProject 			AS	'IdProject',
		BPT.IdPhase			AS	'IdPhase',
		BPT.IdWP			AS	'IdWP',
		WP.Code				AS	'PhaseWPCode', 
		WP.Code + ' - ' + WP.Name	AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END AS 	'Progress',
		WP.StartYearMonth		AS	'StartYearMonth',
		WP.EndYearMonth			AS	'EndYearMonth',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Previous, 0), 0)) ELSE NULL END		AS	'Previous',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.CurrentPreviousDiff, 0), 0)) ELSE NULL END 	AS	'CurrentPreviousDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.[Current], 0), 0)) ELSE NULL END		AS 	'Current',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewCurrentDiff, 0), 0)) ELSE NULL END	AS	'NewCurrentDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.New, 0), 0)) ELSE NULL END			AS	'New',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewRevisedDiff, 0), 0)) ELSE NULL END	AS	'NewRevisedDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Revised, 0), 0)) ELSE NULL END		AS 	'Revised',
		WP.IsActive			AS 	'IsActive'
	FROM 	#BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON 
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, BCP.[Percent], WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the second table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE


	--Select the third table
	SELECT	BTD.IdProject		AS	'IdProject',
		BTD.IdPhase			AS	'IdPhase',
		BTD.IdWP			AS	'IdWP',
		BTD.IdCostCenter		AS	'IdCostCenter',
		BTD.YearMonth		AS	'YearMonth',
		SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
		BTD.IsPreviousActual	AS	'IsPreviousActual',
		SUM(ROUND(BTD.CurrentPreviousDiff, 0))	AS	'CurrentPreviousDiff',
		SUM(ROUND(BTD.[Current], 0))		AS	'Current',
		BTD.IsCurrentActual		AS	'IsCurrentActual',
		SUM(ROUND(BTD.NewCurrentDiff, 0))		AS	'NewCurrentDiff',
		SUM(ROUND(BTD.New, 0))			AS	'New',
		BTD.IsNewActual		AS	'IsNewActual',
		SUM(ROUND(BTD.NewRevisedDiff, 0))		AS	'NewRevisedDiff',
		SUM(ROUND(BTD.Revised, 0))			AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth


GO

--Drops the Procedure bgtGetToCompletionBudgetOtherCostsEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetOtherCostsEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetOtherCostsEvidence
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetOtherCostsEvidence
	@IdProject				INT,
	@IdAssociate			INT,
	@IdAssociateViewer		INT,
	@IsAssociateCurrency 	BIT,
	@Version				CHAR(1), -- First version of budget
	@IdCostType				INT,
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry		INT,
	@IdCurrencyDisplay		int = 0
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT

	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @RetVal INT
	

	---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -2
	END

	--Find out the associate currency
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	if @IdCurrencyDisplay <= 0 
		begin
		-- if Currency wasn't specified on the page, then relies on the currency of the viewer
			IF (@IsAssociateCurrency = 1)
			BEGIN
				SELECT @AssociateCurrency = CTR.IdCurrency,
					   @AssociateCurrencyCode = CRR.Code
				FROM ASSOCIATES AS ASOC
				INNER JOIN COUNTRIES AS CTR 
					ON CTR.Id = ASOC.IdCountry
				INNER JOIN CURRENCIES AS CRR 
					ON CRR.Id = CTR.IdCurrency
				WHERE ASOC.Id = @IdAssociateViewer
			END
		end
	else
		begin
			-- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
			@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
		end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
			IdGeneration = @ToCompletionCurrentGenerationNo

	
	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id INT identity(1,1), 
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous DECIMAL(22, 6),
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff DECIMAL(22, 6),
		[Current] DECIMAL(22, 6),
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff DECIMAL(22, 6),
		New DECIMAL(22, 6),
		IsNewActual BIT NOT NULL,
		NewRevisedDiff DECIMAL(22, 6),
		Revised DECIMAL(22, 6),
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version

	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		EXEC @RetVal = bgtCheckERForReforcastKeys @IdAssociate = @IdAssociate, @AssociateCurrency = @AssociateCurrency, @AssociateCurrencyCode = @AssociateCurrencyCode
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -3
	END

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		--dbo.fnGetActualOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, -1) IS NULL
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment

	--Add new values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
			* dbo.fnGetToCompletionOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END,
			@ToCompletionNewGenerationNo, BTD.YearMonth, @IdCostType)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
			* ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, @IdCostType),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* dbo.fnGetToCompletionOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END,
				@ToCompletionCurrentGenerationNo, BTD.YearMonth, @IdCostType)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, @IdCostType),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* dbo.fnGetToCompletionOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END,
				@ToCompletionPreviousGenerationNo, BTD.YearMonth, @IdCostType)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* ISNULL(dbo.fnGetActualOtherCosts (BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, @IdCostType),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsPreviousActual = 1

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END 
				* dbo.fnGetToCompletionRevisedOtherCosts(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter,
				CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END, @RevisedGenerationNo, BTD.YearMonth,
				@IdCostType)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BRD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency

	-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id


	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND([Current], 0), 0) END
	END

	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND(Revised, 0), 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL(ROUND([Current], 0), 0) - ISNULL(ROUND(Previous, 0), 0) END	
	END


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		DECIMAL(22, 6),
		CurrentPreviousDiff	DECIMAL(22, 6),
		[Current]		DECIMAL(22, 6),
		NewCurrentDiff		DECIMAL(22, 6),
		New			DECIMAL(22, 6),
		NewRevisedDiff		DECIMAL(22, 6),
		Revised			DECIMAL(22, 6),
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL	
		ORDER BY DP.Rank, BTD.CostCenterName
	END



	--Select the first table
	SELECT 	BPT.IdProject 			AS	'IdProject',
		BPT.IdPhase			AS	'IdPhase',
		BPT.IdWP			AS	'IdWP',
		WP.Code				AS	'PhaseWPCode',
		WP.Code + ' - ' + WP.Name	AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END AS 	'Progress',
		WP.StartYearMonth		AS	'StartYearMonth',
		WP.EndYearMonth			AS	'EndYearMonth',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Previous, 0), 0)) ELSE NULL END		AS	'Previous',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.CurrentPreviousDiff, 0), 0)) ELSE NULL END 	AS	'CurrentPreviousDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.[Current], 0), 0)) ELSE NULL END		AS 	'Current',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewCurrentDiff, 0), 0)) ELSE NULL END	AS	'NewCurrentDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.New, 0), 0)) ELSE NULL END			AS	'New',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewRevisedDiff, 0), 0)) ELSE NULL END	AS	'NewRevisedDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Revised, 0), 0)) ELSE NULL END		AS 	'Revised',
		WP.IsActive			AS 	'IsActive'
	FROM 	#BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON 
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, BCP.[Percent], WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the second table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE


	--Select the third table
	SELECT	BTD.IdProject		AS	'IdProject',
		BTD.IdPhase			AS	'IdPhase',
		BTD.IdWP			AS	'IdWP',
		BTD.IdCostCenter		AS	'IdCostCenter',
		BTD.YearMonth		AS	'YearMonth',
		SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
		BTD.IsPreviousActual	AS	'IsPreviousActual',
		SUM(ROUND(BTD.CurrentPreviousDiff, 0))	AS	'CurrentPreviousDiff',
		SUM(ROUND(BTD.[Current], 0))		AS	'Current',
		BTD.IsCurrentActual		AS	'IsCurrentActual',
		SUM(ROUND(BTD.NewCurrentDiff, 0))		AS	'NewCurrentDiff',
		SUM(ROUND(BTD.New, 0))			AS	'New',
		BTD.IsNewActual		AS	'IsNewActual',
		SUM(ROUND(BTD.NewRevisedDiff, 0))		AS	'NewRevisedDiff',
		SUM(ROUND(BTD.Revised, 0))			AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth

GO

--Drops the Procedure bgtGetToCompletionBudgetSalesEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetSalesEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetSalesEvidence
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetSalesEvidence
	@IdProject				INT,
	@IdAssociate			INT,
	@IdAssociateViewer		INT,
	@IsAssociateCurrency 	BIT,
	@Version				CHAR(1), -- Version of budget
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry		INT,
	@IdCurrencyDisplay		int = 0
AS
	
	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT
	
	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @RetVal INT
	

---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -1
	END


	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id INT identity(1,1),
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous DECIMAL(20, 6),
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff DECIMAL(20, 6),
		[Current] DECIMAL(20, 6),
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff DECIMAL(20, 6),
		New DECIMAL(20, 6),
		IsNewActual BIT NOT NULL,
		NewRevisedDiff DECIMAL(20, 6),
		Revised DECIMAL(20, 6),
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version



--Find out the associate currency
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)
	
	if @IdCurrencyDisplay <= 0
	   begin
	   -- if Currency wasn't specified on the page, then relies on the currency of the viewer
			SELECT 	@AssociateCurrency = CTR.IdCurrency,
				@AssociateCurrencyCode = CRR.Code
			FROM ASSOCIATES ASOC
			INNER JOIN COUNTRIES CTR 
				ON CTR.Id = ASOC.IdCountry
			INNER JOIN CURRENCIES CRR 
				ON CRR.Id = CTR.IdCurrency
			WHERE ASOC.Id = @IdAssociateViewer
	   end
	else
		begin
			-- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
			@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
		end

-- check to find if there is exchange rate for every record
	IF (@IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0)
	BEGIN
		EXEC @RetVal = bgtCheckERForReforcastKeys @IdAssociate, @AssociateCurrency, @AssociateCurrencyCode
		IF (@@ERROR <> 0 OR @RetVal < 0)
		BEGIN
			RETURN -2
		END
	END

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		--dbo.fnGetActualSalesVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth) IS NULL	
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment
--Add new values from To Completion (for entries that are not from actual)



	UPDATE 	BTD
	SET 	BTD.New =
				CASE 	WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0
					THEN 
						dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BCD.YearMonth)
					ELSE
						1
					END 
						* 
					BCD.SalesVal


	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = BTD.IdAssociate AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE 	WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN 	dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE	1 END 
						*  ISNULL(dbo.fnGetActualSalesVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE 	WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0
					THEN 
						dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BCD.YearMonth)
					ELSE
						1
					END 
						* 
					BCD.SalesVal


	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = BTD.IdAssociate AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency

	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END 
							* ISNULL(dbo.fnGetActualSalesVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)	
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = CASE 	WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0
					THEN 
						dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BCD.YearMonth)
					ELSE
						1
					END 
						* 
					BCD.SalesVal


	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = BTD.IdAssociate AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE	1 END 
							*  ISNULL(dbo.fnGetActualSalesVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency

	WHERE	BTD.IsPreviousActual = 1

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = CASE 	WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0
					THEN 
						dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BRD.YearMonth)
					ELSE
						1
					END 
						* 
					BRD.SalesVal

	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = BTD.IdAssociate AND
		BRD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency


	-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id


	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(New, 0) - ISNULL([Current], 0) END
	END

	
	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(New, 0) - ISNULL(Revised, 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL([Current], 0) - ISNULL(Previous, 0) END
	END

	
	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
		IdGeneration = @ToCompletionCurrentGenerationNo


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		DECIMAL(20, 6),
		CurrentPreviousDiff	DECIMAL(20, 6),
		[Current]		DECIMAL(20, 6),
		NewCurrentDiff		DECIMAL(20, 6),
		New			DECIMAL(20, 6),
		NewRevisedDiff		DECIMAL(20, 6),
		Revised			DECIMAL(20, 6),
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(BTD.Previous)		AS	'Previous',
			SUM(BTD.CurrentPreviousDiff) 	AS	'CurrentPreviousDiff',
			SUM(BTD.[Current])		AS 	'Current',
			SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
			SUM(BTD.New)			AS	'New',
			SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
			SUM(BTD.Revised)		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(BTD.Previous)		AS	'Previous',
			SUM(BTD.CurrentPreviousDiff) 	AS	'CurrentPreviousDiff',
			SUM(BTD.[Current])		AS 	'Current',
			SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
			SUM(BTD.New)			AS	'New',
			SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
			SUM(BTD.Revised)		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL	
		ORDER BY DP.Rank, BTD.CostCenterName
	END


	
	--Select the first table
	SELECT 	BPT.IdProject 				AS	'IdProject',
		BPT.IdPhase				AS	'IdPhase',
		BPT.IdWP				AS	'IdWP',
		WP.Code					AS	'PhaseWPCode',
		WP.Code + ' - ' + WP.Name		AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END 	AS 'Progress',
		WP.StartYearMonth			AS	'StartYearMonth',
		WP.EndYearMonth				AS	'EndYearMonth',
		SUM(ISNULL(CC.Previous, 0))		AS	'Previous',
		SUM(ISNULL(CC.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
		SUM(ISNULL(CC.[Current], 0))		AS 	'Current',
		SUM(ISNULL(CC.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
		SUM(ISNULL(CC.New, 0))			AS	'New',
		SUM(ISNULL(CC.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
		SUM(ISNULL(CC.Revised, 0))		AS 	'Revised',
		WP.IsActive				AS 	'IsActive'
	FROM 	#BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON 
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, BCP.[Percent], WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the second table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE
	

	--Select the third table
	SELECT	BTD.IdProject			AS	'IdProject',
		BTD.IdPhase			AS	'IdPhase',
		BTD.IdWP			AS	'IdWP',
		BTD.IdCostCenter		AS	'IdCostCenter',
		BTD.YearMonth			AS	'YearMonth',
		SUM(BTD.Previous)		AS	'Previous',
		BTD.IsPreviousActual		AS	'IsPreviousActual',
		SUM(BTD.CurrentPreviousDiff)	AS	'CurrentPreviousDiff',
		SUM(BTD.[Current])		AS	'Current',
		BTD.IsCurrentActual		AS	'IsCurrentActual',
		SUM(BTD.NewCurrentDiff)		AS	'NewCurrentDiff',
		SUM(BTD.New)			AS	'New',
		BTD.IsNewActual			AS	'IsNewActual',
		SUM(BTD.NewRevisedDiff)		AS	'NewRevisedDiff',
		SUM(BTD.Revised)		AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth

GO


	--Drops the Procedure bgtGetToCompletionBudgetValHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetToCompletionBudgetValHoursEvidence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetToCompletionBudgetValHoursEvidence
GO

CREATE  PROCEDURE bgtGetToCompletionBudgetValHoursEvidence
	@IdProject 				INT,
	@IdAssociate			INT,
	@IdAssociateViewer		INT,
	@Version				CHAR(1), -- First version of budget
	@IsAssociateCurrency 	BIT,
	@ShowOnlyCCsWithSignificantValues	BIT,
	@IdCountry 		INT,
	@IdCurrencyDisplay		int = 0
AS

	if @IdCurrencyDisplay is null
		set @IdCurrencyDisplay = 0

-- 	CHECK CONSISTENCY BETWEEN TEMPORARY TABLE AND WORK PACKAGE TABLE
	IF EXISTS
	(
		SELECT BPT.IdProject, BPT.IdPhase, BPT.IdWP
		FROM #BUDGET_PRESELECTION_TEMP AS BPT
		LEFT JOIN WORK_PACKAGES AS WP
			ON WP.IdProject = BPT.IdProject
			AND WP.IdPhase = BPT.IdPhase
			AND WP.[Id] = BPT.IdWP
	 	WHERE WP.IDPhase IS NULL
	)
	BEGIN
		RAISERROR('Budget check: key information about at least one of project''s WPs was changed by another user. Return to preselection screen and re-select your WPs.', 16, 1)
		RETURN -1
	END

	DECLARE @RevisedGenerationNo INT
	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT

	DECLARE @fnErrorState			INT
	DECLARE @fnErrorMessage			varchar(255)

	DECLARE @RetVal INT
	

	---------Get generations numbers
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	
	SELECT  @ToCompletionPreviousGenerationNo = ToCompletionPreviousGenerationNo,
		@ToCompletionCurrentGenerationNo = ToCompletionCurrentGenerationNo,
		@ToCompletionNewGenerationNo = ToCompletionNewGenerationNo,
		@fnErrorState = ErrorState,
		@fnErrorMessage = ErrorMessage
	FROM dbo.fnGetToCompletionGenerationFromVersion(@IdProject, @Version, @IdAssociate)

	IF @fnErrorState=-1
	BEGIN
		RAISERROR(@fnErrorMessage,16,1)
		RETURN -2
	END

	--Find out the associate currency
	DECLARE	@AssociateCurrency INT
	DECLARE @AssociateCurrencyCode VARCHAR(10)

	if @IdCurrencyDisplay <= 0 
		begin
		-- if Currency wasn't specified on the page, then relies on the currency of the viewer
			IF (@IsAssociateCurrency = 1)
			BEGIN
				SELECT @AssociateCurrency = CTR.IdCurrency,
					   @AssociateCurrencyCode = CRR.Code
				FROM ASSOCIATES ASOC
				INNER JOIN COUNTRIES CTR 
					ON CTR.Id = ASOC.IdCountry
				INNER JOIN CURRENCIES CRR 
					ON CRR.Id = CTR.IdCurrency
				WHERE ASOC.Id = @IdAssociateViewer
			END
		end
	else
		begin
			-- if Currency was specified on the page, then relies on the this currency. This becomes the currency of the viewer
			SELECT  @AssociateCurrency = @IdCurrencyDisplay,
			@AssociateCurrencyCode = Code
			from CURRENCIES
			where Id = @IdCurrencyDisplay
		end

	DECLARE @IsBudgetValidated BIT
	SELECT 	@IsBudgetValidated = IsValidated
	FROM	BUDGET_TOCOMPLETION
	WHERE	IdProject = @IdProject AND
		IdGeneration = @ToCompletionCurrentGenerationNo

 
	CREATE TABLE #BUDGET_TOCOMPLETION_DETAIL_TEMP
	(
		Id INT identity(1,1),
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL,
		IdWP INT NOT NULL,
		IdCostCenter INT NOT NULL,
		IdAssociate INT NOT NULL,
		YearMonth INT NOT NULL,
		WPName VARCHAR(36),
		CostCenterName VARCHAR(50),
		Previous DECIMAL(20, 6),
		IsPreviousActual BIT NOT NULL,
		CurrentPreviousDiff DECIMAL(20, 6),
		[Current] DECIMAL(20, 6),
		IsCurrentActual BIT NOT NULL,
		NewCurrentDiff DECIMAL(20, 6),
		New DECIMAL(20, 6),
		IsNewActual BIT NOT NULL,
		NewRevisedDiff DECIMAL(20, 6),
		Revised DECIMAL(20, 6),
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth)
	)

	INSERT INTO #BUDGET_TOCOMPLETION_DETAIL_TEMP (IdProject, IdPhase, IdWP, IdCostCenter, IdAssociate, YearMonth, IsNewActual, IsCurrentActual, IsPreviousActual)
	EXEC bgtGetToCompletionBudgetKeysTable @IdProject = @IdProject, @IdAssociate = @IdAssociate, @Version = @Version

	IF (@IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0)
	BEGIN
		EXEC @RetVal = bgtCheckERForReforcastKeys @IdAssociate = @IdAssociate, @AssociateCurrency = @AssociateCurrency, @AssociateCurrencyCode = @AssociateCurrencyCode
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -3
	END

	--Set the flag for IsNewActual to 0 if there are no actual data for the previous month 
	UPDATE	BTD
	SET	BTD.IsNewActual = 0
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	WHERE	BTD.YearMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate()) AND
		--dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth) IS NULL
		dbo.fnCheckUploadedActualDataForCC(BTD.IdCostCenter, BTD.YearMonth) = 0

	--Add the wp and cost center names
	UPDATE 	BTD 
	SET  	BTD.WPName = WP.Code + ' - ' + WP.Name,
		BTD.CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code]
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN WORK_PACKAGES WP ON
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWP
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN DEPARTMENTS DP ON
		DP.Id = CC.IdDepartment

	--Add new values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
			*
			CASE WHEN (@Version = 'P' OR @Version = 'C')
			THEN 
				BCD.HoursVal
			ELSE 
				dbo.fnGetValuedHours(BTD.IdCostCenter, BCD.HoursQty, BTD.YearMonth)
			END
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionNewGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 0

	--Add new values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.New = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
						* ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsNewActual = 1

	--Add released values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* BCD.HoursVal
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionCurrentGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE 	BTD.IsCurrentActual = 0

	--Add current values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.[Current] = CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsCurrentActual = 1

	--Add previous values from To Completion (for entries that are not from actual)
	UPDATE 	BTD
	SET 	BTD.[Previous] = CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0  THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* BCD.HoursVal
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_TOCOMPLETION_DETAIL BCD ON 
		BCD.IdProject = BTD.IdProject AND
		BCD.IdGeneration = @ToCompletionPreviousGenerationNo AND
		BCD.IdPhase = BTD.IdPhase AND
		BCD.IdWorkPackage = BTD.IdWP AND
		BCD.IdCostCenter = BTD.IdCostCenter AND
		BCD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BCD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	IsPreviousActual = 0

	--Add previous values from Actual (for entries that are from actual)
	UPDATE 	BTD
	SET 	BTD.Previous = CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END
				* ISNULL(dbo.fnGetActualHoursVal(BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth),0)
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency
	WHERE	BTD.IsPreviousActual = 1

	--Add revised values
	UPDATE 	BTD
	SET 	BTD.Revised = CASE WHEN @IsAssociateCurrency = 1  or @IdCurrencyDisplay > 0 THEN dbo.fnGetExchangeRate(CURR.[Id], @AssociateCurrency, BTD.YearMonth) ELSE 1 END 
				* BRD.HoursVal
	FROM 	#BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	INNER	JOIN BUDGET_REVISED_DETAIL BRD ON 
		BRD.IdProject = BTD.IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = BTD.IdPhase AND
		BRD.IdWorkPackage = BTD.IdWP AND
		BRD.IdCostCenter = BTD.IdCostCenter AND
		BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END AND
		BRD.YearMonth = BTD.YearMonth
	INNER JOIN COST_CENTERS CC ON
		CC.Id = BTD.IdCostCenter
	INNER JOIN INERGY_LOCATIONS IL ON
		IL.Id = CC.IdInergyLocation
	INNER JOIN COUNTRIES C ON
		C.Id = IL.IdCountry
	INNER JOIN CURRENCIES CURR ON
		CURR.Id = C.IdCurrency


	-- if there are 2 associates who have IsCurrentActual = 1 at the same node, leave only one of them to have
	-- [Current] <> 0, because [Current] is set to the sum, per team, of values from actual data
	update a
	set [Current] = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsCurrentActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsCurrentActual = 1 and a.Id > b.Id

	-- if there are 2 associates who have IsNewActual = 1 at the same node, leave only one of them to have
	-- [New] <> 0, because [New] is set to the sum, per team, of values from actual data
	update a
	set Previous = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsPreviousActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsPreviousActual = 1 and a.Id > b.Id


	-- if there are 2 associates who have IsPreviousActual = 1 at the same node, leave only one of them to have
	-- [Previous] <> 0, because [Previous] is set to the sum, per team, of values from actual data
	update a
	set New = 0
	from #BUDGET_TOCOMPLETION_DETAIL_TEMP a
	join
		(select IdProject, IdPhase, IdWP, IdCostCenter, YearMonth, min(Id) as Id
			from #BUDGET_TOCOMPLETION_DETAIL_TEMP
			where IsNewActual = 1
			group by IdProject, IdPhase, IdWP, IdCostCenter, YearMonth
			having count(*) > 1
		) b on 
			a.IdProject = b.IdProject and
			a.IdPhase = b.IdPhase and
			a.IdWP = b.IdWP and
			a.IdCostCenter = b.IdCostCenter and
			a.YearMonth = b.YearMonth
	where a.IsNewActual = 1 and a.Id > b.Id

	--Update diff columns
	IF (@ToCompletionNewGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewCurrentDiff = CASE WHEN New IS NULL AND [Current] IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND([Current], 0), 0) END
	END

	IF (@ToCompletionNewGenerationNo IS NOT NULL)--revised will always have a current version no need to test
	BEGIN
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	NewRevisedDiff = CASE WHEN New IS NULL AND Revised IS NULL THEN NULL ELSE ISNULL(ROUND(New, 0), 0) - ISNULL(ROUND(Revised, 0), 0) END
	END

	IF (@ToCompletionPreviousGenerationNo IS NOT NULL and @ToCompletionCurrentGenerationNo is NOT NULL)	
	BEGIN	
		UPDATE 	#BUDGET_TOCOMPLETION_DETAIL_TEMP
		SET 	CurrentPreviousDiff = CASE WHEN [Current] IS NULL AND Previous IS NULL THEN NULL ELSE ISNULL(ROUND([Current], 0), 0) - ISNULL(ROUND(Previous, 0), 0) END
	END


	CREATE TABLE #CC_TABLE
	(
		IdProject		INT,
		IdPhase			INT,
		IdWP			INT,
		IdCostCenter		INT,
		CostCenterName		VARCHAR(50),
		Previous		DECIMAL(20, 6),
		CurrentPreviousDiff	DECIMAL(20, 6),
		[Current]		DECIMAL(20, 6),
		NewCurrentDiff		DECIMAL(20, 6),
		New			DECIMAL(20, 6),
		NewRevisedDiff		DECIMAL(20, 6),
		Revised			DECIMAL(20, 6),
		IdCurrency		INT,
		CurrencyCode		VARCHAR(3)
		PRIMARY KEY (IdProject, IdPhase, IdWP, IdCostCenter)
	)

	IF ISNULL(@ShowOnlyCCsWithSignificantValues, 0) = 0
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		ORDER BY DP.Rank, BTD.CostCenterName
	END
	ELSE
	BEGIN
		INSERT INTO #CC_TABLE
		SELECT 	BTD.IdProject 			AS	'IdProject',
			BTD.IdPhase			AS	'IdPhase',
			BTD.IdWP			AS	'IdWP',
			BTD.IdCostCenter		AS	'IdCostCenter',
			BTD.CostCenterName		AS	'CostCenterName',
			SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
			SUM(ROUND(BTD.CurrentPreviousDiff, 0)) 	AS	'CurrentPreviousDiff',
			SUM(ROUND(BTD.[Current], 0))		AS 	'Current',
			SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
			SUM(ROUND(BTD.New, 0))			AS	'New',
			SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
			SUM(ROUND(BTD.Revised, 0))		AS 	'Revised',
			CURR.[Id]			AS 	'IdCurrency',
			CURR.[Code]			AS 	'CurrencyCode'
		FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP AS BTD
		INNER JOIN COST_CENTERS AS CC
			ON CC.Id = BTD.IdCostCenter
		INNER JOIN DEPARTMENTS DP
			ON DP.Id = CC.IdDepartment
		INNER JOIN INERGY_LOCATIONS AS IL
			ON IL.[Id] = CC.IdInergyLocation
		INNER JOIN COUNTRIES
			ON COUNTRIES.[Id] = IL.IdCountry
		INNER JOIN CURRENCIES CURR 
			ON CURR.[Id]=COUNTRIES.IdCurrency
		WHERE COUNTRIES.[Id] = CASE WHEN @IdCountry = -1 THEN COUNTRIES.[Id] ELSE @IdCountry END
		GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.CostCenterName, CURR.[Id], CURR.[Code], DP.Rank
		HAVING COALESCE( NULLIF(SUM(ROUND(BTD.[Current], 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewCurrentDiff, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.New, 0)), 0), 
				 NULLIF(SUM(ROUND(BTD.NewRevisedDiff, 0)), 0) 
				) IS NOT NULL
		ORDER BY DP.Rank, BTD.CostCenterName
	END



	--Select the first table
	SELECT 	BPT.IdProject 			AS	'IdProject',
		BPT.IdPhase			AS	'IdPhase',
		BPT.IdWP			AS	'IdWP',
		WP.Code				AS	'PhaseWPCode',
		WP.Code + ' - ' + WP.Name	AS	'PhaseWPName',
		CASE WHEN @IdAssociate = -1 THEN dbo.fnGetWeightedAveragePercent(BPT.IdProject, @ToCompletionNewGenerationNo, BPT.IdPhase, BPT.IdWP, @IdAssociate) 
		     ELSE MAX(BCP.[Percent]) END AS 	'Progress',
		WP.StartYearMonth		AS	'StartYearMonth',
		WP.EndYearMonth			AS	'EndYearMonth',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Previous, 0), 0)) ELSE NULL END		AS	'Previous',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.CurrentPreviousDiff, 0), 0)) ELSE NULL END 	AS	'CurrentPreviousDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.[Current], 0), 0)) ELSE NULL END		AS 	'Current',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewCurrentDiff, 0), 0)) ELSE NULL END	AS	'NewCurrentDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.New, 0), 0)) ELSE NULL END			AS	'New',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.NewRevisedDiff, 0), 0)) ELSE NULL END	AS	'NewRevisedDiff',
		CASE WHEN @IsAssociateCurrency = 1 or @IdCurrencyDisplay > 0 THEN SUM(ROUND(ISNULL(CC.Revised, 0), 0)) ELSE NULL END		AS 	'Revised',
		WP.IsActive			AS 	'IsActive'
	FROM 	#BUDGET_PRESELECTION_TEMP BPT
	LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BCP ON 
		BCP.IdProject = BPT.IdProject AND
		BCP.IdGeneration = @ToCompletionNewGenerationNo AND
		BCP.IdPhase = BPT.IdPhase AND
		BCP.IdWorkPackage = BPT.IdWP AND
		BCP.IdAssociate = @IdAssociate
	LEFT JOIN #CC_TABLE CC ON
		CC.IdProject = BPT.IdProject AND
		CC.IdPhase = BPT.IdPhase AND
		CC.IdWP = BPT.IdWP
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = BPT.IdProject AND
		WP.IdPhase = BPT.IdPhase AND
		WP.[Id] = BPT.IdWP
	INNER JOIN PROJECT_PHASES PH ON
		PH.Id = WP.IdPhase
	GROUP BY BPT.IdProject, BPT.IdPhase, BPT.IdWP, BCP.[Percent], WP.StartYearMonth, WP.EndYearMonth, WP.IsActive, PH.Code, WP.Code, WP.Name
	ORDER BY PH.Code


	--Select the second table
	SELECT IdProject, IdPhase, IdWP, IdCostCenter, CostCenterName, Previous, CurrentPreviousDiff, [Current],
		NewCurrentDiff, New, NewRevisedDiff, Revised, IdCurrency, CurrencyCode
	FROM #CC_TABLE


	--Select the third table
	SELECT	BTD.IdProject				AS	'IdProject',
		BTD.IdPhase				AS	'IdPhase',
		BTD.IdWP				AS	'IdWP',
		BTD.IdCostCenter			AS	'IdCostCenter',
		BTD.YearMonth				AS	'YearMonth',
		SUM(ROUND(BTD.Previous, 0))		AS	'Previous',
		BTD.IsPreviousActual			AS	'IsPreviousActual',
		SUM(ROUND(BTD.CurrentPreviousDiff, 0))	AS	'CurrentPreviousDiff',
		SUM(ROUND(BTD.[Current], 0))		AS	'Current',
		BTD.IsCurrentActual			AS	'IsCurrentActual',
		SUM(ROUND(BTD.NewCurrentDiff, 0))	AS	'NewCurrentDiff',
		SUM(ROUND(BTD.New, 0))			AS	'New',
		BTD.IsNewActual				AS	'IsNewActual',
		SUM(ROUND(BTD.NewRevisedDiff, 0))	AS	'NewRevisedDiff',
		SUM(ROUND(BTD.Revised, 0))		AS	'Revised'
	FROM #BUDGET_TOCOMPLETION_DETAIL_TEMP BTD
	GROUP BY BTD.IdProject, BTD.IdPhase, BTD.IdWP, BTD.IdCostCenter, BTD.YearMonth, BTD.IsPreviousActual, BTD.IsCurrentActual, BTD.IsNewActual
	ORDER BY BTD.YearMonth

GO

--Drops the Procedure bgtGetUnaffectedWP if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetUnaffectedWP]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetUnaffectedWP
GO
CREATE PROCEDURE bgtGetUnaffectedWP
	@IdProject 		AS INT 	--The Id of the Project
AS
	--Gets the unaffecte WP. This are the WP that have the StartYearMonth or EndYearMonth null OR
	--do not have any intrco information associated
	SELECT
		WRP.IdProject			AS		'IdProject',
		WRP.IdPhase			AS		'IdPhase',
		WRP.IdWP			AS		'IdWP',
		PH.Code				AS		'PhaseCode',
		WRP.WPCode + ' - ' + WRP.WPName	AS		'WPCode'
	FROM
		(SELECT DISTINCT
			WP.IdProject	AS		'IdProject',
			WP.IdPhase	AS		'IdPhase',
			WP.[Id]		AS		'IdWP',
			WP.Code		AS		'WPCode',
			WP.Name		AS		'WPName'
		FROM WORK_PACKAGES AS WP
		LEFT JOIN PROJECTS_INTERCO AS PI 
			ON PI.IdProject = WP.IdProject AND
			   PI.IdPhase = WP.IdPhase AND
			   PI.IdWorkPackage = WP.Id 
		WHERE WP.IdProject = @IdProject AND
		      WP.IsActive = 1
		GROUP BY WP.IdProject, WP.IdPhase, WP.Id, WP.StartYearMonth, WP.EndYearMonth, WP.Code, WP.Name
		HAVING (COUNT(PI.IdCountry) = 0) OR ((WP.StartYearMonth IS NULL) OR (WP.EndYearMonth IS NULL))
		) AS WRP
	INNER JOIN PROJECT_PHASES AS PH 
		ON WRP.IdPhase = PH.[Id]
	ORDER BY WRP.WPCode ASC
	
GO
--Drops the Procedure catSelectAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetWPIntercoCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetWPIntercoCountries
GO
CREATE PROCEDURE bgtGetWPIntercoCountries
	@IdProject 		AS INT 	--The Id of the selected Associate
AS
	SELECT DISTINCT
		PIL.IdProject 		AS	'IdProject',
		PIL.IdCountry		AS	'IdCountry',
		C.Name 			AS	'CountryName',
		PIL.Position		AS	'Position'
	FROM PROJECTS_INTERCO AS [PI]
	INNER JOIN PROJECTS_INTERCO_LAYOUT PIL ON
		[PI].IdProject = PIL.IdProject AND
		[PI].IdCountry = PIL.IdCountry
	INNER JOIN COUNTRIES AS C ON C.[Id] = [PIL].IdCountry
	INNER JOIN WORK_PACKAGES AS WP ON 	[PI].IdWorkPackage = WP.[Id] AND
						[PI].IdProject = WP.IdProject AND
						[PI].IdPhase = WP.IdPhase
	
	WHERE 	([PI].IdProject = @IdProject) AND
	--The following condition is used to get only the WP that have timing information
		((WP.StartYearMonth IS NOT NULL) AND (WP.EndYearMonth IS NOT NULL)) AND
		([PI].PercentAffected > 0) AND WP.IsActive = 1
	ORDER BY PIL.Position
GO


--Drops the Procedure bgtGetWPTiming if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtGetWPTiming]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtGetWPTiming
GO
CREATE PROCEDURE bgtGetWPTiming
	@IdProject 		AS INT, 	--The Id of the Project
	@IdPhase		AS INT,
	@IdWP			AS INT,
	@IdAssociate		AS INT
AS
	DECLARE @HasBudget BIT
	SET @HasBudget = 0

	IF
	(
		EXISTS
		(
			SELECT 	IdProject
			FROM	BUDGET_INITIAL_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdAssociate = @IdAssociate
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM	BUDGET_REVISED_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdAssociate = @IdAssociate
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM	BUDGET_TOCOMPLETION_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdAssociate = @IdAssociate
		)
	)
	BEGIN
		SET @HasBudget = 1
	END
	

	--Gets the detail table for Timing functionality
	SELECT DISTINCT
		[WP].IdProject 		AS	'IdProject',
		[WP].IdPhase		AS	'IdPhase',
		[PH].Code + ' - ' + [PH].Name	AS	'PhaseCode',
		[WP].[Id]		AS	'IdWP',
		WP.Code + ' - ' + WP.Name	AS	'WPCode',
		WP.StartYearMonth	AS	'StartYearMonth',
		WP.EndYearMonth		AS	'EndYearMonth',
		@HasBudget		AS 	'HasBudget'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.[Id]
	--The following join is used to get only the WP that have interco information
	WHERE 	(WP.IdProject = @IdProject) AND
		(WP.IdPhase = @IdPhase) AND
		(WP.Id = @IdWP)

GO


--Drops the Procedure bgtInitialBudgetEvidenceCheck if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInitialBudgetEvidenceCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInitialBudgetEvidenceCheck
GO

CREATE  PROCEDURE bgtInitialBudgetEvidenceCheck
	@IdProject		INT		--The Id of the selected Project
AS

DECLARE @Rowcount    INT
  
-- There is a project selected and the project is active
SET @Rowcount = (SELECT  count([Id]) AS 'ProjectsCount'
        FROM 	 PROJECTS
	WHERE   [Id]=@IdProject 
			AND [IsActive]=1);
IF (@Rowcount = 0)
BEGIN
	RAISERROR('The selected project must be active',16,1)
	RETURN -1
END

-- The project has at least 1 work package
SET @Rowcount = (SELECT count([Id]) 
		FROM WORK_PACKAGES
		WHERE	[IdProject] = @IdProject)
IF (@Rowcount = 0)
BEGIN
	RAISERROR('The selected project does not have any Work Packages defined',16,1)
	RETURN -2
END

RETURN 1
GO

--Drops the Procedure bgtInsertInitialBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertInitialBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertInitialBudget
GO

CREATE  PROCEDURE bgtInsertInitialBudget
	@IdProject	INT		--The Id of the selected Project
	
AS
BEGIN
	
	IF NOT EXISTS( SELECT *
	FROM PROJECTS AS P(TABLOCKX)
	WHERE 	P.[Id] = @IdProject) 
	BEGIN
		RAISERROR('The selected project does not exists anymore',16,1)
		RETURN
	END

	IF NOT EXISTS (SELECT IdProject FROM BUDGET_INITIAL WHERE IdProject = @IdProject)
	BEGIN
		INSERT INTO BUDGET_INITIAL 
			(IdProject, IsValidated, ValidationDate)
		VALUES	(@IdProject, 0, GETDATE())
	END
END
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--Drops the Procedure bgtInsertInitialBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertInitialBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertInitialBudgetDetail
GO

CREATE  PROCEDURE bgtInsertInitialBudgetDetail
	@IdProject	INT,		--The Id of the selected Project
	@IdPhase	INT,		--The Id of a phase from project
	@IdWP		INT,		--The Id of workpackage
	@IdCostCenter	INT,		--The Id of cost center
	@IdAssociate	INT,		--The Id of associate
	@YearMonth	INT
AS
BEGIN

	DECLARE @CostCenterName 	VARCHAR(50),
		@WPName			VARCHAR(50),
		@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end


	SET @CostCenterName = NULL
	SELECT 
		@CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code], --CC.[Name]
		@WPName = WP.Code + '-' + WP.[Name]
	FROM BUDGET_INITIAL_DETAIL AS BID (TABLOCKX)
	INNER JOIN COST_CENTERS AS CC ON
		CC.[Id] = @IdCostCenter
	INNER JOIN DEPARTMENTS AS DP ON
		DP.[Id] = CC.IdDepartment
	INNER JOIN INERGY_LOCATIONS AS IL ON
		IL.[Id] = CC.IdInergyLocation
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = @IdProject AND
		WP.IdPhase = @IdPhase AND
		WP.[Id] = @IdWP
	WHERE 	
		BID.[IdCostCenter] = @IdCostCenter AND
		BID.IdProject = @IdProject AND
		BID.IdPhase = @IdPhase AND
		BID.IdWorkPackage = @IdWP AND 
		BID.YearMonth = @YearMonth AND
		BID.IdAssociate = @IdAssociate


	IF (@CostCenterName IS NOT NULL)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DUPLICATE_COST_CENTER_1', @IdLanguage = 1, @Parameter1 = @CostCenterName, @Parameter2 = @WPName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END

	DECLARE @IdCountry INT
	DECLARE @CountryName VARCHAR(30)
	DECLARE @CountryHasDefaultAccounts BIT

	SELECT 	@IdCountry = C.[Id],
		@CountryName = C.[Name],
		@CostCenterName = CC.[Name]
	FROM 	COST_CENTERS CC
	INNER 	JOIN INERGY_LOCATIONS IL ON
		CC.IdInergyLocation = IL.[Id]
	INNER 	JOIN COUNTRIES C ON
		IL.IdCountry = C.[Id]
	WHERE 	CC.[Id] = @IdCostCenter

	SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)

	IF (@CountryHasDefaultAccounts = 0)
	BEGIN
		RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
		RETURN -3
	END

	DECLARE @IdAccountHours INT
	DECLARE @IdAccountSales INT

	--Select the account id for hours
	SELECT 	@IdAccountHours = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 6

	--Select the account id for sales
	SELECT 	@IdAccountSales = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 7
		
	
	--insert budget initial detail
	INSERT INTO BUDGET_INITIAL_DETAIL
		(IdProject, IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth,   HoursQty, HoursVal, SalesVal, IdCountry,  IdAccountHours,  IdAccountSales)
	VALUES(@IdProject,  @IdPhase, @IdWP,	     @IdCostCenter, @IdAssociate, @YearMonth,  NULL, 	 NULL,	   NULL,     @IdCountry, @IdAccountHours, @IdAccountSales)

		
END
GO

--Drops the Procedure bgtInsertInitialBudgetOtherCost if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertInitialBudgetOtherCost]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertInitialBudgetOtherCost
GO

CREATE  PROCEDURE bgtInsertInitialBudgetOtherCost
	@IdProject		INT,		--The Id of detail from master table
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT,
	@IdAssociate		INT,
	@YearMonth		INT,
	@IdCostType		INT		--The Id of other cost type
	
AS
BEGIN
	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end

	DECLARE @IdCountry INT
	DECLARE @CountryName VARCHAR(30)
	DECLARE @CostCenterName VARCHAR(50)
	DECLARE @CountryHasDefaultAccounts BIT

	SELECT 	@IdCountry = C.[Id],
		@CountryName = C.[Name],
		@CostCenterName = CC.[Name]
	FROM 	COST_CENTERS CC
	INNER 	JOIN INERGY_LOCATIONS IL ON
		CC.IdInergyLocation = IL.[Id]
	INNER 	JOIN COUNTRIES C ON
		IL.IdCountry = C.[Id]
	WHERE 	CC.[Id] = @IdCostCenter

	SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)

	IF (@CountryHasDefaultAccounts = 0)
	BEGIN
		RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
		RETURN -2
	END

	DECLARE @IdAccount INT

	--Select the account id for the given cost type
	SELECT 	@IdAccount = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = @IdCostType

	--insert other costs
	INSERT INTO BUDGET_INITIAL_DETAIL_COSTS
			(IdProject,  IdPhase,  IdWorkpackage,IdCostCenter,  IdAssociate,  YearMonth,  IdCostType, CostVal, IdCountry,  IdAccount)
		VALUES  (@IdProject, @IdPhase, @IdWP, 	     @IdCostCenter, @IdAssociate, @YearMonth, @IdCostType, NULL,   @IdCountry, @IdAccount)
END
GO

--Drops the Procedure bgtInsertIntercoCountryLayout if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertIntercoCountryLayout]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertIntercoCountryLayout
GO
CREATE PROCEDURE bgtInsertIntercoCountryLayout
	@IdProject INT,
	@IdCountry INT,
	@Position INT
AS
	IF NOT EXISTS
	(
		SELECT 	IdProject
		FROM 	PROJECTS_INTERCO_LAYOUT
		WHERE 	IdProject = @IdProject AND
			IdCountry = @IdCountry
	)
	BEGIN
		INSERT INTO PROJECTS_INTERCO_LAYOUT 
			(IdProject, IdCountry, Position)
		VALUES	(@IdProject, @IdCountry, @Position)
	END
	ELSE
	BEGIN
		UPDATE 	PROJECTS_INTERCO_LAYOUT
		SET 	Position = @Position
		WHERE 	IdProject = @IdProject AND
			IdCountry = @IdCountry
	END
GO

--Drops the Procedure bgtInsertProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertProjectCoreTeam]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertProjectCoreTeam
GO
CREATE PROCEDURE bgtInsertProjectCoreTeam
	@IdProject		INT,		--The Id of the Project that is connected to the Project Core Team you want to insert
	@IdAssociate		INT,		--The Id of the Associate that is connected to the Project Core Team you want to insert
	@IdFunction		INT,		--The Id of the Function that is connected to the Project Core Team you want to insert
	@IsActive		BIT
AS
DECLARE @ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(40)
	

	IF EXISTS(SELECT *
			  FROM PROJECT_CORE_TEAMS PCT(TABLOCKX)
			  WHERE	PCT.IdAssociate	= @IdAssociate AND 
					PCT.IdProject = @IdProject) 
	BEGIN
		SET @ErrorMessage = 'The associate you want to add is already defined in the core team.'
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdProject IS NULL OR 
	   @IdAssociate IS NULL OR 
	   @IdFunction IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	INSERT INTO PROJECT_CORE_TEAMS 	( IdProject, IdAssociate, IdFunction,IsActive,LastUpdate)
	VALUES		       		(@IdProject,@IdAssociate,@IdFunction,@IsActive,GETDATE())
	

GO



--Drops the Procedure bgtInsertRevisedBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertRevisedBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertRevisedBudget
GO

CREATE  PROCEDURE bgtInsertRevisedBudget
	@IdProject	INT,		--The Id of the selected Project
	@IdAssociate	INT		--The Id of the associate
	
AS
BEGIN
	DECLARE @CurrentGeneration INT
	DECLARE @NewGeneration INT
	--Find Released and InProgress generations of revised budget for the current project
	SELECT @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')
	SELECT @NewGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	IF (@NewGeneration is null)
	BEGIN
		set @NewGeneration = @CurrentGeneration + 1

		DECLARE @RetVal INT
		
		EXEC @RetVal = bgtRevisedBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -1
	END

END
GO

--Drops the Procedure bgtInsertRevisedBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertRevisedBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertRevisedBudgetDetail
GO

CREATE  PROCEDURE bgtInsertRevisedBudgetDetail
	@IdProject	INT,		--The Id of the selected Project
	@IdPhase	INT,		--The Id of a phase from project
	@IdWP		INT,		--The Id of workpackage
	@IdCostCenter	INT,		--The Id of cost center
	@IdAssociate	INT,		--The Id of associate
	@YearMonth	INT
AS
BEGIN
	DECLARE	@CostCenterName 	VARCHAR(50),
		@WPName			VARCHAR(50),
		@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	SELECT @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	FROM fnValidateYearMonth(@YearMonth)

	IF (@YMValidationResult < 0)
	BEGIN
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	DECLARE @IdGeneration INT
	--Find a generation of a revised budget for the current project that is not validated (InProgress version of budget)
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	SET @CostCenterName = NULL
	SELECT 
		@CostCenterName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code], --CC.[Name]
		@WPName = WP.Code + '-' + WP.[Name]
	FROM BUDGET_REVISED_DETAIL AS BRD (TABLOCKX)
	INNER JOIN COST_CENTERS AS CC ON
		CC.[Id] = @IdCostCenter
	INNER JOIN DEPARTMENTS AS DP ON
		DP.[Id] = CC.IdDepartment
	INNER JOIN INERGY_LOCATIONS AS IL ON
		IL.[Id] = CC.IdInergyLocation
	INNER JOIN WORK_PACKAGES AS WP ON
		WP.IdProject = @IdProject AND
		WP.IdPhase = @IdPhase AND
		WP.[Id] = @IdWP
	WHERE 	
		BRD.[IdCostCenter] = @IdCostCenter AND
		BRD.IdProject = @IdProject AND
		BRD.IdPhase = @IdPhase AND
		BRD.IdWorkPackage = @IdWP AND 
		BRD.YearMonth = @YearMonth AND
		BRD.IdAssociate = @IdAssociate AND
		BRD.IdGeneration = @IdGeneration


	IF (@CostCenterName IS NOT NULL)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DUPLICATE_COST_CENTER_1',@IdLanguage = 1, @Parameter1 = @CostCenterName, @Parameter2 = @WPName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END

	DECLARE @IdCountry INT
	DECLARE @CountryName VARCHAR(30)
	DECLARE @CountryHasDefaultAccounts BIT

	SELECT 	@IdCountry = C.[Id],
		@CountryName = C.[Name],
		@CostCenterName = CC.[Name]
	FROM 	COST_CENTERS CC
	INNER 	JOIN INERGY_LOCATIONS IL ON
		CC.IdInergyLocation = IL.[Id]
	INNER 	JOIN COUNTRIES C ON
		IL.IdCountry = C.[Id]
	WHERE 	CC.[Id] = @IdCostCenter

	SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)

	IF (@CountryHasDefaultAccounts = 0)
	BEGIN
		RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
		RETURN -3
	END

	DECLARE @IdAccountHours INT
	DECLARE @IdAccountSales INT

	--Select the account id for hours
	SELECT 	@IdAccountHours = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 6

	--Select the account id for sales
	SELECT 	@IdAccountSales = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 7
	
	
	--insert budget initial detail
	INSERT INTO BUDGET_REVISED_DETAIL
		(IdProject, IdGeneration,  IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth,  HoursQty,  HoursVal, SalesVal, IdCountry,  IdAccountHours,  IdAccountSales)
	VALUES  (@IdProject,@IdGeneration, @IdPhase, @IdWP,	    @IdCostCenter, @IdAssociate, @YearMonth, NULL, 	NULL,	  NULL,	    @IdCountry, @IdAccountHours, @IdAccountSales)
END
GO

--Drops the Procedure bgtInsertRevisedBudgetOtherCost if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertRevisedBudgetOtherCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertRevisedBudgetOtherCosts
GO

CREATE  PROCEDURE bgtInsertRevisedBudgetOtherCosts
	@IdProject		INT,		--The Id of project
	@IdPhase		INT,		--The Id of phase
	@IdWP			INT,		--The Id of workpackage
	@IdCostCenter		INT,		--The Id of cost center
	@IdAssociate		INT,		--The Id of associate
	@YearMonth		INT,		--Year and month
	@IdCostType		INT
AS
BEGIN
	Declare	@ErrorMessage		VARCHAR(255),
			@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end

	DECLARE @IdGeneration INT
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	IF (@IdGeneration IS NULL)
	BEGIN
		RAISERROR('No new budget version found for Revised Budget', 16, 1)
		RETURN -2
	END

	DECLARE @IdCountry INT
	DECLARE @CountryName VARCHAR(30)
	DECLARE @CostCenterName VARCHAR(50)
	DECLARE @CountryHasDefaultAccounts BIT

	SELECT 	@IdCountry = C.[Id],
		@CountryName = C.[Name],
		@CostCenterName = CC.[Name]
	FROM 	COST_CENTERS CC
	INNER 	JOIN INERGY_LOCATIONS IL ON
		CC.IdInergyLocation = IL.[Id]
	INNER 	JOIN COUNTRIES C ON
		IL.IdCountry = C.[Id]
	WHERE 	CC.[Id] = @IdCostCenter

	SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)

	IF (@CountryHasDefaultAccounts = 0)
	BEGIN
		RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
		RETURN -3
	END

	DECLARE @IdAccount INT

	--Select the account id for the given cost type
	SELECT 	@IdAccount = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = @IdCostType
	
	--insert other costs
	INSERT INTO BUDGET_REVISED_DETAIL_COSTS
		(IdProject,  IdGeneration,  IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth,  IdCostType,  CostVal, IdCountry,  IdAccount)
	VALUES  (@IdProject, @IdGeneration, @IdPhase, @IdWP, 	     @IdCostCenter, @IdAssociate, @YearMonth, @IdCostType, NULL,    @IdCountry, @IdAccount)
	
END
GO


--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtInsertToCompletionBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtInsertToCompletionBudget
GO

CREATE  PROCEDURE bgtInsertToCompletionBudget
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT
AS
	--Get the new generation Id
	DECLARE @NewGeneration		INT
	DECLARE @CurrentGeneration	INT
	DECLARE @RevisedGenerationNo 	INT

	DECLARE @RetVal INT
	
	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'N')
	SET @RevisedGenerationNo = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')

	IF (@NewGeneration IS NULL)
	BEGIN
		SET @CurrentGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'C')
		IF (@CurrentGeneration IS NULL)
		BEGIN
			RAISERROR('No released generation found for To Completion budget', 16, 1)
			RETURN -1
		END
		SET @NewGeneration = @CurrentGeneration + 1
		
		EXEC @RetVal = bgtToCompletionBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -2
	END


	IF (EXISTS 
	(SELECT IdProject FROM BUDGET_TOCOMPLETION_DETAIL AS BTD
	 WHERE 	BTD.IdProject = @IdProject AND
		BTD.IdGeneration = @NewGeneration AND
		BTD.IdPhase = @IdPhase AND
		BTD.IdWorkPackage = @IdWP AND
		BTD.IdCostCenter = @IdCostCenter AND
		BTD.IdAssociate = @IdAssociate
	)	
	OR 
	EXISTS
	(
	SELECT 	IdProject FROM BUDGET_REVISED_DETAIL AS BRD
	WHERE 	BRD.IdProject = @IdProject AND
		BRD.IdGeneration = @RevisedGenerationNo AND
		BRD.IdPhase = @IdPhase AND
		BRD.IdWorkPackage = @IdWP AND
		BRD.IdCostCenter = @IdCostCenter AND
		BRD.IdAssociate = @IdAssociate
	)
	OR
	EXISTS
	(
	SELECT 	IdProject FROM ACTUAL_DATA_DETAILS_HOURS AS AD
	WHERE 	AD.IdProject = @IdProject AND
		AD.IdPhase = @IdPhase AND
		AD.IdWorkPackage = @IdWP AND
		AD.IdCostCenter = @IdCostCenter
	)
	OR
	EXISTS
	(
	SELECT 	IdProject FROM ACTUAL_DATA_DETAILS_SALES AS AD
	WHERE 	AD.IdProject = @IdProject AND
		AD.IdPhase = @IdPhase AND
		AD.IdWorkPackage = @IdWP AND
		AD.IdCostCenter = @IdCostCenter
	)
	OR
	EXISTS
	(
	SELECT 	IdProject FROM ACTUAL_DATA_DETAILS_COSTS AS AD
	WHERE 	AD.IdProject = @IdProject AND
		AD.IdPhase = @IdPhase AND
		AD.IdWorkPackage = @IdWP AND
		AD.IdCostCenter = @IdCostCenter
	)
	)
	BEGIN
		DECLARE @CCName VARCHAR(50)
		DECLARE @WPName VARCHAR(50)
		DECLARE @ErrorMessage	VARCHAR(255)
		SELECT 	@CCName = DP.[Name]+'-'+IL.Code+'-'+CC.[Code],
			@WPName = WP.Code + '-' + WP.[Name]
		FROM	COST_CENTERS AS CC
		INNER 	JOIN DEPARTMENTS AS DP 
		ON	CC.IdDepartment = DP.[Id]
		INNER 	JOIN INERGY_LOCATIONS AS IL
		ON 	CC.IdInergyLocation = IL.[Id]
		INNER 	JOIN WORK_PACKAGES AS WP ON
			WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.[Id] = @IdWP
		WHERE 	CC.[Id] = @IdCostCenter
		

		--RAISERROR('Cost Center %s is already added.', 16, 1, @CCName)

		EXEC   auxSelectErrorMessage_2 @Code = 'DUPLICATE_COST_CENTER_1', @IdLanguage = 1, @Parameter1 = @CCName, @Parameter2 = @WPName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3
	END 


	DECLARE @IdCountry INT
	DECLARE @CountryName VARCHAR(30)
	DECLARE @CostCenterName VARCHAR(50)
	DECLARE @CountryHasDefaultAccounts BIT

	SELECT 	@IdCountry = C.[Id],
		@CountryName = C.[Name],
		@CostCenterName = CC.[Name]
	FROM 	COST_CENTERS CC
	INNER 	JOIN INERGY_LOCATIONS IL ON
		CC.IdInergyLocation = IL.[Id]
	INNER 	JOIN COUNTRIES C ON
		IL.IdCountry = C.[Id]
	WHERE 	CC.[Id] = @IdCostCenter

	SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)

	IF (@CountryHasDefaultAccounts = 0)
	BEGIN
		RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
		RETURN -4
	END

	DECLARE @IdAccountHours INT
	DECLARE @IdAccountSales INT

	--Select the account id for hours
	SELECT 	@IdAccountHours = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 6

	--Select the account id for sales
	SELECT 	@IdAccountSales = GLA.[Id]
	FROM 	GL_ACCOUNTS GLA
	INNER JOIN COST_INCOME_TYPES CIT ON
	GLA.Account = CIT.DefaultAccount
	WHERE	GLA.IdCountry = @IdCountry AND
		CIT.[Id] = 7
		


	IF NOT EXISTS
	(
		SELECT 	IdProject
		FROM 	BUDGET_TOCOMPLETION_PROGRESS
		WHERE	IdProject = @IdProject AND
			IdGeneration = @NewGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdAssociate = @IdAssociate
	)
	BEGIN
		INSERT INTO BUDGET_TOCOMPLETION_PROGRESS 
			(IdProject,   IdGeneration,   IdPhase,  IdWorkPackage,   IdAssociate,  [Percent])
		VALUES (@IdProject,   @NewGeneration, @IdPhase, @IdWP         ,  @IdAssociate, 0)
	END

	DECLARE @StartYear INT
	DECLARE @StartMonth INT
	DECLARE @EndYear INT
	DECLARE @EndMonth INT

	SELECT 	@StartYear = StartYearMonth / 100,
		@StartMonth = StartYearMonth % 100,
		@EndYear = EndYearMonth / 100,
		@EndMonth = EndYearMonth % 100
	FROM 	WORK_PACKAGES AS WP
	WHERE 	WP.IdProject = @IdProject AND
		WP.IdPhase = @IdPhase AND
		WP.[Id] = @IdWP
	
	WHILE ((@StartYear < @EndYear) OR (@StartYear = @EndYear AND @StartMonth <= @EndMonth))
	BEGIN
		DECLARE @Date INT
		SET @Date = @StartYear * 100 + @StartMonth
		
		INSERT INTO BUDGET_TOCOMPLETION_DETAIL
			(IdProject, IdGeneration,   IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth, HoursQty,  HoursVal, SalesVal, IdCountry,  IdAccountHours,  IdAccountSales)
		VALUES (@IdProject, @NewGeneration, @IdPhase, @IdWP, 	     @IdCostCenter, @IdAssociate, @Date,     NULL,	NULL, 	  NULL,	    @IdCountry, @IdAccountHours, @IdAccountSales)

		DECLARE @CostType INT
		SET @CostType = 1
	
		WHILE (@CostType <= 5)
		BEGIN
			DECLARE @IdAccount INT

			--Select the account id for the given cost type
			SELECT 	@IdAccount = GLA.[Id]
			FROM 	GL_ACCOUNTS GLA
			INNER JOIN COST_INCOME_TYPES CIT ON
			GLA.Account = CIT.DefaultAccount
			WHERE	GLA.IdCountry = @IdCountry AND
				CIT.[Id] = @CostType
			
			INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS
				(IdProject,  IdGeneration,   IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth,   IdCostType, CostVal, IdCountry,  IdAccount)
			VALUES	(@IdProject, @NewGeneration, @IdPhase, @IdWP, 	      @IdCostCenter, @IdAssociate, @Date,	@CostType,  NULL,    @IdCountry, @IdAccount)
			SET @CostType = @CostType + 1
		END

		IF(@StartMonth = 12)
		BEGIN
			SET @StartYear = @StartYear + 1
			SET @StartMonth = 1
		END
		ELSE
		BEGIN
			SET @StartMonth = @StartMonth + 1
		END
		
	END
	
GO

--Drops the Procedure bgtIsAssociatePMOnProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtIsAssociatePMOnProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtIsAssociatePMOnProject
GO

CREATE PROCEDURE bgtIsAssociatePMOnProject
	@IdProject 		AS INT,
	@IdAssociate       	AS INT		
AS	

SELECT dbo.fnIsAssociatePMOnProject(@IdProject, @IdAssociate) AS 'IsAssociatePMOnProject' 

GO


--Drops the Procedure bgtIsLastRevisedVersionOpen if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtIsLastRevisedVersionOpen]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtIsLastRevisedVersionOpen
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE proc [dbo].[bgtIsLastRevisedVersionOpen]
@IdProject int

as

declare @IdVersion int

SELECT @IdVersion = MAX(IdGeneration) 
FROM BUDGET_REVISED TABLOCKX
WHERE 	IdProject = @IdProject

declare @rez int = 0

if exists (select * from BUDGET_REVISED_STATES
			where IdProject = @IdProject
			and IdGeneration = @IdVersion
			and State = 'O'
			)
	set @rez = 1

return @rez

GO

--Drops the Procedure bgtIsLastToCompletionVersionOpen if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtIsLastToCompletionVersionOpen]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtIsLastToCompletionVersionOpen
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

create proc [dbo].[bgtIsLastToCompletionVersionOpen]
@IdProject int

as

declare @IdVersion int

SELECT @IdVersion = MAX(IdGeneration) 
FROM BUDGET_TOCOMPLETION TABLOCKX
WHERE 	IdProject = @IdProject

declare @rez int = 0

if exists (select * from BUDGET_TOCOMPLETION_STATES
			where IdProject = @IdProject
			and IdGeneration = @IdVersion
			and State = 'O'
			)
	set @rez = 1

return @rez

GO


--Drops the Procedure bgtMoveRevisedBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtMoveRevisedBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtMoveRevisedBudget
GO

CREATE  PROCEDURE [dbo].[bgtMoveRevisedBudget]
	@IdProject			INT,
	@IdAssociateLM			INT, -- LM: member that leaves the project
	@IdAssociateNM			INT,  -- NM: new member, that takes over the budget from LM
	@IdAssociateMovingBudget		INT  -- the member that moves the budget from LM (leaving member) to NM (new member)
AS


CREATE TABLE #RevisedVersionNo (BudgetVersion int, IsVersionActual int)
INSERT INTO #RevisedVersionNo
	EXEC bgtGetRevisedVersionNo @IdProject, @Version = N'N'

DECLARE @IdGeneration int
SELECT @IdGeneration = BudgetVersion
FROM #RevisedVersionNo

declare @NewAssociateReturns bit
set @NewAssociateReturns = 0

if exists(select Id from BUDGET_REVISED_MOVE_OPERATIONS
				where IdProject = @IdProject 
				and IdAssociateFrom = @IdAssociateNM
	   )
begin
 set @NewAssociateReturns = 1
end

-- commented on November 2017. The customer wanted to delete data that belongs to new member
--IF EXISTS
--(
--	SELECT * 
--	FROM
--	(
--		SELECT *
--		FROM BUDGET_REVISED_DETAIL
--		WHERE IdProject = @IdProject
--		AND IdGeneration = @IdGeneration
--		AND IdAssociate = @IdAssociateLM
--	) t
--	INNER JOIN
--	(
--		SELECT *
--		FROM BUDGET_REVISED_DETAIL
--		WHERE IdProject = @IdProject
--		AND IdGeneration = @IdGeneration
--		AND IdAssociate = @IdAssociateNM
--	) t1
--	ON  t.IdProject = t1.IdProject
--	AND t.IdGeneration = t1.IdGeneration
--	AND t.IdPhase = t1.IdPhase
--	AND t.IdWorkPackage = t1.IdWorkPackage
--	AND t.IdCostCenter = t1.IdCostCenter
--	AND t.YearMonth = t1.YearMonth
--	AND case when @NewAssociateReturns = 1 then t1.HoursQty else 1 end <> 0
--	  -- In case New Associate returns ignore the fact that he/she has data with 0 values
--	  -- which have been set when he/she left team
--)
--OR EXISTS
--(
--	SELECT * 
--	FROM
--	(
--		SELECT *
--		FROM BUDGET_REVISED_DETAIL_COSTS
--		WHERE IdProject = @IdProject
--		AND IdGeneration = @IdGeneration
--		AND IdAssociate = @IdAssociateLM
--	) t
--	INNER JOIN
--	(
--		SELECT *
--		FROM BUDGET_REVISED_DETAIL_COSTS
--		WHERE IdProject = @IdProject
--		AND IdGeneration = @IdGeneration
--		AND IdAssociate = @IdAssociateNM
--	) t1
--	ON  t.IdProject = t1.IdProject
--	AND t.IdGeneration = t1.IdGeneration
--	AND t.IdPhase = t1.IdPhase
--	AND t.IdWorkPackage = t1.IdWorkPackage
--	AND t.IdCostCenter = t1.IdCostCenter
--	AND t.YearMonth = t1.YearMonth
--	AND t.IdCostType = t1.IdCostType
--	AND case when @NewAssociateReturns = 1 then t1.CostVal else 1 end <> 0
--	  -- In case New Associate returns ignore the fact that he/she has data with 0 values
--	  -- which have been set when he/she left team

--)
--BEGIN
--	RAISERROR('Error: Duplicated items found in source and destination', 16, 1)
--	RETURN -1
--END

if(
	(SELECT count(*)
	 FROM BUDGET_REVISED_DETAIL
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM)
	
	+
	(SELECT count(*)
	 FROM BUDGET_REVISED_DETAIL_COSTS
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM) = 0)
BEGIN	
	RAISERROR('There is no data to transfer', 16, 1)
	RETURN -2
END



	delete BUDGET_REVISED_DETAIL_COSTS
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM


	delete BUDGET_REVISED_DETAIL
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM

/*
-- commented on November 2017
if @NewAssociateReturns = 1
   begin
-- in this case delete data with IdGeneration = @IdGeneration if ALL records have value = 0
-- because these records have been inserted when NewAssociate left the team
	if 0 = ALL (
			select HoursQty
			from BUDGET_REVISED_DETAIL
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
			)
	AND
	  0 = ALL (
			select CostVal
			from BUDGET_REVISED_DETAIL_COSTS
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
			)
	   begin
			delete BUDGET_REVISED_DETAIL_COSTS
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM

			delete BUDGET_REVISED_DETAIL
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
	   end
   end
*/

-- insert data for the new member
INSERT INTO BUDGET_REVISED_DETAIL
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales
FROM BUDGET_REVISED_DETAIL
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

INSERT INTO BUDGET_REVISED_DETAIL_COSTS
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, IdCostType, CostVal, IdCountry, IdAccount
FROM BUDGET_REVISED_DETAIL_COSTS
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM
  
-- insert data into the logs table
INSERT INTO BUDGET_REVISED_MOVE_OPERATIONS
	VALUES(@IdProject, @IdGeneration, GETDATE(), @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget)

	-- set to 0 old member data
update BUDGET_REVISED_DETAIL_COSTS
set CostVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

update BUDGET_REVISED_DETAIL
set HoursQty = 0, HoursVal = 0, SalesVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

declare @State_AssociateLM varchar(1)

select @State_AssociateLM = [State] from BUDGET_REVISED_STATES
	WHERE IdProject = @IdProject 
		AND IdGeneration = @IdGeneration 
		AND IdAssociate = @IdAssociateLM 

select @State_AssociateLM = isnull(@State_AssociateLM,'N')
  
update BUDGET_REVISED_STATES
set [State] = 'N'
WHERE IdProject = @IdProject 
  AND IdGeneration = @IdGeneration 
  AND IdAssociate = @IdAssociateLM  



if exists(select * from BUDGET_REVISED_STATES
						WHERE IdProject = @IdProject 
						AND IdGeneration = @IdGeneration 
						AND IdAssociate = @IdAssociateNM)
   
   update BUDGET_REVISED_STATES
	set [State] = @State_AssociateLM
	WHERE IdProject = @IdProject 
	AND IdGeneration = @IdGeneration 
	AND IdAssociate = @IdAssociateNM
else
	insert into  BUDGET_REVISED_STATES
	(IdProject, IdGeneration, IdAssociate, [State], StateDate)
	select @IdProject, @IdGeneration, @IdAssociateNM, @State_AssociateLM, getdate()

go

--Drops the Procedure bgtMoveRevisedBudgetReleasedVersion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtMoveRevisedBudgetReleasedVersion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtMoveRevisedBudgetReleasedVersion
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE  PROCEDURE [dbo].[bgtMoveRevisedBudgetReleasedVersion]
	@IdProject			INT,
	@IdAssociateLM			INT, -- LM: member that leaves the project
	@IdAssociateNM			INT,  -- NM: new member, that takes over the budget from LM
	@IdAssociateMovingBudget		INT,  -- the member that moves the budget from LM (leaving member) to NM (new member)
	@ExecuteMoveReforecastBudget int = 1 -- if = 1 Reforecast budget will be moved too
AS


DECLARE @IdGeneration int

SELECT @IdGeneration = MAX(IdGeneration) 
FROM BUDGET_REVISED TABLOCKX
WHERE 	IdProject = @IdProject AND IsValidated = 1

if(
	(SELECT count(*)
	 FROM BUDGET_REVISED_DETAIL
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM)
	
	+
	(SELECT count(*)
	 FROM BUDGET_REVISED_DETAIL_COSTS
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM) = 0)
BEGIN	
	RAISERROR('There is no data to transfer', 16, 1)
	RETURN -2
END

-- delete any existing revised data for this generation

	delete BUDGET_REVISED_DETAIL_COSTS
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM


	delete BUDGET_REVISED_DETAIL
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM


-- insert data for the new member
INSERT INTO BUDGET_REVISED_DETAIL
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales
FROM BUDGET_REVISED_DETAIL
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

INSERT INTO BUDGET_REVISED_DETAIL_COSTS
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, IdCostType, CostVal, IdCountry, IdAccount
FROM BUDGET_REVISED_DETAIL_COSTS
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM
  
-- insert data into the logs table
INSERT INTO BUDGET_REVISED_MOVE_OPERATIONS
	VALUES(@IdProject, @IdGeneration, GETDATE(), @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget)

	-- set to 0 old member data
update BUDGET_REVISED_DETAIL_COSTS
set CostVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

update BUDGET_REVISED_DETAIL
set HoursQty = 0, HoursVal = 0, SalesVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

  
update BUDGET_REVISED_STATES
set [State] = 'N'
WHERE IdProject = @IdProject 
  AND IdGeneration = @IdGeneration 
  AND IdAssociate = @IdAssociateLM  



if exists(select * from BUDGET_REVISED_STATES
						WHERE IdProject = @IdProject 
						AND IdGeneration = @IdGeneration 
						AND IdAssociate = @IdAssociateNM)
   
   update BUDGET_REVISED_STATES
	set [State] = 'V'
	WHERE IdProject = @IdProject 
	AND IdGeneration = @IdGeneration 
	AND IdAssociate = @IdAssociateNM
else
	insert into  BUDGET_REVISED_STATES
	(IdProject, IdGeneration, IdAssociate, [State], StateDate)
	select @IdProject, @IdGeneration, @IdAssociateNM, 'V', getdate()

if @ExecuteMoveReforecastBudget = 1 
   begin
		declare @ReforecastIsReleasedTable table (ReforecastReleased int)

		insert into @ReforecastIsReleasedTable
		exec [bgtGetLastValidatedReforecastVersion] @IdProject

		if (select ReforecastReleased from @ReforecastIsReleasedTable)  > 0
		  begin
			-- Reforecast has Released version
			exec [bgtMoveToCompletionBudgetReleasedVersion] @IdProject, @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget, 0
		  end
		else
		   begin
			 declare @IdVersionProgress int
			-- check if status is in Progress
				select @IdVersionProgress = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'N')
				if @IdVersionProgress is not null
				  -- it exists an InProgressVersion, we call "normal" move budget
				    begin
						exec bgtMoveToCompletionBudget @IdProject, @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget
					end
		   end

   end

go
--Drops the Procedure bgtMoveToCompletionBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtMoveToCompletionBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtMoveToCompletionBudget
GO

CREATE  PROCEDURE [dbo].[bgtMoveToCompletionBudget]
	@IdProject		INT,
	@IdAssociateLM		INT, -- LM: member that leaves the project
	@IdAssociateNM		INT,  -- NM: new member, that takes over the budget from LM
	@IdAssociateMovingBudget		INT  -- the member that moves the budget from LM (leaving member) to NM (new member)
AS



CREATE TABLE #ReforecastVersionNo (BudgetVersion int, IsVersionActual int)
INSERT INTO #ReforecastVersionNo
	EXEC bgtGetReforecastVersionNo @IdProject, @Version = N'N'

DECLARE @IdGeneration int
SELECT @IdGeneration = BudgetVersion
FROM #ReforecastVersionNo

declare @NewAssociateReturns bit
set @NewAssociateReturns = 0

 if exists(select Id from BUDGET_TOCOMPLETION_MOVE_OPERATIONS
					where IdProject = @IdProject 
					and IdAssociateFrom = @IdAssociateNM
		   )
   begin
	 set @NewAssociateReturns = 1
   end

/*
-- commented on November 2017. The customer wanted to delete data that belongs to new member
IF EXISTS
(
	SELECT * 
	FROM
	(
		SELECT *
		FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE IdProject = @IdProject
		  AND IdGeneration = @IdGeneration
		  AND IdAssociate = @IdAssociateLM
	) t
	INNER JOIN
	(
		SELECT *
		FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE IdProject = @IdProject
		  AND IdGeneration = @IdGeneration
		  AND IdAssociate = @IdAssociateNM

	) t1
	ON  t.IdProject = t1.IdProject
	AND t.IdGeneration = t1.IdGeneration
	AND t.IdPhase = t1.IdPhase
	AND t.IdWorkPackage = t1.IdWorkPackage
	AND t.IdCostCenter = t1.IdCostCenter
	AND t.YearMonth = t1.YearMonth
	AND case when @NewAssociateReturns = 1 then t1.HoursQty else 1 end <> 0
	  -- In case New Associate returns ignore the fact that he/she has data with 0 values
	  -- which have been set when he/she left team
)
OR EXISTS
(
	SELECT * 
	FROM
	(
		SELECT *
		FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
		WHERE IdProject = @IdProject
		  AND IdGeneration = @IdGeneration
		  AND IdAssociate = @IdAssociateLM
	) t
	INNER JOIN
	(
		SELECT *
		FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
		WHERE IdProject = @IdProject
		  AND IdGeneration = @IdGeneration
		  AND IdAssociate = @IdAssociateNM
	) t1
	ON  t.IdProject = t1.IdProject
	AND t.IdGeneration = t1.IdGeneration
	AND t.IdPhase = t1.IdPhase
	AND t.IdWorkPackage = t1.IdWorkPackage
	AND t.IdCostCenter = t1.IdCostCenter
	AND t.YearMonth = t1.YearMonth
	AND t.IdCostType = t1.IdCostType
	AND case when @NewAssociateReturns = 1 then t1.CostVal else 1 end <> 0
	  -- In case New Associate returns ignore the fact that he/she has data with 0 values
	  -- which have been set when he/she left team
)
BEGIN
	RAISERROR('Error: Duplicated items found in source and destination', 16, 1)
	RETURN -1
END
*/


if(
	(SELECT count(*)
	 FROM BUDGET_TOCOMPLETION_DETAIL
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM)
	
	+
	(SELECT count(*)
	 FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM) = 0)
BEGIN	
	RAISERROR('There is no data to transfer', 16, 1)
	RETURN -2
END

	delete BUDGET_TOCOMPLETION_DETAIL_COSTS
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM


	delete BUDGET_TOCOMPLETION_DETAIL
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM

/*
-- commented on November 2017
if @NewAssociateReturns = 1
   begin
-- in this case delete data with IdGeneration = @IdGeneration if ALL records have value = 0
-- because these records have been inserted when NewAssociate left the team
	if 0 = ALL (
			select HoursQty
			from BUDGET_TOCOMPLETION_DETAIL
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
			)
	AND
	  0 = ALL (
			select CostVal
			from BUDGET_TOCOMPLETION_DETAIL_COSTS
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
			)
	   begin
			delete BUDGET_TOCOMPLETION_DETAIL_COSTS
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM

			delete BUDGET_TOCOMPLETION_DETAIL
			where IdProject = @IdProject
			and IdGeneration = @IdGeneration
			and IdAssociate = @IdAssociateNM
	   end
   end
*/
-- insert data for the new member
INSERT INTO BUDGET_TOCOMPLETION_PROGRESS 
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdAssociate, [Percent])
SELECT t.IdProject, t.IdGeneration, t.IdPhase, t.IdWorkPackage, @IdAssociateNM, t.[Percent]
FROM
(
	SELECT * 
	FROM BUDGET_TOCOMPLETION_PROGRESS
	WHERE IdProject = @IdProject
	  AND IdGeneration = @IdGeneration
	  AND IdAssociate = @IdAssociateLM
) t
LEFT JOIN
(
	SELECT * 
	FROM BUDGET_TOCOMPLETION_PROGRESS
	WHERE IdProject = @IdProject
	  AND IdGeneration = @IdGeneration
	  AND IdAssociate = @IdAssociateNM
) t1
ON t.IdProject = t1.IdProject
AND t.IdGeneration = t1.IdGeneration
AND t.IdPhase = t1.IdPhase
AND t.IdWorkPackage = t1.IdWorkPackage
WHERE t1.IdProject IS NULL
  AND t1.IdGeneration IS NULL
  AND t1.IdPhase IS NULL
  AND t1.IdWorkPackage IS NULL


INSERT INTO BUDGET_TOCOMPLETION_DETAIL
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales
FROM BUDGET_TOCOMPLETION_DETAIL
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM


INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, IdCostType, CostVal, IdCountry, IdAccount
FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

--insert data into the logs table
INSERT INTO BUDGET_TOCOMPLETION_MOVE_OPERATIONS
	VALUES(@IdProject, @IdGeneration, GETDATE(), @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget)

-- set to 0 old member data
update BUDGET_TOCOMPLETION_DETAIL_COSTS
set CostVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM
  
update BUDGET_TOCOMPLETION_DETAIL
set HoursQty = 0, HoursVal = 0, SalesVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM
  
update BUDGET_TOCOMPLETION_PROGRESS
set [Percent] = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM  

declare @State_AssociateLM varchar(1)

select @State_AssociateLM = [State] from BUDGET_TOCOMPLETION_STATES
	WHERE IdProject = @IdProject 
		AND IdGeneration = @IdGeneration 
		AND IdAssociate = @IdAssociateLM 

select @State_AssociateLM = isnull(@State_AssociateLM,'N')

update BUDGET_TOCOMPLETION_STATES
set [State] = 'N'
WHERE IdProject = @IdProject 
  AND IdGeneration = @IdGeneration 
  AND IdAssociate = @IdAssociateLM	


if exists(select * from BUDGET_TOCOMPLETION_STATES
						WHERE IdProject = @IdProject 
						AND IdGeneration = @IdGeneration 
						AND IdAssociate = @IdAssociateNM)
   
   update BUDGET_TOCOMPLETION_STATES
	set [State] = @State_AssociateLM
	WHERE IdProject = @IdProject 
	AND IdGeneration = @IdGeneration 
	AND IdAssociate = @IdAssociateNM
else
	insert into  BUDGET_TOCOMPLETION_STATES
	(IdProject, IdGeneration, IdAssociate, [State], StateDate)
	select @IdProject, @IdGeneration, @IdAssociateNM, @State_AssociateLM, getdate()

go--Drops the Procedure bgtMoveToCompletionBudgetReleasedVersion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtMoveToCompletionBudgetReleasedVersion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtMoveToCompletionBudgetReleasedVersion
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE  PROCEDURE [dbo].[bgtMoveToCompletionBudgetReleasedVersion]
	@IdProject		INT,
	@IdAssociateLM		INT, -- LM: member that leaves the project
	@IdAssociateNM		INT,  -- NM: new member, that takes over the budget from LM
	@IdAssociateMovingBudget		INT,  -- the member that moves the budget from LM (leaving member) to NM (new member)
	@ExecuteMoveRevisedBudget int = 1 -- if =1, RevisedBudget is moved too
AS

DECLARE @IdGeneration int

SELECT @IdGeneration = MAX(IdGeneration) 
FROM BUDGET_TOCOMPLETION TABLOCKX
WHERE 	IdProject = @IdProject AND IsValidated = 1


if(
	(SELECT count(*)
	 FROM BUDGET_TOCOMPLETION_DETAIL
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM)
	
	+
	(SELECT count(*)
	 FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
	 WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateLM) = 0)
BEGIN	
	RAISERROR('There is no data to transfer', 16, 1)
	RETURN -2
END

-- delete any existing reforecast data for this generation
	delete BUDGET_TOCOMPLETION_DETAIL_COSTS
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM


	delete BUDGET_TOCOMPLETION_DETAIL
	where IdProject = @IdProject
	and IdGeneration = @IdGeneration
	and IdAssociate = @IdAssociateNM

	delete BUDGET_TOCOMPLETION_PROGRESS
	WHERE IdProject = @IdProject
		AND IdGeneration = @IdGeneration
		AND IdAssociate = @IdAssociateNM

-- insert data for the new member

INSERT INTO BUDGET_TOCOMPLETION_PROGRESS 
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdAssociate, [Percent])
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, @IdAssociateNM, [Percent]
FROM BUDGET_TOCOMPLETION_PROGRESS
WHERE IdProject = @IdProject
	AND IdGeneration = @IdGeneration
	AND IdAssociate = @IdAssociateLM

update BUDGET_TOCOMPLETION_PROGRESS
set [Percent] = 0
WHERE IdProject = @IdProject
	AND IdGeneration = @IdGeneration
	AND IdAssociate = @IdAssociateLM  

INSERT INTO BUDGET_TOCOMPLETION_DETAIL
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales
FROM BUDGET_TOCOMPLETION_DETAIL
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM


INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, @IdAssociateNM, YearMonth, IdCostType, CostVal, IdCountry, IdAccount
FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM

-- set 0 to the values for the old member
update BUDGET_TOCOMPLETION_DETAIL
set HoursQty = 0, HoursVal = 0, SalesVal = 0
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM


update BUDGET_TOCOMPLETION_DETAIL_COSTS
set CostVal = 0
FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
WHERE IdProject = @IdProject
  AND IdGeneration = @IdGeneration
  AND IdAssociate = @IdAssociateLM


--insert data into the logs table
INSERT INTO BUDGET_TOCOMPLETION_MOVE_OPERATIONS
VALUES(@IdProject, @IdGeneration, GETDATE(), @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget)

declare @State_AssociateLM varchar(1)

select @State_AssociateLM = [State] from BUDGET_TOCOMPLETION_STATES
	WHERE IdProject = @IdProject 
		AND IdGeneration = @IdGeneration 
		AND IdAssociate = @IdAssociateLM 

select @State_AssociateLM = isnull(@State_AssociateLM,'N')

update BUDGET_TOCOMPLETION_STATES
set [State] = 'N'
WHERE IdProject = @IdProject 
  AND IdGeneration = @IdGeneration 
  AND IdAssociate = @IdAssociateLM	


if exists(select * from BUDGET_TOCOMPLETION_STATES
						WHERE IdProject = @IdProject 
						AND IdGeneration = @IdGeneration 
						AND IdAssociate = @IdAssociateNM)
   
   update BUDGET_TOCOMPLETION_STATES
	set [State] = 'V'
	WHERE IdProject = @IdProject 
	AND IdGeneration = @IdGeneration 
	AND IdAssociate = @IdAssociateNM
else
	insert into  BUDGET_TOCOMPLETION_STATES
	(IdProject, IdGeneration, IdAssociate, [State], StateDate)
	select @IdProject, @IdGeneration, @IdAssociateNM, @State_AssociateLM, getdate()


if @ExecuteMoveRevisedBudget = 1 
   begin
		declare @RevisedIsReleasedTable table (RevisedIsReleased int)

		insert into @RevisedIsReleasedTable
		exec [bgtGetLastValidatedRevisedVersion]  @IdProject

		if (select RevisedIsReleased from  @RevisedIsReleasedTable) > 0
		  begin
			-- Revised has Released version
			exec [bgtMoveRevisedBudgetReleasedVersion] @IdProject, @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget, 0
		  end
		else
		   begin
			 declare @IdVersionProgress int
			-- check if status is in Progress
				select @IdVersionProgress = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')
				if @IdVersionProgress is not null
				  -- it exists an InProgressVersion, we call "normal" move budget
				    begin
						exec bgtMoveRevisedBudget @IdProject, @IdAssociateLM, @IdAssociateNM, @IdAssociateMovingBudget
					end
		   end
   end

GO


--Drops the Procedure bgtProjectCoreTeamSelectOpenBudgets if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtProjectCoreTeamSelectOpenBudgets]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtProjectCoreTeamSelectOpenBudgets
GO
CREATE PROCEDURE bgtProjectCoreTeamSelectOpenBudgets
	@IdProject 	AS INT,
	@IdAssociate 	AS INT
AS
	SELECT 	BIS.IdProject AS 'IdProject',
		BIS.IdAssociate AS 'IdAssociate',
		State AS 'BudgetState'
	FROM 	BUDGET_INITIAL_STATES BIS
	WHERE	BIS.IdProject = @IdProject AND
		BIS.IdAssociate = @IdAssociate AND
		BIS.State <> 'V' AND BIS.State <> 'N' AND BIS.State <> 'U'

	UNION

	SELECT 	BRS.IdProject AS 'IdProject',
		BRS.IdAssociate AS 'IdAssociate',
		State AS 'BudgetState'
	FROM 	BUDGET_REVISED_STATES BRS
	WHERE	BRS.IdProject = @IdProject AND
		BRS.IdAssociate = @IdAssociate AND
		BRS.State <> 'V' AND BRS.State <> 'N'

	UNION

	SELECT 	BTS.IdProject AS 'IdProject',
		BTS.IdAssociate AS 'IdAssociate',
		State AS 'BudgetState'
	FROM 	BUDGET_TOCOMPLETION_STATES BTS
	WHERE	BTS.IdProject = @IdProject AND
		BTS.IdAssociate = @IdAssociate AND
		BTS.State <> 'V' AND BTS.State <> 'N'
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtRestoreBudgetToInitialState]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[bgtRestoreBudgetToInitialState]
GO


Create procedure [bgtRestoreBudgetToInitialState]
@IdProject int
as

declare @errMessage varchar(500)

if not exists (select IdProject from BUDGET_INITIAL (nolock) WHERE IdProject = @IdProject and IsValidated = 1)
  return
  

begin tran

--deletes all the information for TOCOMPLETION budget (all generations)
DELETE FROM BUDGET_TOCOMPLETION_DETAIL_COSTS WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_TOCOMPLETION_DETAIL_COSTS for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE FROM BUDGET_TOCOMPLETION_DETAIL WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_TOCOMPLETION_DETAIL for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE FROM BUDGET_TOCOMPLETION_PROGRESS WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_TOCOMPLETION_PROGRESS for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE FROM BUDGET_TOCOMPLETION_STATES WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_TOCOMPLETION_STATES for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE FROM BUDGET_TOCOMPLETION WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_TOCOMPLETION for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end

--deletes all the information for REVISED budget (all generations)
DELETE FROM BUDGET_REVISED_DETAIL_COSTS WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_REVISED_DETAIL_COSTS for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE FROM BUDGET_REVISED_DETAIL WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_REVISED_DETAIL for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE FROM BUDGET_REVISED_STATES WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_REVISED_STATES for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE FROM BUDGET_REVISED WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_REVISED for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be deleted'
	 goto err
  end

--sets the state to 'Waiting for approval' for all initial budget members 
UPDATE BUDGET_INITIAL_STATES SET State='W' WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_INITIAL_STATES for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
	 goto err
  end


UPDATE BUDGET_INITIAL SET IsValidated = 0 WHERE IdProject = @IdProject
if @@error <> 0
  begin
     set @errMessage = 'BUDGET_INITIAL for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
	 goto err
  end
  
	commit
	select 0
	goto retur

err:
	rollback
	raiserror(@errMessage,16,1)
	select -1

retur:
    return


GO

--Drops the Procedure bgtGetRevisedBudgetHours if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtRevisedBudgetCheckForValidatedInitial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtRevisedBudgetCheckForValidatedInitial
GO

CREATE  PROCEDURE bgtRevisedBudgetCheckForValidatedInitial
	@IdProject		INT		--The Id of associate
AS
BEGIN
	IF EXISTS 
	(
		SELECT 	*
		FROM 	BUDGET_INITIAL
		WHERE 	IsValidated = 1
		AND 	IdProject = @IdProject
	)
		RETURN 1
	ELSE
		RETURN 0
END
GO

--Drops the Procedure bgtUpdateRevisedBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtRevisedBudgetCreateNewFromCurrent]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtRevisedBudgetCreateNewFromCurrent
GO

CREATE  PROCEDURE bgtRevisedBudgetCreateNewFromCurrent
	@IdProject 		INT,
	@NewGeneration		INT,
	@IdAssociate		INT
AS
BEGIN
	DECLARE @retVal		INT

	INSERT INTO BUDGET_REVISED_DETAIL (IdProject, IdGeneration, IdPhase, IdWorkPackage,
		IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal,
		IdCountry, IdAccountHours, IdAccountSales)
	SELECT	
		BUDGET_REVISED_DETAIL.IdProject,
		IdGeneration + 1,
		BUDGET_REVISED_DETAIL.IdPhase,
		IdWorkPackage,
		IdCostCenter,
		BUDGET_REVISED_DETAIL.IdAssociate,
		YearMonth,
		HoursQty,
		HoursVal,
		SalesVal,
		IdCountry,
		IdAccountHours,
		IdAccountSales
	FROM 	BUDGET_REVISED_DETAIL
	--copy only active work packages
	INNER 	JOIN WORK_PACKAGES AS WP ON
		BUDGET_REVISED_DETAIL.IdProject = WP.IdProject AND
		BUDGET_REVISED_DETAIL.IdPhase = WP.IdPhase AND
		BUDGET_REVISED_DETAIL.IdWorkPackage = WP.[Id]
	--copy only the data of the active project core team members
	INNER 	JOIN PROJECT_CORE_TEAMS AS PCT ON
		PCT.IdProject = BUDGET_REVISED_DETAIL.IdProject AND
		PCT.IdAssociate = BUDGET_REVISED_DETAIL.IdAssociate
	WHERE 	IdGeneration = @NewGeneration - 1 AND
		BUDGET_REVISED_DETAIL.IdAssociate = @IdAssociate AND
		BUDGET_REVISED_DETAIL.IdProject = @IdProject AND
		WP.IsActive = 1 AND
		PCT.IsActive = 1

	INSERT INTO BUDGET_REVISED_DETAIL_COSTS (IdProject, IdGeneration, IdPhase, IdWorkPackage,
		IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
	SELECT	
		BUDGET_REVISED_DETAIL_COSTS.IdProject,
		IdGeneration + 1,
		BUDGET_REVISED_DETAIL_COSTS.IdPhase,
		IdWorkPackage,
		IdCostCenter,
		BUDGET_REVISED_DETAIL_COSTS.IdAssociate,
		YearMonth,
		IdCostType,
		CostVal,
		IdCountry,
		IdAccount
	FROM 	BUDGET_REVISED_DETAIL_COSTS
	--copy only active work packages
	INNER 	JOIN WORK_PACKAGES AS WP ON
		BUDGET_REVISED_DETAIL_COSTS.IdProject = WP.IdProject AND
		BUDGET_REVISED_DETAIL_COSTS.IdPhase = WP.IdPhase AND
		BUDGET_REVISED_DETAIL_COSTS.IdWorkPackage = WP.[Id]
	--copy only the data of the active project core team members
	INNER 	JOIN PROJECT_CORE_TEAMS AS PCT ON
		PCT.IdProject = BUDGET_REVISED_DETAIL_COSTS.IdProject AND
		PCT.IdAssociate = BUDGET_REVISED_DETAIL_COSTS.IdAssociate
	WHERE 	IdGeneration = @NewGeneration -1 AND
		BUDGET_REVISED_DETAIL_COSTS.IdAssociate = @IdAssociate AND
		BUDGET_REVISED_DETAIL_COSTS.IdProject = @IdProject AND
		WP.IsActive = 1 AND
		PCT.IsActive = 1

	--in case the WP Period has been changed from the validation we do the following routine 
	--for all the WP in the project, active or inactive
	DECLARE @IdProjectParam		int, 
		   @IdPhaseParam		int, 
		   @IdWPParam			int, 
		   @StartYearMonth		int, 
		   @EndYearMonth		int
	
	DECLARE WPCursor CURSOR FAST_FORWARD FOR
	SELECT DISTINCT	BRD.IdProject,
					BRD.IdPhase,
					BRD.IdWorkPackage,
					WP.StartYearMonth,
					WP.EndYearMonth
	FROM BUDGET_REVISED_DETAIL BRD
	INNER JOIN WORK_PACKAGES WP
			ON BRD.IdProject =WP.IdProject and
			   BRD.IdPhase = WP.IdPhase and
			   BRD.IdWorkPackage = WP.Id
	WHERE BRD.IdProject = @IdProject and 
		  BRD.IdGeneration = @NewGeneration and
		  BRD.IdAssociate = @IdAssociate and
		  -- check if number of month expected is different from the number of month found	
		  ((WP.EndYearMonth/100 - WP.StartYearMonth/100)*12 + (WP.EndYearMonth%100 - WP.StartYearMonth%100)+1) <> 
		 	 		(select TOP 1 count(*) 
					 from BUDGET_REVISED_DETAIL BRD2 with (nolock)
					 where BRD2.IdProject = BRD.IdProject AND
						   BRD2.IdGeneration = BRD.IdGeneration AND
						   BRD2.IdPhase = BRD.IdPhase AND
						   BRD2.IdWorkPackage = BRD.IdWorkPackage AND
						   BRD2.IdAssociate = BRD.IdAssociate
					 group by IdCostCenter) OR
		  -- check if StartYearMonth of the work package is the same as in the revised budget
		  WP.StartYearMonth <> (select min(BRD2.YearMonth)
					from BUDGET_REVISED_DETAIL BRD2 with (nolock)
					where BRD2.IdProject = BRD.IdProject AND
						   BRD2.IdGeneration = BRD.IdGeneration AND
						   BRD2.IdPhase = BRD.IdPhase AND
						   BRD2.IdWorkPackage = BRD.IdWorkPackage AND
						   BRD2.IdAssociate = BRD.IdAssociate AND
						   BRD2.IdCostCenter = BRD.IdCostCenter) OR
		  -- check if EndYearMonth of the work package is the same as in the revised budget
		  WP.EndYearMonth <> (select max(BRD2.YearMonth)
				      from BUDGET_REVISED_DETAIL BRD2 with (nolock)
				      where BRD2.IdProject = BRD.IdProject AND
						   BRD2.IdGeneration = BRD.IdGeneration AND
						   BRD2.IdPhase = BRD.IdPhase AND
						   BRD2.IdWorkPackage = BRD.IdWorkPackage AND
						   BRD2.IdAssociate = BRD.IdAssociate AND
						   BRD2.IdCostCenter = BRD.IdCostCenter)
	
	
	open WPCursor
	
	FETCH NEXT FROM WPCursor INTO @IdProjectParam, @IdPhaseParam, @IdWPParam, @StartYearMonth, @EndYearMonth
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		EXEC @retVal = bgtUpdateRevisedWPPeriod @IdProjectParam, @IdPhaseParam, @IdWPParam, @StartYearMonth, @EndYearMonth
		IF (@@ERROR <> 0 OR @retVal < 0)
		BEGIN
			CLOSE WPCursor
			DEALLOCATE WPCursor		
			RAISERROR ('There was an error splitting the totals per months for one WP.', 16, 1)
			RETURN -2
		END		
	
		FETCH NEXT FROM WPCursor INTO @IdProjectParam, @IdPhaseParam, @IdWPParam, @StartYearMonth, @EndYearMonth
	END
	
	CLOSE WPCursor
	DEALLOCATE WPCursor


	INSERT INTO BUDGET_REVISED_STATES(IdProject, IdGeneration, IdAssociate, State, StateDate)
	SELECT IdProject, IdGeneration+1, IdAssociate, 'N', StateDate
	FROM BUDGET_REVISED_STATES
	WHERE IdProject = @IdProject and
		  IdGeneration = @NewGeneration - 1 and 
		  IdAssociate = @IdAssociate

END
GO

--Drops the Procedure bgtRevisedBudgetCreateNewFromCurrentAll if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtRevisedBudgetCreateNewFromCurrentAll]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtRevisedBudgetCreateNewFromCurrentAll
GO

-- exec bgtRevisedBudgetCreateNewFromCurrentAll 25,2

CREATE  PROCEDURE bgtRevisedBudgetCreateNewFromCurrentAll
	@IdProject 			INT,
	@NewGeneration		INT
AS
BEGIN
	DECLARE @retVal 	INT

	--Creates a copy of the released version budget, increasing the IdGeneration (InProgress budget <- Released budget)
	INSERT INTO BUDGET_REVISED 
		(IdProject,  IdGeneration, 		IsValidated, 	ValidationDate)
	VALUES	(@IdProject, @NewGeneration, 		0, 		GETDATE())
	
	DECLARE AssociatesCursor CURSOR FAST_FORWARD FOR
	SELECT 	IdAssociate
	FROM	PROJECT_CORE_TEAMS
	WHERE IdProject = @IdProject and 
		  IsActive = 1
	
	open AssociatesCursor
	declare @IdAsociate int
	
	FETCH NEXT FROM AssociatesCursor INTO @IdAsociate
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		EXEC @retVal = bgtRevisedBudgetCreateNewFromCurrent @IdProject, @NewGeneration, @IdAsociate
	
		IF (@@ERROR <> 0 OR @retVal < 0)
		BEGIN
			CLOSE AssociatesCursor
			DEALLOCATE AssociatesCursor		
			RAISERROR ('There was error creating the budget for one active associate.', 16, 1)
			RETURN -1
		END		
	
		FETCH NEXT FROM AssociatesCursor INTO @IdAsociate
	END
	
	CLOSE AssociatesCursor
	DEALLOCATE AssociatesCursor
	

END
GO

--Drops the Procedure bgtSelectExchangeRateForConverter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtSelectExchangeRateForConverter]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtSelectExchangeRateForConverter
GO
CREATE PROCEDURE bgtSelectExchangeRateForConverter
	@CurrencyFrom	AS INT,	--The CurrencyFrom of the selected Exchange Rate
	@CurrencyTo	AS INT, --The CurrencyTo of the selected Exchange Rate
	@YearMonth	AS INT	--The Year and Month of the selected Exchange Rate
AS
	DECLARE @ConversionRate  	AS DECIMAL(10,4),
		@CurrencyFromName	VARCHAR(30),
		@CurrencyToName 	VARCHAR(30),
		@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	--we validate the YearMonth
	if (@YearMonth <> -1)
	BEGIN

		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@YearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -1
		end
	END

	--we validate the from and to currencies
	SELECT 	@CurrencyFromName = [Name]
	FROM 	CURRENCIES
	WHERE 	[Id] = @CurrencyFrom

	IF (@CurrencyFromName is NULL)
	BEGIN
		RAISERROR('CurrencyFrom (Id=%d) was not found in the CURRENCIES catalogue. Exchange rate cannot be calculated.', 16, 1, @CurrencyFrom)
		RETURN -2
	END


	SELECT 	@CurrencyToName = [Name]
	FROM 	CURRENCIES
	WHERE 	[Id] = @CurrencyTo

	IF (@CurrencyToName is NULL)
	BEGIN
		RAISERROR('CurrencyTo (Id=%d) was not found in the CURRENCIES catalogue. Exchange rate cannot be calculated.', 16, 1, @CurrencyTo)
		RETURN -3
	END



	--we see what is the exchange rate
	SELECT @ConversionRate = dbo.fnGetExchangeRate(@CurrencyFrom, @CurrencyTo, @YearMonth)
	IF (@ConversionRate IS NULL)
	BEGIN	
		RAISERROR('No exchange rate found for %s to %s conversion for YearMonth %d', 16, 1, @CurrencyFromName, @CurrencyToName, @YearMonth )
		RETURN -4
	END

	SELECT @ConversionRate AS 'ExchangeRate'
GO

--Drops the Procedure bgtSelectProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtSelectProjectCoreTeam]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtSelectProjectCoreTeam
GO
CREATE PROCEDURE bgtSelectProjectCoreTeam
	@IdProject	AS INT,		--The Id of the Project that is connected to the selected Core Team Member
	@IdAssociate	AS INT		--The Id of the Associate that is connected to the selected Core Team Member
AS
	--If @Id has the value -1, it will return all Core Team Members, that have the specified Project
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 

	IF( @IdAssociate = -1)
	BEGIN 
		SELECT 	
			A.[Name]	AS 'CoreTeamMemberName',
			A.EmployeeNumber as 'EmployeeNumber',
			PF.[Name]	AS 'FunctionName',
			C.[Name]   	AS 'Country',
			CTM.LastUpdate  AS 'LastUpdateDate',
			CTM.IsActive	AS 'IsActive',
			CTM.IdProject	AS 'IdProject',
			CTM.IdAssociate	AS 'IdAssociate',
			CTM.IdFunction	AS 'IdFunction',
			P.Name as 'ProjectName'
		FROM PROJECT_CORE_TEAMS AS CTM(nolock)
		INNER JOIN PROJECT_FUNCTIONS PF(nolock)
			ON CTM.IdFunction = PF.[Id]
		INNER JOIN ASSOCIATES A(nolock)
			ON CTM.IdAssociate = A.[Id]
		INNER JOIN PROJECTS P(nolock)
			ON CTM.IdProject = P.[Id]
		INNER JOIN COUNTRIES C (nolock)
			ON A.IdCountry  = C.Id
		WHERE CTM.IdProject = @IdProject
		ORDER BY PF.Rank

		RETURN
	END

	--If @Id does have the value different of -1 it will return the selected Core Team Member
	SELECT 	
		A.[Name]	AS 'CoreTeamMemberName',
		A.EmployeeNumber as 'EmployeeNumber',
		PF.[Name]	AS 'FunctionName',
		C.[Name]   	AS 'Country',
		CTM.LastUpdate  AS 'LastUpdateDate',
		CTM.IsActive	AS 'IsActive',
		CTM.IdProject	AS 'IdProject',
		CTM.IdAssociate	AS 'IdAssociate',
		CTM.IdFunction	AS 'IdFunction',
		P.Name as 'ProjectName'
	FROM PROJECT_CORE_TEAMS CTM(nolock)
		INNER JOIN PROJECT_FUNCTIONS PF(nolock)
	ON CTM.IdFunction = PF.[Id]
		INNER JOIN ASSOCIATES A(nolock)
	ON CTM.IdAssociate = A.[Id]
		INNER JOIN PROJECTS P(nolock)
	ON CTM.IdProject = P.[Id]
		INNER JOIN COUNTRIES C (nolock)
	ON A.IdCountry  = C.Id
	WHERE 	CTM.IdProject = @IdProject AND 
		CTM.IdAssociate = @IdAssociate
	ORDER BY PF.Rank

GO

--Drops the Procedure bgtSelectProjectFunctions if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtSelectProjectFunctions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtSelectProjectFunctions
GO
CREATE PROCEDURE bgtSelectProjectFunctions
AS
		SELECT 	PF.[Id]		AS 'Id',
			PF.[Name]	AS 'Name'
		FROM PROJECT_FUNCTIONS AS PF
		ORDER BY PF.Rank
GO

--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtToCompletionBudgetCreateNewFromCurrent]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtToCompletionBudgetCreateNewFromCurrent
GO

CREATE  PROCEDURE bgtToCompletionBudgetCreateNewFromCurrent
	@IdProject			INT,
	@NewGeneration		INT,
	@IdAssociate		INT
AS
BEGIN
	DECLARE @retVal		INT

	--If no record for the new generation exists in table BUDGET_TOCOMPLETION_PROGRESS, copy the data from the
	--Released generation into the InProgress generation for this project and this associate
	INSERT INTO BUDGET_TOCOMPLETION_PROGRESS (IdProject,IdGeneration,IdPhase,IdWorkPackage, IdAssociate, [Percent])
	SELECT  BTP.IdProject,
		    BTP.IdGeneration + 1,
		    BTP.IdPhase,
		    BTP.IdWorkPackage,
		    BTP.IdAssociate,
		    BTP.[Percent]
	FROM 	BUDGET_TOCOMPLETION_PROGRESS BTP
	INNER 	JOIN WORK_PACKAGES WP 
		ON	BTP.IdProject = WP.IdProject AND
			BTP.IdPhase = WP.IdPhase AND
			BTP.IdWorkPackage = WP.Id
	INNER 	JOIN PROJECT_CORE_TEAMS PCT 
		ON	PCT.IdProject = BTP.IdProject AND
			PCT.IdAssociate = BTP.IdAssociate
	WHERE	BTP.IdProject = @IdProject AND
			BTP.IdGeneration = @NewGeneration - 1 AND
			BTP.IdAssociate = @IdAssociate AND
			WP.IsActive = 1 AND 	--copy only active work packages
			PCT.IsActive = 1		--copy only the data of the active project core team members

	--If no record for the new generation exists in table BUDGET_TOCOMPLETION_DETAIL, copy the data from the
	--Released generation into the InProgress generation for this project and this associate
	INSERT INTO BUDGET_TOCOMPLETION_DETAIL (IdProject, IdGeneration, IdPhase, IdWorkPackage,
		IdCostCenter, IdAssociate, YearMonth, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
	SELECT  BTD.IdProject,
			BTD.IdGeneration + 1,
			BTD.IdPhase,
			BTD.IdWorkPackage,
			BTD.IdCostCenter,
			BTD.IdAssociate,
			BTD.YearMonth,
			BTD.HoursQty,
			BTD.HoursVal,
			BTD.SalesVal,
			BTD.IdCountry,
			BTD.IdAccountHours,
			BTD.IdAccountSales
	FROM 	BUDGET_TOCOMPLETION_DETAIL BTD
	INNER 	JOIN WORK_PACKAGES WP 
		ON	BTD.IdProject = WP.IdProject AND
			BTD.IdPhase = WP.IdPhase AND
			BTD.IdWorkPackage = WP.[Id]
	INNER 	JOIN PROJECT_CORE_TEAMS AS PCT 
		ON	PCT.IdProject = BTD.IdProject AND
			PCT.IdAssociate = BTD.IdAssociate
	WHERE	BTD.IdProject = @IdProject AND
			BTD.IdGeneration = @NewGeneration - 1 AND
			BTD.IdAssociate = @IdAssociate AND
			WP.IsActive = 1 AND 	--copy only active work packages
			PCT.IsActive = 1 AND	--copy only the data of the active project core team members 
			BTD.YearMonth BETWEEN WP.StartYearMonth and WP.EndYearMonth --this will cut rows in case the WP period has changed

	--If no record for the new generation exists in table BUDGET_TOCOMPLETION_DETAIL_COSTS, copy the data from the
	--Released generation into the InProgress generation for this project and this associate
	INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS (IdProject, IdGeneration, IdPhase, IdWorkPackage,
		IdCostCenter, IdAssociate, YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
	SELECT 	BTDC.IdProject,
			BTDC.IdGeneration + 1,
			BTDC.IdPhase,
			BTDC.IdWorkPackage,
			BTDC.IdCostCenter,
			BTDC.IdAssociate,
			BTDC.YearMonth,
			BTDC.IdCostType,
			BTDC.CostVal,
			BTDC.IdCountry,
			BTDC.IdAccount
	FROM 	BUDGET_TOCOMPLETION_DETAIL_COSTS BTDC
	INNER 	JOIN WORK_PACKAGES WP 
		ON	BTDC.IdProject = WP.IdProject AND
			BTDC.IdPhase = WP.IdPhase AND
			BTDC.IdWorkPackage = WP.Id
	INNER 	JOIN PROJECT_CORE_TEAMS PCT 
		ON	PCT.IdProject = BTDC.IdProject AND
			PCT.IdAssociate = BTDC.IdAssociate
	WHERE	BTDC.IdProject = @IdProject AND
			BTDC.IdGeneration = @NewGeneration - 1 AND
			BTDC.IdAssociate = @IdAssociate AND
			WP.IsActive = 1 AND 	--copy only active work packages
			PCT.IsActive = 1 AND	--copy only the data of the active project core team members
			BTDC.YearMonth BETWEEN WP.StartYearMonth and WP.EndYearMonth --this will cut rows in case the WP period has changed

	INSERT INTO BUDGET_TOCOMPLETION_STATES(IdProject, IdGeneration, IdAssociate, State, StateDate)
	SELECT IdProject, IdGeneration+1, IdAssociate, 'N', StateDate
	FROM BUDGET_TOCOMPLETION_STATES
	WHERE IdProject = @IdProject and
		  IdGeneration = @NewGeneration - 1 and 
		  IdAssociate = @IdAssociate

END
GO

--Drops the Procedure bgtToCompletionBudgetCreateNewFromCurrentAll if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtToCompletionBudgetCreateNewFromCurrentAll]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtToCompletionBudgetCreateNewFromCurrentAll
GO

-- exec bgtToCompletionBudgetCreateNewFromCurrentAll 25,2

CREATE  PROCEDURE bgtToCompletionBudgetCreateNewFromCurrentAll
	@IdProject		INT,
	@NewGeneration		INT
AS

--create the new version information in the master table
DECLARE @YearMonthActualDataCurrent INT,
		@retVal						INT

SELECT 	@YearMonthActualDataCurrent = YearMonthActualData
FROM 	BUDGET_TOCOMPLETION
WHERE	IdProject = @IdProject AND
		IdGeneration = @NewGeneration - 1

INSERT INTO BUDGET_TOCOMPLETION
	(IdProject,  IdGeneration,  IsValidated, ValidationDate, YearMonthActualData)
VALUES	(@IdProject, @NewGeneration, 0,		 NULL, 		 @YearMonthActualDataCurrent)
	

DECLARE AssociatesCursor CURSOR FAST_FORWARD FOR
SELECT 	IdAssociate
FROM	PROJECT_CORE_TEAMS
WHERE IdProject = @IdProject and 
	  IsActive = 1

open AssociatesCursor
declare @IdAsociate int

FETCH NEXT FROM AssociatesCursor INTO @IdAsociate
WHILE @@FETCH_STATUS = 0
BEGIN
	
	EXEC @retVal = bgtToCompletionBudgetCreateNewFromCurrent @IdProject, @NewGeneration, @IdAsociate
	IF (@@ERROR <> 0 OR @retVal < 0)
	BEGIN
		CLOSE AssociatesCursor
		DEALLOCATE AssociatesCursor
		RAISERROR ('There was error creating the budget for one active associate.', 16, 1)
		RETURN -1
	END		

	FETCH NEXT FROM AssociatesCursor INTO @IdAsociate
END

CLOSE AssociatesCursor
DEALLOCATE AssociatesCursor


GO

--Drops the Procedure bgtToCompletionBudgetCreateNewVersion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtToCompletionBudgetCreateNewVersion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtToCompletionBudgetCreateNewVersion
GO

CREATE PROCEDURE bgtToCompletionBudgetCreateNewVersion
	@IdProject int
AS
BEGIN
	declare @CurrentGeneration 	int,
			@NewGeneration 		int

	SET @CurrentGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'C')
	IF (@CurrentGeneration IS NULL)
	BEGIN
		RAISERROR('No released generation found for To Completion budget', 16, 1)
		RETURN -1
	END
	SET @NewGeneration = @CurrentGeneration + 1

	EXEC bgtToCompletionBudgetCreateNewFromCurrentAll @IdProject, @NewGeneration
	IF @@ERROR <> 0 
	BEGIN
		raiserror ('There was error creating the new generation.',16,1)
		RETURN -2
	END		
END
GO
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtUnvalidateLastReforecastVersion') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUnvalidateLastReforecastVersion
GO

CREATE  PROCEDURE bgtUnvalidateLastReforecastVersion
(
	@IdProject INT
)
AS
	declare @IdGeneration int
	declare @errMessage varchar(500)

	select @IdGeneration = max(IdGeneration)
	from BUDGET_TOCOMPLETION TABLOCKX
	WHERE 	IdProject = @IdProject
	and IsValidated = 1
	
	if isnull(@IdGeneration,0) > 0
	   begin
			begin tran


			Update BUDGET_TOCOMPLETION
			set ValidationDate = null,
				YearMonthActualData = null,
				IsValidated = 0
			where IdProject = @IdProject and IdGeneration = @IdGeneration
			
			if @@error <> 0
			   begin
				set @errMessage = 'BUDGET_TOCOMPLETION for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
				goto err
			   end


			Update BUDGET_TOCOMPLETION_STATES
				set State = 'W'
			where IdProject = @IdProject and 
			IdGeneration = @IdGeneration and 
			State <> 'N'
				  
			if @@error <> 0
			   begin
				set @errMessage = 'BUDGET_TOCOMPLETION_STATES for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
				goto err
			   end
				  
				commit
				goto retur
	   end
	   
	err:	   
		rollback
		raiserror(@errMessage,16,1)
	
	retur:
		return
		
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].bgtUnvalidateLastRevisedVersion') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUnvalidateLastRevisedVersion
GO

CREATE  PROCEDURE bgtUnvalidateLastRevisedVersion
(
	@IdProject INT
)
AS
	declare @IdGeneration int
	declare @errMessage varchar(500)

	select @IdGeneration = max(IdGeneration)
	from BUDGET_REVISED TABLOCKX
	WHERE 	IdProject = @IdProject
	and IsValidated = 1
	
	if isnull(@IdGeneration,0) > 0
	   begin
		begin tran

			Update BUDGET_REVISED
				set IsValidated = 0
			where IdProject = @IdProject and IdGeneration = @IdGeneration
			
			if @@error <> 0
			   begin
				set @errMessage = 'BUDGET_REVISED for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
				goto err
			   end

			Update BUDGET_REVISED_STATES
			set State = 'W'
			where IdProject = @IdProject and 
				  IdGeneration = @IdGeneration and 
				  State <> 'N'
				  
			if @@error <> 0
			   begin
				set @errMessage = 'BUDGET_REVISED_STATES for IdProject = ' + cast(@IdProject as varchar) + ' couldn''t be updated'
				goto err
			   end
				  
				commit
				goto retur
	   end
	   
	err:	   
		rollback
		raiserror(@errMessage,16,1)
	
	retur:
		return
		
GO

--Drops the Procedure bgtUpdateCompletionBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateCompletionBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateCompletionBudgetStates
GO



-- bgtUpdateCompletionBudgetStates 14,'N',4,'O'

CREATE        PROCEDURE bgtUpdateCompletionBudgetStates
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1),
	@IdAssociate		AS INT,
	@State			AS CHAR(1)
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@IdAssociate < 0 )
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -2
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -3
	END 

DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)

	IF(@IdGeneration is null)
	BEGIN
		RAISERROR('There is no reforecast for this version',16,1)		
		RETURN -4
	END

IF EXISTS (
		SELECT * FROM BUDGET_TOCOMPLETION_STATES WHERE [IdProject]=@IdProject AND
			 [IdGeneration]=@IdGeneration AND 
			[IdAssociate]=@IdAssociate
	  )
	BEGIN
		UPDATE [BUDGET_TOCOMPLETION_STATES]
		SET 
			[State]=@State, 
			[StateDate]=GETDATE()
		WHERE 
			[IdProject]=@IdProject AND
			[IdGeneration]=@IdGeneration AND  
			[IdAssociate]=@IdAssociate
	END
	ELSE
	BEGIN
		INSERT INTO [BUDGET_TOCOMPLETION_STATES]
			(IdProject, IdGeneration, IdAssociate, State, StateDate)
		VALUES 
			(@IdProject, @IdGeneration, @IdAssociate, @State, GETDATE())
	END



GO






--Drops the Procedure bgtUpdateInitialBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateInitialBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateInitialBudgetDetail
GO

CREATE  PROCEDURE bgtUpdateInitialBudgetDetail
	@IdProject	INT,		--The Id of the selected Project
	@IdPhase	INT,		--The Id of a phase from project
	@IdWP		INT,		--The Id of workpackage
	@IdCostCenter	INT,		--The Id of cost center
	@IdAssociate	INT,		--The Id of associate
	@YearMonth	INT,
	@HoursQty	INT,
	@HoursVal	DECIMAL(18,4),
	@SalesVal	DECIMAL(18,4)	
AS
BEGIN

	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end
	
	--If the value of @HoursVal is not null (has been inserted by the user in the application, store it in the db)
	IF (@HoursVal IS NOT NULL)
	BEGIN
		UPDATE  BUDGET_INITIAL_DETAIL
		SET 
			HoursQty = @HoursQty, 
			HoursVal = @HoursVal,
			SalesVal = @SalesVal
		WHERE
		IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdCostCenter = @IdCostCenter AND
		IdAssociate = @IdAssociate AND
		YearMonth = @YearMonth
	END
	ELSE
	BEGIN
		DECLARE @NewHoursVal DECIMAL(18,4)
		SET @NewHoursVal = dbo.fnGetValuedHours(@IdCostCenter, @HoursQty, @YearMonth)
		
		UPDATE  BUDGET_INITIAL_DETAIL
		SET 
			HoursQty = @HoursQty, 
			HoursVal = @NewHoursVal,
			SalesVal = @SalesVal
		WHERE	IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate AND
			YearMonth = @YearMonth
	END
END
GO

--Drops the Procedure bgtUpdateInitialBudgetOtherCost if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateInitialBudgetOtherCost]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateInitialBudgetOtherCost
GO

CREATE  PROCEDURE bgtUpdateInitialBudgetOtherCost
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT,
	@IdAssociate		INT,
	@YearMonth		INT,
	@IdCostType		INT,		--The Id of other cost type
	@CostVal		DECIMAL(18,4) = NULL	--The other cost value
	
AS
BEGIN

	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end


	--update other costs
	UPDATE BUDGET_INITIAL_DETAIL_COSTS
		SET CostVal = @CostVal
		WHERE IdProject = @IDProject
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdCostCenter = @IdCostCenter
		AND IdAssociate = @IdAssociate
		AND YearMonth = @YearMonth
		AND IdCostType = @IdCostType

END
GO

--Drops the Procedure bgtUpdateInitialBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateInitialBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateInitialBudgetStates
GO


CREATE    PROCEDURE bgtUpdateInitialBudgetStates
	@IdProject 	INT, 	--The Id of the Project
	@IdAssociate 	INT,     -- The Id of Associate
	@State 		CHAR(1)
AS

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 

	IF (@IdAssociate < 0 )
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -1
	END 
	

Declare @ROWCOUNT INT
	IF EXISTS(SELECT * FROM Budget_Initial_States WHERE IdProject = @IdProject
		AND IdAssociate = @IdAssociate)
	BEGIN
		UPDATE
			Budget_Initial_States
		SET 		
			StateDate = GETDATE(),
			State = @State
		
		WHERE 	IdProject = @IdProject
			AND IdAssociate = @IdAssociate
	
		SET @Rowcount = @@ROWCOUNT
		RETURN @Rowcount
	END
	ELSE
	BEGIN
		INSERT INTO [BUDGET_INITIAL_STATES]
			([IdProject], [IdAssociate], [StateDate], [State])
		VALUES(@IdProject, @IdAssociate, GETDATE(), @State)
		RETURN 1
	END
	

	



GO




--Drops the Procedure bgtUpdateInitialWPPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateInitialWPPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateInitialWPPeriod
GO
CREATE PROCEDURE bgtUpdateInitialWPPeriod
	@IdProjectParam	INT,		--The Id of the project
	@IdPhaseParam 	INT,		--The Id of the phase
	@IdWP		INT,		--The Id of the selected WorkPackage
	@StartYearMonth INT,		--The new startyearmonth of the workpackage
	@EndYearMonth	INT		--The new endyearmonth of the workpackage
AS
	--Create totals table (without costs)
	CREATE TABLE #Totals
	(
		IdProject 		INT NOT NULL,
		IdPhase 		INT NOT NULL,
		IdWorkPackage		INT NOT NULL,
		IdCostCenter		INT NOT NULL,
		IdAssociate		INT NOT NULL,
		HoursQty		INT,
		HoursVal		decimal(18,4),
		SalesVal		decimal(18,4),
		IdCountry		INT NOT NULL,
		IdAccountHours		INT NOT NULL,
		IdAccountSales		INT NOT NULL
		PRIMARY KEY (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate)
	)

	--Create total costs table
	CREATE TABLE #TotalCosts
	(
		IdProject 		INT NOT NULL,
		IdPhase 		INT NOT NULL,
		IdWorkPackage		INT NOT NULL,
		IdCostCenter		INT NOT NULL,
		IdAssociate		INT NOT NULL,
		IdCostType 		INT NOT NULL,
		CostVal			decimal(18,4),
		IdCountry 		INT NOT NULL,
		IdAccount		INT NOT NULL
		PRIMARY KEY (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCostType)
	)

	INSERT INTO #Totals
	(IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
	SELECT	BID.IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		SUM(HoursQty),
		SUM(HoursVal),
		SUM(SalesVal),
		IdCountry,
		IdAccountHours,
		IdAccountSales
	FROM 	BUDGET_INITIAL_DETAIL BID
	INNER JOIN BUDGET_INITIAL BI
		on BID.IdProject = BI.IdProject
	WHERE 	BID.IdProject = @IdProjectParam AND
			BID.IdPhase = @IdPhaseParam AND
			BID.IdWorkPackage = @IdWP AND
			BI.IsValidated = 0 --only for non validated Initial budgets
	GROUP BY BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter, BID.IdAssociate, BID.IdCountry, BID.IdAccountHours, BID.IdAccountSales

	INSERT INTO #TotalCosts
	(IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCostType, CostVal, IdCountry, IdAccount)
	SELECT 	BIDC.IdProject,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		IdCostType,
		SUM(CostVal),
		IdCountry,
		IdAccount
	FROM	BUDGET_INITIAL_DETAIL_COSTS BIDC
	INNER JOIN BUDGET_INITIAL BI
		on BIDC.IdProject = BI.IdProject
	WHERE 	BIDC.IdProject = @IdProjectParam AND
		BIDC.IdPhase = @IdPhaseParam AND
		BIDC.IdWorkPackage = @IdWP AND
			BI.IsValidated = 0 --only for non validated Initial budgets
	GROUP BY BIDC.IdProject, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter, BIDC.IdAssociate, BIDC.IdCostType, BIDC.IdCountry, BIDC.IdAccount
	
	DECLARE TotalsCursor CURSOR FAST_FORWARD FOR
		SELECT 	IdProject,
			IdPhase,
			IdWorkPackage,
			IdCostCenter,
			IdAssociate,
			HoursQty,
			HoursVal,
			SalesVal,
			IdCountry,
			IdAccountHours,
			IdAccountSales
		FROM 	#Totals

	OPEN TotalsCursor

	DECLARE @IdProject 	INT
	DECLARE @IdPhase 	INT
	DECLARE @IdWorkPackage 	INT
	DECLARE @IdCostCenter	INT
	DECLARE @IdAssociate	INT
	DECLARE @TotalHoursQty	INT
	DECLARE @TotalHoursVal	DECIMAL(18,4)
	DECLARE @TotalSalesVal 	DECIMAL(18,4)
	DECLARE @TotalCostVal	DECIMAL(18,4)
	DECLARE @TotalIdCountry INT
	DECLARE @TotalIdAccountHours INT
	DECLARE @TotalIdAccountSales INT
	DECLARE @TotalCostIdCountry INT
	DECLARE @TotalIdAccount INT

	DECLARE @EndYear	SMALLINT	
	DECLARE @EndMonth	SMALLINT
	DECLARE @StartMonth	SMALLINT
	DECLARE @StartYear	SMALLINT

	--Update work package period in initial budget
	FETCH NEXT FROM TotalsCursor INTO @IdProject, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate,
		@TotalHoursQty, @TotalHoursVal, @TotalSalesVal, @TotalIdCountry, @TotalIdAccountHours, @TotalIdAccountSales
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--Delete the old data
		DELETE FROM BUDGET_INITIAL_DETAIL_COSTS
		WHERE 	IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWorkPackage AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate
		
		DELETE FROM BUDGET_INITIAL_DETAIL
		WHERE	IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWorkPackage AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate

		SET @StartYear = @StartYearMonth / 100
		SET @StartMonth = @StartYearMonth % 100
		SET @EndYear = @EndYearMonth / 100
		SET @EndMonth = @EndYearMonth % 100

		declare @HourlyRate decimal(18,4)
		declare @HourlyRateIsDefinedAndInteger bit = null

		if @TotalHoursQty <> 0
		   begin
			set @HourlyRateIsDefinedAndInteger = 1
			set @HourlyRate = @TotalHoursVal * 1.0 / @TotalHoursQty
			if floor(@HourlyRate) <> @HourlyRate
			    set @HourlyRateIsDefinedAndInteger = 0
		   end
		
		WHILE ((@StartYear < @EndYear) OR (@StartYear = @EndYear AND @StartMonth <= @EndMonth))
		BEGIN
			DECLARE @Date INT
			SET @Date = @StartYear * 100 + @StartMonth

			DECLARE @CurrentHoursQty int
			DECLARE @CurrentHoursVal bigint
			DECLARE @CurrentSalesVal bigint
						
			SET @CurrentHoursQty = dbo.fnGetSplittedValue(@TotalHoursQty, @Date, @StartYearMonth, @EndYearMonth)
			if 	@HourlyRateIsDefinedAndInteger is null
			    begin
					SET @CurrentHoursVal = dbo.fnGetSplittedValue(CAST(@TotalHoursVal AS BIGINT), @Date, @StartYearMonth, @EndYearMonth)
				end
			else if @HourlyRateIsDefinedAndInteger = 0
			    begin 
					-- if HourlyRate is not integer, the last month is calculated differently
					if @Date < @EndYearMonth
						set @CurrentHoursVal = @CurrentHoursQty * floor(@HourlyRate)
					else
					    begin
							set @CurrentHoursVal = @TotalHoursVal -  (select sum(HoursVal)
								from BUDGET_INITIAL_DETAIL
								where IdProject = @IdProject 
								and IdPhase = @IdPhase 
								and IdWorkPackage = @IdWorkPackage
								and IdCostCenter = @IdCostCenter 
								and IdAssociate = @IdAssociate)
						end
				end
			else
				begin
					set @CurrentHoursVal = @CurrentHoursQty * floor(@HourlyRate)
				end

			SET @CurrentSalesVal = dbo.fnGetSplittedValue(CAST(@TotalSalesVal AS BIGINT), @Date, @StartYearMonth, @EndYearMonth)						

			INSERT INTO BUDGET_INITIAL_DETAIL
				(IdProject,  IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth, HoursQty,         HoursVal, 	   SalesVal, 	     IdCountry, 	IdAccountHours, 	IdAccountSales)
			VALUES 	(@IdProject, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate, @Date,     @CurrentHoursQty, CAST(@CurrentHoursVal AS DECIMAL(18,4)), CAST(@CurrentSalesVal AS DECIMAL(18,4)), @TotalIdCountry,	@TotalIdAccountHours,   @TotalIdAccountSales)

			DECLARE @Counter INT
			SET @Counter = 1
			
			WHILE (@Counter <= 5)
			BEGIN
				DECLARE @CurrentCostVal BIGINT
				
				SELECT 	@TotalCostVal = CostVal,
					@TotalCostIdCountry = IdCountry,
					@TotalIdAccount = IdAccount
				FROM 	#TotalCosts
				WHERE 	IdProject = @IdProject AND
					IdPhase = @IdPhase AND
					IdWorkPackage = @IdWorkPackage AND
					IdCostCenter = @IdCostCenter AND
					IdAssociate = @IdAssociate AND
					IdCostType = @Counter							
				
				SET @CurrentCostVal = dbo.fnGetSplittedValue(CAST(@TotalCostVal AS BIGINT), @Date, @StartYearMonth, @EndYearMonth)
				
				INSERT INTO BUDGET_INITIAL_DETAIL_COSTS
					(IdProject,  IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth, IdCostType, CostVal, IdCountry, IdAccount)
				VALUES	(@IdProject, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate, @Date,     @Counter,   CAST(@CurrentCostVal AS DECIMAL(18,4)), @TotalCostIdCountry, @TotalIdAccount)
				
				SET @Counter = @Counter + 1
			END
		
			IF(@StartMonth = 12)
			BEGIN
				SET @StartYear = @StartYear + 1
				SET @StartMonth = 1
			END
			ELSE
			BEGIN
				SET @StartMonth = @StartMonth + 1
			END

		END


		FETCH NEXT FROM TotalsCursor INTO @IdProject, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate,
		@TotalHoursQty, @TotalHoursVal, @TotalSalesVal, @TotalIdCountry, @TotalIdAccountHours, @TotalIdAccountSales
	END

	CLOSE TotalsCursor
	DEALLOCATE TotalsCursor
GO
--Drops the Procedure bgtUpdateProjectCoreTeam if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateProjectCoreTeam]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateProjectCoreTeam
GO
CREATE PROCEDURE bgtUpdateProjectCoreTeam
	@IdProject		INT,		--The Id of the Project that is connected to the Project Core Team you want to insert
	@IdAssociate		INT,		--The Id of the Associate that is connected to the Project Core Team you want to insert
	@IdFunction		INT,		--The Id of the Function that is connected to the Project Core Team you want to insert
	@IsActive		BIT
AS
DECLARE @ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20),
	@RowCount 		INT
	
	IF(@IdProject IS NULL OR 
	   @IdAssociate IS NULL OR 
	   @IdFunction IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	DECLARE @OldIsActive BIT
	SELECT  @OldIsActive = IsActive
	FROM	PROJECT_CORE_TEAMS
	WHERE	IdProject = @IdProject AND 
		IdAssociate = @IdAssociate

	DECLARE @BudgetState CHAR(1)
	DECLARE @IdGeneration INT

	--If we are making a core team member from active to inactive, delete all his budget information
	IF (@OldIsActive = 1 AND @IsActive = 0)
	BEGIN
		SELECT 	@BudgetState = State
		FROM	BUDGET_INITIAL_STATES
		WHERE 	IdProject = @IdProject AND
			IdAssociate = @IdAssociate AND
			State <> 'V' AND State <> 'N' AND State <> 'U'

		IF (@BudgetState IS NOT NULL)
		BEGIN
			DELETE FROM BUDGET_INITIAL_DETAIL_COSTS
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate
			DELETE FROM BUDGET_INITIAL_DETAIL
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate
		END

		SELECT 	@BudgetState = State,
			@IdGeneration = IdGeneration
		FROM	BUDGET_REVISED_STATES
		WHERE 	IdProject = @IdProject AND
			IdAssociate = @IdAssociate AND
			State <> 'V' AND State <> 'N'

		IF (@BudgetState IS NOT NULL AND @IdGeneration IS NOT NULL)
		BEGIN
			DELETE FROM BUDGET_REVISED_DETAIL_COSTS
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate AND
				IdGeneration = @IdGeneration
			DELETE FROM BUDGET_REVISED_DETAIL
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate AND
				IdGeneration = @IdGeneration
		END

		SELECT 	@BudgetState = State,
			@IdGeneration = IdGeneration
		FROM	BUDGET_TOCOMPLETION_STATES
		WHERE 	IdProject = @IdProject AND
			IdAssociate = @IdAssociate AND
			State <> 'V' AND State <> 'N'

		IF (@BudgetState IS NOT NULL AND @IdGeneration IS NOT NULL)
		BEGIN
			DELETE FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate AND
				IdGeneration = @IdGeneration
			DELETE FROM BUDGET_TOCOMPLETION_DETAIL
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate AND
				IdGeneration = @IdGeneration
			DELETE FROM BUDGET_TOCOMPLETION_PROGRESS
			WHERE	IdProject = @IdProject AND
				IdAssociate = @IdAssociate AND
				IdGeneration = @IdGeneration
		END
	END


	UPDATE PROJECT_CORE_TEAMS
	SET	IdFunction = @IdFunction,
		IsActive = @IsActive,
		LastUpdate = GETDATE()	
	WHERE  	IdProject = @IdProject AND 
		IdAssociate = @IdAssociate

	SET @RowCount = @@ROWCOUNT
	RETURN @RowCount
GO



--Drops the Procedure bgtUpdateRevisedBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateRevisedBudgetDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateRevisedBudgetDetail
GO

CREATE  PROCEDURE bgtUpdateRevisedBudgetDetail
	@IdProject			INT,		--The Id of the selected Project
	@IdPhase			INT,		--The Id of a phase from project
	@IdWP				INT,		--The Id of workpackage
	@IdCostCenter		INT,		--The Id of cost center
	@IdAssociate		INT,		--The Id of associate
	@YearMonth			INT,
	@HoursQty			INT = NULL,
	@SalesVal			DECIMAL = NULL
AS
BEGIN
	Declare	@ErrorMessage		VARCHAR(255),
			@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	SELECT @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	FROM fnValidateYearMonth(@YearMonth)

	IF (@YMValidationResult < 0)
	BEGIN
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	DECLARE @IdGeneration INT
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	DECLARE @WPDuration 	INT,
			@rowCount		INT


	DECLARE	@HoursVal DECIMAL(18,4)
	SET  	@HoursVal = CASE WHEN @HoursQty IS NOT NULL THEN dbo.fnGetValuedHours(@IdCostCenter, @HoursQty, @YearMonth) ELSE NULL END

	UPDATE  BUDGET_REVISED_DETAIL
	SET 	HoursQty = ISNULL(@HoursQty, HoursQty),
			SalesVal = CASE WHEN @HoursQty IS NOT NULL THEN	SalesVal ELSE @SalesVal END,
			HoursVal = CASE WHEN @HoursVal IS NULL THEN HoursVal ELSE @HoursVal END
	WHERE	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate AND
			YearMonth = @YearMonth

	Set @rowCount = @@ROWCOUNT
	If (@rowCount = 0)
	BEGIN
		RAISERROR('Save failed. Other user may have changed data you were saving.', 16, 1)
		RETURN -2
	END


END
GO

--Drops the Procedure bgtUpdateRevisedBudgetDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateRevisedBudgetDetailForUplodRevisedBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateRevisedBudgetDetailForUplodRevisedBudget
GO

create  PROCEDURE [dbo].[bgtUpdateRevisedBudgetDetailForUplodRevisedBudget]
	@IdProject			INT,		--The Id of the selected Project
	@IdPhase			INT,		--The Id of a phase from project
	@IdWP				INT,		--The Id of workpackage
	@IdCostCenter		INT,		--The Id of cost center
	@IdAssociate		INT,		--The Id of associate
	@YearMonth			INT,
	@HoursQty			INT = NULL,
	@SalesVal			DECIMAL = NULL
AS
BEGIN
	Declare	@ErrorMessage		VARCHAR(255),
			@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	SELECT @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	FROM fnValidateYearMonth(@YearMonth)

	IF (@YMValidationResult < 0)
	BEGIN
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	DECLARE @IdGeneration INT
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	DECLARE @WPDuration 	INT,
			@rowCount		INT


	DECLARE	@HoursVal DECIMAL(18,4)
	SET  	@HoursVal = CASE WHEN @HoursQty IS NOT NULL THEN dbo.fnGetValuedHours(@IdCostCenter, @HoursQty, @YearMonth) ELSE NULL END

	UPDATE  BUDGET_REVISED_DETAIL
	SET 	HoursQty = ISNULL(@HoursQty, HoursQty),
			SalesVal = @SalesVal,
			HoursVal = CASE WHEN @HoursVal IS NULL THEN HoursVal ELSE @HoursVal END
	WHERE	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate AND
			YearMonth = @YearMonth

	Set @rowCount = @@ROWCOUNT
	If (@rowCount = 0)
	BEGIN
		RAISERROR('Save failed. Other user may have changed data you were saving.', 16, 1)
		RETURN -2
	END


END

GO

--Drops the Procedure bgtUpdateRevisedBudgetOtherCost if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateRevisedBudgetOtherCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateRevisedBudgetOtherCosts
GO

CREATE  PROCEDURE bgtUpdateRevisedBudgetOtherCosts
	@IdProject				INT,		--The Id of project
	@IdPhase				INT,		--The Id of phase
	@IdWP					INT,		--The Id of workpackage
	@IdCostCenter			INT,		--The Id of cost center
	@IdAssociate			INT,		--The Id of associate
	@YearMonth				INT,		--Year and month
	@IdCostType				INT,
	@CostVal				DECIMAL(18,2)
AS
BEGIN

	Declare	@ErrorMessage		VARCHAR(255),
			@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end

	DECLARE @IdGeneration INT,
			@rowCount	  INT
	SELECT @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'N')

	IF (@IdGeneration IS NULL)
	BEGIN
		RAISERROR('No new budget version found for Revised Budget', 16, 1)
		RETURN -2
	END
		
	--update other costs
	UPDATE BUDGET_REVISED_DETAIL_COSTS
	SET CostVal = @CostVal
	WHERE IdProject = @IdProject AND
		  IdGeneration = @IdGeneration AND
		  IdPhase = @IdPhase AND
		  IdWorkPackage = @IdWP AND
		  IdCostCenter = @IdCostCenter AND
		  IdAssociate = @IdAssociate AND
		  YearMonth = @YearMonth AND
		  IdCostType = @IdCostType

	Set @rowCount = @@ROWCOUNT
	If (@rowCount = 0)
	BEGIN
		RAISERROR('Save failed. Other user may have changed data you were saving.', 16, 1)
		RETURN -3
	END
	
END
GO

--Drops the Procedure bgtUpdateRevisedBudgetStates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateRevisedBudgetStates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateRevisedBudgetStates
GO

-- bgtUpdateRevisedBudgetStates 14,'N',4,'O'
CREATE PROCEDURE bgtUpdateRevisedBudgetStates
	@IdProject 			INT,
	@BudVersion			CHAR(1),
	@IdAssociate		INT,
	@State				CHAR(1)
AS
BEGIN

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 

	IF (@IdAssociate < 0 )
	BEGIN 
		RAISERROR('No associate has been selected',16,1)		
		RETURN -2
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -3
	END 

	DECLARE @IdGeneration INT
	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	IF(@IdGeneration is null)
	BEGIN
		RAISERROR('There is no revised budget for this version',16,1)		
		RETURN -4
	END

	IF EXISTS (	SELECT * 
				FROM BUDGET_REVISED_STATES 
				WHERE IdProject = @IdProject AND
			 		  IdGeneration=@IdGeneration AND 
					  IdAssociate=@IdAssociate)
	BEGIN
		UPDATE BUDGET_REVISED_STATES
		SET State=@State, 
			StateDate=GETDATE()
		WHERE 
			IdProject=@IdProject AND
			IdGeneration=@IdGeneration AND  
			IdAssociate=@IdAssociate
	END
	ELSE
	BEGIN
		INSERT INTO BUDGET_REVISED_STATES
			(IdProject, IdGeneration, IdAssociate, State, StateDate)
		VALUES 
			(@IdProject, @IdGeneration, @IdAssociate, @State, GETDATE())
	END
END

GO






--Drops the Procedure bgtUpdateRevisedWPPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateRevisedWPPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateRevisedWPPeriod
GO
CREATE PROCEDURE bgtUpdateRevisedWPPeriod
	@IdProjectParam	INT,		--The Id of the project
	@IdPhaseParam 	INT,		--The Id of the phase
	@IdWP		INT,		--The Id of the selected WorkPackage
	@StartYearMonth INT,		--The new startyearmonth of the workpackage
	@EndYearMonth	INT		--The new endyearmonth of the workpackage
AS
	--Create totals table (without costs)
	CREATE TABLE #Totals
	(
		IdProject 		INT NOT NULL,
		IdGeneration		INT NOT NULL,
		IdPhase 		INT NOT NULL,
		IdWorkPackage		INT NOT NULL,
		IdCostCenter		INT NOT NULL,
		IdAssociate		INT NOT NULL,
		HoursQty		INT,
		HoursVal		INT,
		SalesVal		INT,
		IdCountry		INT NOT NULL,
		IdAccountHours		INT NOT NULL,
		IdAccountSales		INT NOT NULL
		PRIMARY KEY (IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate)
	)

	--Create total costs table
	CREATE TABLE #TotalCosts
	(
		IdProject 		INT NOT NULL,
		IdGeneration		INT NOT NULL,
		IdPhase 		INT NOT NULL,
		IdWorkPackage		INT NOT NULL,
		IdCostCenter		INT NOT NULL,
		IdAssociate		INT NOT NULL,
		IdCostType 		INT NOT NULL,
		CostVal			INT,
		IdCountry 		INT NOT NULL,
		IdAccount		INT NOT NULL
		PRIMARY KEY (IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCostType)
	)

	INSERT INTO #Totals
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, HoursQty, HoursVal, SalesVal, IdCountry, IdAccountHours, IdAccountSales)
	SELECT 	BRD.IdProject,
		BRD.IdGeneration,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		SUM(HoursQty),
		SUM(HoursVal),
		SUM(SalesVal),
		IdCountry,
		IdAccountHours,
		IdAccountSales
	FROM 	BUDGET_REVISED_DETAIL BRD
	INNER JOIN BUDGET_REVISED BR
		on BRD.IdProject = BR.IDProject and
		   BRD.IdGeneration = BR.IdGeneration
	WHERE 	BRD.IdProject = @IdProjectParam AND
			BRD.IdPhase = @IdPhaseParam AND
			BRD.IdWorkPackage = @IdWP AND
			BR.IsValidated = 0 --only change in non validated versions
	GROUP BY BRD.IdProject, BRD.IdGeneration, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter, BRD.IdAssociate, BRD.IdCountry, BRD.IdAccountHours, BRD.IdAccountSales

	INSERT INTO #TotalCosts
	(IdProject, IdGeneration, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCostType, CostVal, IdCountry, IdAccount)
	SELECT 	BRDC.IdProject,
		BRDC.IdGeneration,
		IdPhase,
		IdWorkPackage,
		IdCostCenter,
		IdAssociate,
		IdCostType,
		SUM(CostVal),
		IdCountry,
		IdAccount
	FROM	BUDGET_REVISED_DETAIL_COSTS BRDC
	INNER JOIN BUDGET_REVISED BR
		on BRDC.IdProject = BR.IDProject and
		   BRDC	.IdGeneration = BR.IdGeneration
	WHERE 	BRDC.IdProject = @IdProjectParam AND
			BRDC.IdPhase = @IdPhaseParam AND
			BRDC.IdWorkPackage = @IdWP AND
			BR.IsValidated = 0 --only change in non validated versions			
	GROUP BY BRDC.IdProject, BRDC.IdGeneration, BRDC.IdPhase, BRDC.IdWorkPackage, BRDC.IdCostCenter, BRDC.IdAssociate, BRDC.IdCostType, BRDC.IdCountry, BRDC.IdAccount
	
	DECLARE TotalsCursor CURSOR FAST_FORWARD FOR
		SELECT 	IdProject,
			IdGeneration,
			IdPhase,
			IdWorkPackage,
			IdCostCenter,
			IdAssociate,
			HoursQty,
			HoursVal,
			SalesVal,
			IdCountry,
			IdAccountHours,
			IdAccountSales
		FROM 	#Totals

	OPEN TotalsCursor

	DECLARE @IdProject 	INT
	DECLARE @IdGeneration 	INT
	DECLARE @IdPhase 	INT
	DECLARE @IdWorkPackage 	INT
	DECLARE @IdCostCenter	INT
	DECLARE @IdAssociate	INT
	DECLARE @TotalHoursQty	INT
	DECLARE @TotalHoursVal	INT
	DECLARE @TotalSalesVal 	INT
	DECLARE @TotalCostVal	INT
	DECLARE @TotalIdCountry INT
	DECLARE @TotalIdAccountHours INT
	DECLARE @TotalIdAccountSales INT
	DECLARE @TotalCostIdCountry INT
	DECLARE @TotalIdAccount INT

	DECLARE @EndYear	SMALLINT	
	DECLARE @EndMonth	SMALLINT
	DECLARE @StartMonth	SMALLINT
	DECLARE @StartYear	SMALLINT

	--Update work package period in revised budget
	FETCH NEXT FROM TotalsCursor INTO @IdProject, @IdGeneration, @IdPhase, @IdWorkPackage, @IdCostCenter,
		@IdAssociate, @TotalHoursQty, @TotalHoursVal, @TotalSalesVal, @TotalIdCountry, @TotalIdAccountHours, @TotalIdAccountSales
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--Delete the old data
		DELETE FROM BUDGET_REVISED_DETAIL_COSTS
		WHERE 	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWorkPackage AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate
		
		DELETE FROM BUDGET_REVISED_DETAIL
		WHERE	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWorkPackage AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = @IdAssociate

		SET @StartYear = @StartYearMonth / 100
		SET @StartMonth = @StartYearMonth % 100
		SET @EndYear = @EndYearMonth / 100
		SET @EndMonth = @EndYearMonth % 100
		
		WHILE ((@StartYear < @EndYear) OR (@StartYear = @EndYear AND @StartMonth <= @EndMonth))
		BEGIN
			DECLARE @Date INT
			SET @Date = @StartYear * 100 + @StartMonth

			DECLARE @CurrentHoursQty INT
			DECLARE @CurrentHoursVal INT
			DECLARE @CurrentSalesVal INT

			SET @CurrentHoursQty = dbo.fnGetSplittedValue(@TotalHoursQty, @Date, @StartYearMonth, @EndYearMonth)
			SET @CurrentHoursVal = dbo.fnGetSplittedValue(@TotalHoursVal, @Date, @StartYearMonth, @EndYearMonth)
			SET @CurrentSalesVal = dbo.fnGetSplittedValue(@TotalSalesVal, @Date, @StartYearMonth, @EndYearMonth)

			INSERT INTO BUDGET_REVISED_DETAIL
				(IdProject,  IdGeneration,  IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth, HoursQty,         HoursVal, 	   SalesVal, 	     IdCountry, 	IdAccountHours, 	IdAccountSales)
			VALUES 	(@IdProject, @IdGeneration, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate, @Date,     @CurrentHoursQty, @CurrentHoursVal, @CurrentSalesVal, @TotalIdCountry,	@TotalIdAccountHours,   @TotalIdAccountSales)

			DECLARE @Counter INT
			SET @Counter = 1
			
			WHILE (@Counter <= 5)
			BEGIN
				DECLARE @CurrentCostVal INT
				
				SELECT 	@TotalCostVal = CostVal,
					@TotalCostIdCountry = IdCountry,
					@TotalIdAccount = IdAccount
				FROM 	#TotalCosts
				WHERE 	IdProject = @IdProject AND
					IdGeneration = @IdGeneration AND
					IdPhase = @IdPhase AND
					IdWorkPackage = @IdWorkPackage AND
					IdCostCenter = @IdCostCenter AND
					IdAssociate = @IdAssociate AND
					IdCostType = @Counter

				SET @CurrentCostVal = dbo.fnGetSplittedValue(@TotalCostVal, @Date, @StartYearMonth, @EndYearMonth)
				
				INSERT INTO BUDGET_REVISED_DETAIL_COSTS
					(IdProject,  IdGeneration,  IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth, IdCostType, CostVal,	   IdCountry, 		IdAccount)
				VALUES	(@IdProject, @IdGeneration, @IdPhase, @IdWorkPackage, @IdCostCenter, @IdAssociate, @Date,     @Counter,   @CurrentCostVal,@TotalCostIdCountry, @TotalIdAccount)
				
				SET @Counter = @Counter + 1
			END
		
			IF(@StartMonth = 12)
			BEGIN
				SET @StartYear = @StartYear + 1
				SET @StartMonth = 1
			END
			ELSE
			BEGIN
				SET @StartMonth = @StartMonth + 1
			END

		END


		FETCH NEXT FROM TotalsCursor INTO @IdProject, @IdGeneration, @IdPhase, @IdWorkPackage, @IdCostCenter,
		@IdAssociate, @TotalHoursQty, @TotalHoursVal, @TotalSalesVal, @TotalIdCountry, @TotalIdAccountHours, @TotalIdAccountSales
	END

	CLOSE TotalsCursor
	DEALLOCATE TotalsCursor
GO

--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateToCompletionBudgetHours]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateToCompletionBudgetHours
GO

CREATE  PROCEDURE bgtUpdateToCompletionBudgetHours
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT,
	@YearMonth		INT,
	@Hours			INT,
	@ActualDataTimestamp	DATETIME
AS
	--Get the new generation Id
	DECLARE @NewGeneration		INT
	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'N')
	IF (@NewGeneration IS NULL)
	BEGIN
		RAISERROR('No new generation found for To Completion budget', 16, 1)
		RETURN
	END
	
	IF 
	(
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_HOURS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_SALES AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_COSTS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
	)
	BEGIN
		RAISERROR('Please reload your budget, the actual data your budget is based on has changed.', 16, 1)
		RETURN
	END

	IF NOT EXISTS (
		SELECT 
			IdProject
		FROM 	BUDGET_TOCOMPLETION_DETAIL
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth		
	)
	BEGIN
		DECLARE @IdCountry INT
		DECLARE @CountryName VARCHAR(30)
		DECLARE @CostCenterName VARCHAR(50)
		DECLARE @CountryHasDefaultAccounts BIT
	
		SELECT 	@IdCountry = C.[Id],
			@CountryName = C.[Name],
			@CostCenterName = CC.[Name]
		FROM 	COST_CENTERS CC
		INNER 	JOIN INERGY_LOCATIONS IL ON
			CC.IdInergyLocation = IL.[Id]
		INNER 	JOIN COUNTRIES C ON
			IL.IdCountry = C.[Id]
		WHERE 	CC.[Id] = @IdCostCenter
	
		SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)
	
		IF (@CountryHasDefaultAccounts = 0)
		BEGIN
			RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
			RETURN -3
		END
	
		DECLARE @IdAccountHours INT
		DECLARE @IdAccountSales INT
	
		--Select the account id for hours
		SELECT 	@IdAccountHours = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 6
	
		--Select the account id for sales
		SELECT 	@IdAccountSales = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 7
		

		INSERT INTO BUDGET_TOCOMPLETION_DETAIL 
			(IdProject,   IdGeneration,  IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth,  HoursQty, SalesVal, HoursVal,   					     IdCountry,  IdAccountHours,  IdAccountSales)
		VALUES (@IdProject, @NewGeneration, @IdPhase, @IdWP         , @IdCostCenter,  @IdAssociate, @YearMonth, @Hours,   NULL,	    dbo.fnGetValuedHours(@IdCostCenter, @Hours, @YearMonth), @IdCountry, @IdAccountHours, @IdAccountSales)
	END
	ELSE
	BEGIN
		UPDATE 	BUDGET_TOCOMPLETION_DETAIL
		SET 	HoursQty = @Hours,
			HoursVal = dbo.fnGetValuedHours(@IdCostCenter, @Hours, @YearMonth)
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth
	
	END
GO

--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateToCompletionOtherCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateToCompletionOtherCosts
GO

CREATE  PROCEDURE bgtUpdateToCompletionOtherCosts
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT,
	@YearMonth		INT,
	@CostVal		DECIMAL(18,2),
	@IdCostType		INT,
	@ActualDataTimestamp	DATETIME
AS
	--Get the new generation Id
	DECLARE @NewGeneration		INT
	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'N')
	IF (@NewGeneration IS NULL)
	BEGIN
		RAISERROR('No new generation found for To Completion budget', 16, 1)
		RETURN
	END

	IF 
	(
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_HOURS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_SALES AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_COSTS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
	)
	BEGIN
		RAISERROR('Please reload your budget, the actual data your budget is based on has changed.', 16, 1)
		RETURN
	END

	IF NOT EXISTS (
		SELECT 
			IdProject
		FROM 	BUDGET_TOCOMPLETION_DETAIL
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth
	)
	BEGIN
		DECLARE @IdCountry INT
		DECLARE @CountryName VARCHAR(30)
		DECLARE @CostCenterName VARCHAR(50)
		DECLARE @CountryHasDefaultAccounts BIT
	
		SELECT 	@IdCountry = C.[Id],
			@CountryName = C.[Name],
			@CostCenterName = CC.[Name]
		FROM 	COST_CENTERS CC
		INNER 	JOIN INERGY_LOCATIONS IL ON
			CC.IdInergyLocation = IL.[Id]
		INNER 	JOIN COUNTRIES C ON
			IL.IdCountry = C.[Id]
		WHERE 	CC.[Id] = @IdCostCenter
	
		SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)
	
		IF (@CountryHasDefaultAccounts = 0)
		BEGIN
			RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
			RETURN -3
		END
	
		DECLARE @IdAccountHours INT
		DECLARE @IdAccountSales INT
	
		--Select the account id for hours
		SELECT 	@IdAccountHours = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 6
	
		--Select the account id for sales
		SELECT 	@IdAccountSales = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 7

		INSERT INTO BUDGET_TOCOMPLETION_DETAIL	
			(IdProject,  IdGeneration,   IdPhase,  IdWorkPackage, 	IdCostCenter,  IdAssociate,  YearMonth,  HoursQty, HoursVal, SalesVal,  IdCountry, IdAccountHours,   IdAccountSales)
		VALUES	(@IdProject, @NewGeneration, @IdPhase, @IdWP, 		@IdCostCenter, @IdAssociate, @YearMonth, NULL,     NULL,     NULL,	@IdCountry, @IdAccountHours, @IdAccountSales)
	END

	IF NOT EXISTS (
		SELECT 
			IdProject
		FROM 	BUDGET_TOCOMPLETION_DETAIL_COSTS
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth
		AND	IdCostType = @IdCostType
	)
	BEGIN
		SELECT 	@IdCountry = C.[Id],
			@CountryName = C.[Name],
			@CostCenterName = CC.[Name]
		FROM 	COST_CENTERS CC
		INNER 	JOIN INERGY_LOCATIONS IL ON
			CC.IdInergyLocation = IL.[Id]
		INNER 	JOIN COUNTRIES C ON
			IL.IdCountry = C.[Id]
		WHERE 	CC.[Id] = @IdCostCenter

		DECLARE @IdAccount INT

		--Select the account id for the given cost type
		SELECT 	@IdAccount = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = @IdCostType

		INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS
			(IdProject,  IdGeneration,   IdPhase,  IdWorkPackage, IdCostCenter,  IdAssociate,  YearMonth,  IdCostType,  CostVal,  IdCountry,  IdAccount)
		VALUES  (@IdProject, @NewGeneration, @IdPhase, @IdWP,         @IdCostCenter, @IdAssociate, @YearMonth, @IdCostType, @CostVal, @IdCountry, @IdAccount)
	END
	ELSE
	BEGIN
		UPDATE 	BUDGET_TOCOMPLETION_DETAIL_COSTS
		SET 	CostVal = @CostVal
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth
		AND	IdCostType = @IdCostType
	END
GO

--Drops the Procedure bgtUpdateToCompletionBudgetProgress if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateToCompletionBudgetProgress]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateToCompletionBudgetProgress
GO

CREATE  PROCEDURE bgtUpdateToCompletionBudgetProgress
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@Percentage		DECIMAL(18, 2)
AS
	--Get the new generation Id
	DECLARE @NewGeneration		INT
	DECLARE @CurrentGeneration	INT

	DECLARE @RetVal INT

	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'N')
	
	IF (@NewGeneration IS NULL)
	BEGIN
		SET @CurrentGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'C')
		IF (@CurrentGeneration IS NULL)
		BEGIN
			RAISERROR('No released generation found for To Completion budget', 16, 1)
			RETURN -1
		END
		SET @NewGeneration = @CurrentGeneration + 1

		EXEC @RetVal = bgtToCompletionBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -2
	END

	IF NOT EXISTS (
		SELECT 	IdProject
		FROM 	BUDGET_TOCOMPLETION_PROGRESS
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdAssociate = @IdAssociate
		AND 	IdWorkPackage = @IdWP
	)
	BEGIN
		INSERT INTO BUDGET_TOCOMPLETION_PROGRESS 
			(IdProject,   IdGeneration,   IdPhase,  IdWorkPackage, IdAssociate,  [Percent])
		VALUES (@IdProject,   @NewGeneration, @IdPhase, @IdWP,  @IdAssociate, @Percentage)
	END
	ELSE
	BEGIN
		UPDATE	BUDGET_TOCOMPLETION_PROGRESS
		SET 	[Percent] = @Percentage
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdAssociate = @IdAssociate
		AND 	IdWorkPackage = @IdWP
	END
GO

--Drops the Procedure bgtGetToCompletionBudgetHoursEvidence if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateToCompletionBudgetSales]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateToCompletionBudgetSales
GO

CREATE  PROCEDURE bgtUpdateToCompletionBudgetSales
	@IdAssociate		INT,
	@IdProject		INT,
	@IdPhase		INT,
	@IdWP			INT,
	@IdCostCenter		INT,
	@YearMonth		INT,
	@Sales			DECIMAL(18, 2),
	@ActualDataTimestamp	DATETIME
AS
	--Get the new generation Id
	DECLARE @NewGeneration		INT
	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'N')
	IF (@NewGeneration IS NULL)
	BEGIN
		RAISERROR('No new generation found for To Completion budget', 16, 1)
		RETURN
	END

	IF 
	(
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_HOURS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_SALES AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
		OR
		EXISTS 
		(
			SELECT 	I.ImportDate
			FROM	ACTUAL_DATA_DETAILS_COSTS AD
			INNER JOIN IMPORTS I ON
				AD.IdImport = I.IdImport
			WHERE 	AD.IdProject = @IdProject AND
				I.ImportDate > @ActualDataTimestamp
		)
	)
	BEGIN
		RAISERROR('Please reload your budget, the actual data your budget is based on has changed.', 16, 1)
		RETURN
	END

	IF NOT EXISTS (
		SELECT 
			IdProject
		FROM 	BUDGET_TOCOMPLETION_DETAIL
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth		
	)
	BEGIN
		DECLARE @IdCountry INT
		DECLARE @CountryName VARCHAR(30)
		DECLARE @CostCenterName VARCHAR(50)
		DECLARE @CountryHasDefaultAccounts BIT
	
		SELECT 	@IdCountry = C.[Id],
			@CountryName = C.[Name],
			@CostCenterName = CC.[Name]
		FROM 	COST_CENTERS CC
		INNER 	JOIN INERGY_LOCATIONS IL ON
			CC.IdInergyLocation = IL.[Id]
		INNER 	JOIN COUNTRIES C ON
			IL.IdCountry = C.[Id]
		WHERE 	CC.[Id] = @IdCostCenter
	
		SELECT @CountryHasDefaultAccounts = dbo.fnCheckCountryDefaultAccounts(@IdCountry)
	
		IF (@CountryHasDefaultAccounts = 0)
		BEGIN
			RAISERROR('You do not have all the default accounts for Country %s to which the Cost Center %s belongs in your G/L Account catalogue.', 16, 1, @CountryName, @CostCenterName)
			RETURN -3
		END
	
		DECLARE @IdAccountHours INT
		DECLARE @IdAccountSales INT
	
		--Select the account id for hours
		SELECT 	@IdAccountHours = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 6
	
		--Select the account id for sales
		SELECT 	@IdAccountSales = GLA.[Id]
		FROM 	GL_ACCOUNTS GLA
		INNER JOIN COST_INCOME_TYPES CIT ON
		GLA.Account = CIT.DefaultAccount
		WHERE	GLA.IdCountry = @IdCountry AND
			CIT.[Id] = 7


		INSERT INTO BUDGET_TOCOMPLETION_DETAIL 
			(IdProject,   IdGeneration,   IdPhase,  IdWorkPackage,  IdCostCenter,  IdAssociate,  YearMonth,  HoursQty, SalesVal, HoursVal,  IdCountry,  IdAccountHours,  IdAccountSales)
		VALUES (@IdProject,   @NewGeneration, @IdPhase, @IdWP         , @IdCostCenter, @IdAssociate, @YearMonth, NULL, 	   @Sales,   NULL,	@IdCountry, @IdAccountHours, @IdAccountSales)
	END
	ELSE
	BEGIN
		UPDATE 	BUDGET_TOCOMPLETION_DETAIL
		SET 	SalesVal = @Sales
		WHERE	IdProject = @IdProject
		AND	IdGeneration = @NewGeneration
		AND	IdPhase = @IdPhase
		AND	IdWorkPackage = @IdWP
		AND	IdCostCenter = @IdCostCenter
		AND	IdAssociate = @IdAssociate
		AND 	YearMonth = @YearMonth
	END
GO

--Drops the Procedure bgtUpdateToCompletionWPPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateToCompletionWPPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateToCompletionWPPeriod
GO
CREATE PROCEDURE bgtUpdateToCompletionWPPeriod
	@IdProjectParam	INT,		--The Id of the project
	@IdPhaseParam 	INT,		--The Id of the phase
	@IdWP		INT,		--The Id of the selected WorkPackage
	@StartYearMonth INT,		--The new startyearmonth of the workpackage
	@EndYearMonth	INT		--The new endyearmonth of the workpackage
AS
BEGIN
	-- two rules apply for this procedure
	--1. Validated versions do not update
	--2. Non-validated version, if they exists, will give error

	DECLARE @CountAssociates  int,
			@errMsg		varchar(255)

	SELECT @CountAssociates = Count (DISTINCT BCD.IdAssociate)
	FROM BUDGET_TOCOMPLETION_DETAIL BCD
	INNER JOIN BUDGET_TOCOMPLETION BT
		on BCD.IdProject = BT.IDProject and
		   BCD.IdGeneration = BT.IdGeneration
	WHERE 	BCD.IdProject = @IdProjectParam AND
			BCD.IdPhase = @IdPhaseParam AND
			BCD.IdWorkPackage = @IdWP AND
			BT.IsValidated = 0 --only for non validated versions	

	if (@CountAssociates > 0)
	BEGIN
		Declare @FullWpName varchar(40)
		SELECT @FullWpName = WP.Code + ' - ' + WP.Name
		FROM WORK_PACKAGES WP
		WHERE WP.IdProject = @IdProjectParam AND
			  WP.IdPhase = @IdPhaseParam AND
			  WP.Id = @IdWP

		set @errMsg = 'WP ''' + @FullWpName + ''' is used in InProgress reforecast by ' + cast(@CountAssociates as varchar(4)) + ' core team members. WP Period update aborted.'
		RAISERROR(@errMsg, 16, 1)
		RETURN -1
	END

END
GO

--Drops the Procedure bgtUpdateWPInterco if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateWPInterco]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateWPInterco
GO
CREATE PROCEDURE bgtUpdateWPInterco
	@IdProject		INT,		
	@IdPhase		INT,		
	@IdWP			INT,	
	@IdCountry		INT,	
	@Percent		DECIMAL(18,2),
	@WPCode			VARCHAR(3)
AS

	DECLARE	@ErrorMessage		VARCHAR(255)

	IF @WPCode IS NOT NULL AND NOT EXISTS(
			SELECT [Id] 
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND			      
			      IdPhase = @IdPhase AND
			      [Id] = @IdWP AND
			      Code = @WpCode
			)
	BEGIN
	SET @ErrorMessage = 'Key information about WP with code ' + @WPCode + '  has been changed by another user. Please refresh your information.'
	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	DECLARE @CurrentPercent DECIMAL
	SET @CurrentPercent = NULL

	SELECT
		@CurrentPercent = PercentAffected
	FROM PROJECTS_INTERCO
	WHERE 	IdProject= @IdProject AND
		IdPhase = @IdPhase AND
		[IdWorkPackage] = @IdWP AND
		IdCountry = @IdCountry
	
	IF (@CurrentPercent IS NULL) 
	BEGIN
		INSERT INTO PROJECTS_INTERCO 
			(IdProject,  IdPhase,  IdWorkPackage, IdCountry, PercentAffected,LastUpdate)
		VALUES	(@IdProject, @IdPhase, @IdWP,	     @IdCountry, @Percent,       GETDATE())
	END
	ELSE
	BEGIN
		IF (@Percent > 0)
		BEGIN
			UPDATE PROJECTS_INTERCO
			SET
				PercentAffected = @Percent
			WHERE 	IdProject= @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdCountry = @IdCountry
		END
		ELSE
		BEGIN
			DELETE FROM PROJECTS_INTERCO
			WHERE 	IdProject= @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdCountry = @IdCountry
		END
	END	
GO
--Drops the Procedure bgtUpdateWPTiming if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtUpdateWPTiming]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtUpdateWPTiming
GO
CREATE PROCEDURE bgtUpdateWPTiming
	@IdProject		INT,		
	@IdPhase		INT,		
	@IdWP			INT,		
	@StartYearMonth		INT,
	@EndYearMonth		INT,
	@LastUserUpdate		INT,
	@WPCode			VARCHAR(3)
AS

	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT
--validate that record tring to be updated exists in work_packages catalog
	IF @WPCode IS NOT NULL AND NOT EXISTS(
			SELECT [Id] 
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND			      
			      IdPhase = @IdPhase AND
			      [Id] = @IdWP AND
			      Code = @WpCode
			)
	BEGIN
	SET @ErrorMessage = 'Key information about WP with code ' + @WPCode + '  has been changed by another user. Please refresh your information.'
	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

--validation yearmonth section
	
	
	DECLARE @RetVal INT

	if (@StartYearMonth <> -1)
	BEGIN
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@StartYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -1
		end
	END

	if (@EndYearMonth <> -1)
	begin
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@EndYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -2
		end
	end
--end validation section


	--If this work package has data in any budget and the startYM or endYM is -1, raise an error
	IF 
	(
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_INITIAL_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
		OR
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_REVISED_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
		OR
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_TOCOMPLETION_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
	)
	BEGIN
		IF (@StartYearMonth = -1 OR @EndYearMonth = -1)
		BEGIN
			RAISERROR('This Work Package must have the period correctly defined because it contains budget data. ', 16, 1)
			RETURN -3
		END
	END


	--Check if the period has changed (the updated values of startyearmonth and endyearmonth are different than
	--the ones already saved in the database
	DECLARE @OldStartYearMonth INT
	DECLARE @OldEndYearMonth INT

	SELECT 	@OldStartYearMonth = StartYearMonth,
		@OldEndYearMonth = EndYearMonth
	FROM 	WORK_PACKAGES
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		[Id] = @IdWP
	
	IF (@OldStartYearMonth <> @StartYearMonth OR @OldEndYearMonth <> @EndYearMonth)
	BEGIN
		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_TOCOMPLETION_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase AND
					IdWorkPackage = @IdWP
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateToCompletionWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase, @IdWP = @IdWP, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -4
		END

		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_REVISED_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase AND
					IdWorkPackage = @IdWP
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateRevisedWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase, @IdWP = @IdWP, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR <> 0 OR @RetVal < 0)
				RETURN -5
		END

		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_INITIAL_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase AND
					IdWorkPackage = @IdWP
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateInitialWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase, @IdWP = @IdWP, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR <> 0 OR @RetVal < 0)
				RETURN -6
		END
	END

	DECLARE @Rowcount INT
	--We will always find a WP corresponding - no testing condition should be done
	
	UPDATE WORK_PACKAGES
	SET
		StartYearMonth = (CASE  
					WHEN @StartYearMonth = -1 THEN NULL
					ELSE @StartYearMonth
				END),
		EndYearMonth = (CASE  
					WHEN @EndYearMonth = -1 THEN NULL
					ELSE @EndYearMonth
				END),
		LastUserUpdate = @LastUserUpdate,
		LastUpdate = GETDATE()
	WHERE 	IdProject= @IdProject AND
		IdPhase = @IdPhase AND
		Id = @IdWP
	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
				
GO



--Drops the Procedure bgtValidateCompletionBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtValidateCompletionBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtValidateCompletionBudget
GO

-- bgtValidateCompletionBudget 18,'N'
CREATE PROCEDURE bgtValidateCompletionBudget
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)
				
AS
	
	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)	
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END	



	DECLARE @IdGeneration INT,
		@IsValidated  BIT
	SELECT  @IdGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,@BudVersion)

	--check to see if the budget is not already validated
	SELECT @IsValidated = IsValidated 
	FROM BUDGET_TOCOMPLETION (tablockx)
	WHERE IdProject = @IdProject and 
	      IdGeneration = @IdGeneration 

	IF (@IsValidated = 1)
	BEGIN 
		RAISERROR('To Completion budget is already validated.',16,1)		
		RETURN -3
	END 
	

	--Delete the data of the core team members that have worked on the budget but are now inactive (so
	--that their data won't be propagated into the Released version)
	DELETE BCDC 
	FROM BUDGET_TOCOMPLETION_DETAIL_COSTS BCDC
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BCDC.IdProject = PCT.IdProject AND
			BCDC.IdAssociate = PCT.IdAssociate
	WHERE 	BCDC.IdProject = @IdProject AND
			BCDC.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DELETE BCD 
	FROM BUDGET_TOCOMPLETION_DETAIL BCD
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BCD.IdProject = PCT.IdProject AND
			BCD.IdAssociate = PCT.IdAssociate
	WHERE 	BCD.IdProject = @IdProject AND
			BCD.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DELETE BCP 
	FROM BUDGET_TOCOMPLETION_PROGRESS BCP
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BCP.IdProject = PCT.IdProject AND
			BCP.IdAssociate = PCT.IdAssociate
	WHERE 	BCP.IdProject = @IdProject AND
			BCP.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DELETE BCS 
	FROM BUDGET_TOCOMPLETION_STATES BCS
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BCS.IdProject = PCT.IdProject AND
			BCS.IdAssociate = PCT.IdAssociate
	WHERE 	BCS.IdProject = @IdProject AND
			BCS.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	
	--read the validation date from OS
	DECLARE @ValidationDate smalldatetime
	SET @ValidationDate = GETDATE()

	--update all existing states to valid
	UPDATE BTS
	SET BTS.State = 'V',
	    BTS.StateDate = CASE WHEN ISNULL(BTS.State, 'N') = 'N' then ISNULL(BTS2.StateDate, @ValidationDate) ELSE @ValidationDate END
	FROM BUDGET_TOCOMPLETION_STATES BTS
	LEFT JOIN BUDGET_TOCOMPLETION_STATES BTS2
		on BTS.IdProject = BTS2.IdProject and
		   BTS.IdGeneration = BTS2.IdGeneration and
		   BTS.IdAssociate = BTS2.IdAssociate
	WHERE BTS.IdProject = @IdProject AND 
	      BTS.IdGeneration = @IdGeneration


	-- update the Yearmonth Actual Data column with the last actual data found in actual tables at the moment of validation.
	-- the user must see the situation of actual/tocompletion as it was at the date of validation
	DECLARE @YearMonthActualData INT
	SET @YearMonthActualData =  dbo.fnGetYearMonthOfPreviousMonth(getdate())


	UPDATE BUDGET_TOCOMPLETION
	SET YearMonthActualData = @YearMonthActualData
	WHERE IdProject = @IdProject AND 
	      IdGeneration = @IdGeneration 

	--validate the budget
	UPDATE BUDGET_TOCOMPLETION
	SET IsValidated=1, 
	    ValidationDate=@ValidationDate
	WHERE IdProject=@IdProject AND
	      IdGeneration = @IdGeneration 


GO






--Drops the Procedure bgtValidateInitialBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bgtValidateInitialBudget]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtValidateInitialBudget
GO


CREATE    PROCEDURE bgtValidateInitialBudget
	@IdProject 	INT 	--Id of the Project
AS

	Declare @IsValidated bit

	--read the validation date from OS
	DECLARE @ValidationDate smalldatetime
	SET @ValidationDate = GETDATE()

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected.',16,1)		
		RETURN -1
	END 

	--check if the project is already validated - read the state for one of the associates
	SELECT @IsValidated = IsValidated 
	FROM BUDGET_INITIAL (tablockx)
	WHERE IdProject = @IdProject

	IF (@IsValidated = 1)
	BEGIN 
		RAISERROR('Initial budget is already validated.',16,1)		
		RETURN -2
	END 

	--Delete the data of the core team members that have worked on the budget but are now inactive (so
	--that their data won't be copied to revised and reforecast)
	DELETE BIDC 
	FROM BUDGET_INITIAL_DETAIL_COSTS BIDC
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BIDC.IdProject = PCT.IdProject AND
			BIDC.IdAssociate = PCT.IdAssociate
	WHERE 	BIDC.IdProject = @IdProject AND
			PCT.IsActive = 0

	DELETE BID 
	FROM BUDGET_INITIAL_DETAIL BID
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BID.IdProject = PCT.IdProject AND
			BID.IdAssociate = PCT.IdAssociate
	WHERE 	BID.IdProject = @IdProject AND
			PCT.IsActive = 0

	DELETE BIS 
	FROM BUDGET_INITIAL_STATES BIS
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BIS.IdProject = PCT.IdProject AND
			BIS.IdAssociate = PCT.IdAssociate
	WHERE 	BIS.IdProject = @IdProject AND
			PCT.IsActive = 0

	
	--update only existing records with V state
	UPDATE
		BUDGET_INITIAL_STATES
	SET 		
		StateDate = CASE WHEN (ISNULL(State,'N') = 'N' or ISNULL(State,'N') = 'V') then StateDate else @ValidationDate end,
		State = 'V'
	WHERE 	IdProject = @IdProject

	UPDATE
		BUDGET_INITIAL
	SET 	
		IsValidated = 1,
		ValidationDate = @ValidationDate
	WHERE	IdProject = @IdProject



	--COPY BUDGET_INITIAL TO REVISED
	INSERT INTO [BUDGET_REVISED]
	([IdProject], [IdGeneration], [IsValidated], [ValidationDate])
	SELECT BI.[IdProject], 1, BI.[IsValidated], @ValidationDate
	FROM [BUDGET_INITIAL] BI
	WHERE BI.[IdProject]  = @IdProject

	--COPY BUDGET_INITIAL_DETAIL TO REVISED
	INSERT INTO [BUDGET_REVISED_DETAIL]
	(
		[IdProject], [IdGeneration], [IdPhase], 
		[IdWorkPackage], [IdCostCenter], [IdAssociate],
		[YearMonth], [HoursQty], [HoursVal], [SalesVal],
		[IdCountry], [IdAccountHours], [IdAccountSales]
	)
	SELECT   
		BID.[IdProject], 
		1, 
		BID.[IdPhase],
		BID.[IdWorkPackage],
		BID.[IdCostCenter], 
		BID.[IdAssociate],
		BID.[YearMonth],
		BID.[HoursQty], 
		BID.HoursVal, 
		BID.[SalesVal],
		BID.[IdCountry],
		BID.[IdAccountHours],
		BID.[IdAccountSales]
	FROM [BUDGET_INITIAL_DETAIL] BID
	INNER JOIN WORK_PACKAGES WP ON
		BID.IdProject = WP.IdProject AND
		BID.IdPhase = WP.IdPhase AND
		BID.IDWorkPackage = WP.[Id]
	WHERE 	BID.[IdProject] =  @IdProject AND
		WP.IsActive = 1

	--COPY BUDGET_INITIAL_DETAIL_COSTS
	INSERT INTO [BUDGET_REVISED_DETAIL_COSTS]
	(
		 [IdProject], [IdGeneration], [IdPhase],
		 [IdWorkPackage], [IdCostCenter], [IdAssociate],
		 [YearMonth], [IdCostType], [CostVal],
		 [IdCountry], [IdAccount]
	)
	SELECT BIDC.[IdProject], 1, BIDC.[IdPhase],
	       BIDC.[IdWorkPackage], BIDC.[IdCostCenter], BIDC.[IdAssociate],
	       BIDC.[YearMonth], BIDC.[IdCostType], BIDC.[CostVal],
	       BIDC.[IdCountry], BIDC.[IdAccount]
	FROM [BUDGET_INITIAL_DETAIL_COSTS] BIDC
	INNER JOIN WORK_PACKAGES WP ON
		BIDC.IdProject = WP.IdProject AND
		BIDC.IdPhase = WP.IdPhase AND
		BIDC.IDWorkPackage = WP.[Id]
	WHERE 	BIDC.[IdProject] = @IdProject AND
		WP.IsActive = 1


	-- COPY BUDGET_INITIAL_STATES TO REVISED
	INSERT INTO [BUDGET_REVISED_STATES]
	(
		[IdProject], [IdGeneration], [IdAssociate],
		 [State], [StateDate]
	)

	SELECT   BIS.[IdProject],1, BIS.[IdAssociate],
		 BIS.[State], BIS.[StateDate] 
	FROM [BUDGET_INITIAL_STATES] BIS
	WHERE BIS.[IdProject] = @IdProject


	
	-- COPY TO TO COMPLETION BUDGET --------------------------------------------------------------------

	--COPY BUDGET_INITIAL TO TOCOMPLETION
	--YearMonthActualData is on purpose set to null in order to mantain the equality of 
	--INITIAL = VERSION 1 of revised = VERSION 1 of Reforecst
	INSERT INTO BUDGET_TOCOMPLETION
		(IdProject, IdGeneration, IsValidated, ValidationDate, YearMonthActualData)
	SELECT BI.IdProject, 1, BI.IsValidated, BI.ValidationDate, NULL --user must 
	FROM BUDGET_INITIAL AS BI
	WHERE BI.IdProject  = @IdProject

	--INSERT INTO TOCOMPLETION_PREOGRESS
	INSERT INTO BUDGET_TOCOMPLETION_PROGRESS
		(IdProject, IdGeneration, IdPhase, [Percent], IdAssociate, IdWorkPackage)
	SELECT DISTINCT BID.IdProject, 1, BID.IdPhase, NULL, BID.IdAssociate, BID.IdWorkPackage
	FROM BUDGET_INITIAL_DETAIL BID
	INNER JOIN WORK_PACKAGES WP ON
		BID.IdProject = WP.IdProject AND
		BID.IdPhase = WP.IdPhase AND
		BID.IDWorkPackage = WP.[Id]
	WHERE 	BID.IdProject =  @IdProject AND
		WP.IsActive = 1

	--COPY BUDGET_INITIAL_DETAIL TO TO_COMPLETION_DETAIL
	INSERT INTO BUDGET_TOCOMPLETION_DETAIL
	(
		IdProject, IdGeneration, IdPhase, IdWorkPackage, 
		IdCostCenter,      IdAssociate,   YearMonth,
		HoursQty,     HoursVal,     SalesVal,
		[IdCountry], [IdAccountHours], [IdAccountSales]
	)
	SELECT	
		BID.IdProject, 
		1, 
		BID.IdPhase,
		BID.IdWorkPackage,
		BID.IdCostCenter,
		BID.IdAssociate,
		BID.YearMonth,
		BID.HoursQty,
		BID.HoursVal, 
		BID.SalesVal,
		BID.[IdCountry],
		BID.[IdAccountHours],
		BID.[IdAccountSales]
	FROM BUDGET_INITIAL_DETAIL BID
	INNER JOIN WORK_PACKAGES WP ON
		BID.IdProject = WP.IdProject AND
		BID.IdPhase = WP.IdPhase AND
		BID.IDWorkPackage = WP.[Id]
	WHERE 	BID.IdProject =  @IdProject AND
		WP.IsActive = 1

	--COPY BUDGET_INITIAL_DETAIL_COSTS TO TOCOMPLETION_DETAIL_COSTS
	INSERT INTO BUDGET_TOCOMPLETION_DETAIL_COSTS
	(
		IdProject, IdGeneration, IdPhase, IdWorkPackage, 
		IdCostCenter,       IdAssociate,     YearMonth,
		IdCostType,     CostVal, [IdCountry], [IdAccount]
	)
	SELECT 	BIDC.IdProject, 1, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter,
		BIDC.IdAssociate, BIDC.YearMonth, BIDC.IdCostType, BIDC.CostVal,
	       	BIDC.[IdCountry], BIDC.[IdAccount]
	FROM BUDGET_INITIAL_DETAIL_COSTS BIDC
	INNER JOIN WORK_PACKAGES WP ON
		BIDC.IdProject = WP.IdProject AND
		BIDC.IdPhase = WP.IdPhase AND
		BIDC.IDWorkPackage = WP.[Id]
	WHERE 	BIDC.IdProject = @IdProject AND
		WP.IsActive = 1

	-- COPY BUDGET_INITIAL_STATES TO TOCOMPLETION
	INSERT INTO BUDGET_TOCOMPLETION_STATES
	(
		IdProject, IdGeneration, IdAssociate, State, StateDate
	)
	SELECT   BIS.IdProject,1, BIS.IdAssociate, BIS.State, BIS.StateDate 
	FROM BUDGET_INITIAL_STATES BIS
	WHERE BIS.[IdProject] = @IdProject
	
GO


--Drops the Procedure bgtValidateRevisedBudget if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.bgtValidateRevisedBudget') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bgtValidateRevisedBudget
GO

-- bgtValidateRevisedBudget 18,'N'
CREATE PROCEDURE bgtValidateRevisedBudget
	@IdProject 		AS INT,
	@BudVersion		AS CHAR(1)
				
AS

	IF (@IdProject < 0 )
	BEGIN 
		RAISERROR('No project has been selected',16,1)		
		RETURN -1
	END 
	IF (@BudVersion IS NULL )
	BEGIN 
		RAISERROR('No budget version has been selected',16,1)		
		RETURN -2
	END	


	DECLARE @IdGeneration INT,
		@IsValidated  BIT

	SELECT  @IdGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,@BudVersion)

	--check to see if the budget is not already validated
	SELECT @IsValidated = IsValidated 
	FROM BUDGET_REVISED (tablockx)
	WHERE IdProject = @IdProject and 
	      IdGeneration = @IdGeneration 

	IF (@IsValidated = 1)
	BEGIN 
		RAISERROR('Revised budget is already validated.',16,1)		
		RETURN -3
	END 
	
	--Delete the data of the core team members that have worked on the budget but are now inactive (so
	--that their data won't be propagated into the Released version)
	DELETE BRDC 
	FROM BUDGET_REVISED_DETAIL_COSTS BRDC
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BRDC.IdProject = PCT.IdProject AND
			BRDC.IdAssociate = PCT.IdAssociate
	WHERE 	BRDC.IdProject = @IdProject AND
			BRDC.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DELETE BRD 
	FROM BUDGET_REVISED_DETAIL BRD
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON  BRD.IdProject = PCT.IdProject AND
			BRD.IdAssociate = PCT.IdAssociate
	WHERE 	BRD.IdProject = @IdProject AND
			BRD.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DELETE BRS 
	FROM BUDGET_REVISED_STATES BRS
	INNER JOIN PROJECT_CORE_TEAMS PCT 
		ON	BRS.IdProject = PCT.IdProject AND
			BRS.IdAssociate = PCT.IdAssociate
	WHERE 	BRS.IdProject = @IdProject AND
			BRS.IdGeneration = @IdGeneration AND
			PCT.IsActive = 0

	DECLARE @ValidationDate smalldatetime
	SET @ValidationDate = GETDATE()

	--update all existing states to valid
	UPDATE BRS
	SET BRS.State = 'V',
	    BRS.StateDate = CASE WHEN ISNULL(BRS.State, 'N') = 'N' then ISNULL(BRS2.StateDate, @ValidationDate) ELSE @ValidationDate END
	FROM BUDGET_REVISED_STATES BRS
	LEFT JOIN BUDGET_REVISED_STATES BRS2
		on BRS.IdProject = BRS2.IdProject and
		   BRS.IdGeneration = BRS2.IdGeneration and
		   BRS.IdAssociate = BRS2.IdAssociate
	WHERE BRS.IdProject = @IdProject AND 
	      BRS.IdGeneration = @IdGeneration


	--make the budget valid
	UPDATE BUDGET_REVISED
	SET IsValidated=1, 
		ValidationDate=@ValidationDate
	WHERE IdProject=@IdProject AND 
		  IdGeneration = @IdGeneration 


GO






--Drops the Procedure bpsDeleteInitialBudgetWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsDeleteInitialBudgetWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsDeleteInitialBudgetWPInfo
GO
CREATE PROCEDURE bpsDeleteInitialBudgetWPInfo
	@IdProject 		AS INT, 		--The Id of the Project
	@IdPhase		AS INT,			--The Id of the Phase
	@IdWP			AS INT,			--The Id of the WP
	@IdAssociate	AS INT,			--The Id of the associate
	@WPCode			AS VARCHAR(3)
AS
BEGIN

	DECLARE @ErrorMessage varchar(255)
	DECLARE @retVal	INT
	
	IF NOT EXISTS (SELECT Id
				   FROM WORK_PACKAGES
					WHERE IdProject = @IdProject AND
						  IdPhase	= @IdPhase AND
						  Id = @IdWP
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	--delete initial budget detail other costs
	DELETE FROM BUDGET_INITIAL_DETAIL_COSTS 
	WHERE IdProject = @IdProject
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdAssociate = @IdAssociate

	--delete initial budget detail
	DELETE FROM BUDGET_INITIAL_DETAIL
	WHERE IdProject = @IdProject
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdAssociate = @IdAssociate

END
GO

--Drops the Procedure bpsDeleteReforecastWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsDeleteReforecastWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsDeleteReforecastWPInfo
GO
CREATE PROCEDURE bpsDeleteReforecastWPInfo
	@IdProject 			AS INT, 	--The Id of the Project
	@IdPhase			AS INT,		--The Id of the Phase
	@IdWP				AS INT,		--The Id of the WP
	@IdAssociate		AS INT,		--The Id of the associate
	@WPCode				AS VARCHAR(3)
AS
BEGIN

	DECLARE @NewGeneration INT
	DECLARE @CurrentGeneration INT

	DECLARE @ErrorMessage varchar(255)
	DECLARE @retVal	INT
	
	IF NOT EXISTS (
			SELECT [Id]
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND
			      IdPhase	= @IdPhase AND
			      Id = @IdWP
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -4
	END

	SET @NewGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'N')
	SET @CurrentGeneration = dbo.fnGetToCompletionBudgetGeneration(@IdProject,'C')
	
	IF (@CurrentGeneration IS NULL)
	BEGIN
		RAISERROR('No released version found for reforecast budget.', 16, 1)
		RETURN -5
	END

	IF (@NewGeneration IS NULL)		
	BEGIN
		SET @NewGeneration = @CurrentGeneration + 1

		EXEC @retVal = bgtToCompletionBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @retVal	< 0)
			RETURN -6
	END
	
	EXEC @retVal = bgtUpdateCompletionBudgetStates @IdProject = @IdProject, @BudVersion = 'N', @IdAssociate = @IdAssociate, @State = 'O'
	IF (@@ERROR <> 0 OR @retVal	< 0)
		RETURN -7

	DELETE FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
	WHERE 	IdProject = @IdProject AND
		IdGeneration = @NewGeneration AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdAssociate = @IdAssociate

	DELETE FROM BUDGET_TOCOMPLETION_DETAIL
	WHERE 	IdProject = @IdProject AND
		IdGeneration = @NewGeneration AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdAssociate = @IdAssociate
	
	DELETE 	FROM BUDGET_TOCOMPLETION_PROGRESS
	WHERE 	IdProject = @IdProject AND
		IdGeneration = @NewGeneration AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdAssociate = @IdAssociate

END
GO

--Drops the Procedure bpsDeleteRevisedBudgetWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsDeleteRevisedBudgetWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsDeleteRevisedBudgetWPInfo
GO
CREATE PROCEDURE bpsDeleteRevisedBudgetWPInfo
	@IdProject 		AS INT, 	--The Id of the Project
	@IdPhase		AS INT,		--The Id of the Phase
	@IdWP			AS INT,		--The Id of the WP
	@IdAssociate	AS INT,		--The Id of the associate
	@WPCode			AS VARCHAR(3)
AS
BEGIN

	DECLARE @NewGeneration INT
	DECLARE @CurrentGeneration INT

	DECLARE @ErrorMessage varchar(255)
	DECLARE @retVal	INT
	
	IF NOT EXISTS (
			SELECT [Id]
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND
			      IdPhase	= @IdPhase AND
			      Id = @IdWP
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	END

	SET @NewGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, 'N')
	SET @CurrentGeneration = dbo.fnGetRevisedBudgetGeneration(@IdProject,'C')

	IF (@CurrentGeneration IS NULL)
	BEGIN
		RAISERROR('No released version found for revised budget.', 16, 1)
		RETURN -2
	END
	
	
	IF (@NewGeneration IS NULL)
	BEGIN
		SET @NewGeneration = @CurrentGeneration + 1
	
		EXEC @retVal = bgtRevisedBudgetCreateNewFromCurrentAll @IdProject = @IdProject, @NewGeneration = @NewGeneration
		IF (@@ERROR <> 0 OR @retVal	< 0)
			RETURN -3
	END
	
	EXEC @retVal = bgtUpdateRevisedBudgetStates @IdProject = @IdProject, @BudVersion = 'N', @IdAssociate = @IdAssociate, @State = 'O'
	IF (@@ERROR <> 0 OR @retVal	< 0)
		RETURN -4
		
	DECLARE @CurrentHours INT
	DECLARE @CurrentVal DECIMAL(18, 4)  
	DECLARE @CurrentSales DECIMAL(18, 4)
	DECLARE @CurrentCosts DECIMAL(18, 2)


	--isnull works here because the value is used only for checking
	SELECT 	@CurrentHours = SUM(ISNULL(HoursQty, 0)),
			@CurrentVal = SUM(ISNULL(HoursVal, 0)),
			@CurrentSales = SUM(ISNULL(SalesVal, 0))
	FROM 	BUDGET_REVISED_DETAIL
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdAssociate = @IdAssociate AND
		IdGeneration = @CurrentGeneration

	SELECT 	@CurrentCosts = SUM(ISNULL(CostVal, 0))
	FROM 	BUDGET_REVISED_DETAIL_COSTS
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		IdWorkPackage = @IdWP AND
		IdAssociate = @IdAssociate AND
		IdGeneration = @CurrentGeneration

	IF (ISNULL(@CurrentHours, 0) <> 0 OR
		ISNULL(@CurrentVal, 0) <> 0 OR
		ISNULL(@CurrentSales, 0) <> 0 OR
		ISNULL(@CurrentCosts, 0) <> 0)
	BEGIN
		DECLARE @wpName varchar(36)
		DECLARE @err varchar(255)

		SELECT @wpName = WP.[Code] + ' - '+WP.[Name]
		FROM WORK_PACKAGES WP
		WHERE 	WP.IdProject = @IdProject AND
				WP.IdPhase = @IdPhase AND
				WP.Id = @IdWP

		SET @err ='Work Package '+@wpName+' cannot be deleted because it is used in Released version.' 
		RAISERROR(@err, 16, 1)
		RETURN -5
	END		
	
	--delete initial budget detail other costs
	DELETE FROM BUDGET_REVISED_DETAIL_COSTS 
	WHERE IdProject = @IdProject
		AND IdGeneration = @NewGeneration
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdAssociate = @IdAssociate
	
	--delete initial budget detail
	DELETE FROM BUDGET_REVISED_DETAIL
	WHERE IdProject = @IdProject
		AND IdGeneration = @NewGeneration
		AND IdPhase = @IdPhase
		AND IdWorkPackage = @IdWP
		AND IdAssociate = @IdAssociate
		
	
END
GO

--Drops the Procedure bpsSelectInitialBudgetWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectInitialBudgetWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectInitialBudgetWPInfo
GO
CREATE PROCEDURE bpsSelectInitialBudgetWPInfo
	@IdProject	AS INT, 	--The Id of the Project
	@IdPhase	AS INT,		--The Id of the Phase
	@IdWP		AS INT,		--The Id of the Work Package
	@BudgetVersion	AS CHAR(1) = NULL,	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate	AS INT,
	@WPCode		AS VARCHAR(3)
AS

	DECLARE @ErrorMessage varchar(255)
	IF NULLIF(@WPCode, '') IS NOT NULL AND NOT EXISTS (
			SELECT [Id]
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND
			      IdPhase	= @IdPhase AND
			      [Id]	= @IdWP AND
			      Code	= @WPCode
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'	
		RAISERROR(@ErrorMessage, 16, 1)
	
	END

	DECLARE @BudgetGeneration INT
	DECLARE @HasBudget BIT
	DECLARE @HasActualOrRevisedData BIT

	SET @HasBudget = 0
	SET @HasActualOrRevisedData = 0

	IF EXISTS
	(
		SELECT 	IdProject
		FROM	BUDGET_INITIAL_DETAIL
		WHERE	IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SET @HasBudget = 1
	END

	SELECT 	WP.IdProject 						AS 'IdProject',
			WP.IdPhase 							AS 'IdPhase',
			WP.[Id]								AS 'IdWP',
			[PH].[Code] + ' - ' + [PH].[Name]	AS 'PhaseName',
			[WP].Code + ' - ' + [WP].Name		AS 'WPName',
			[WP].Code							AS 'WPCode',
			WP.StartYearMonth					AS 'StartYearMonth',
			WP.EndYearMonth						AS 'EndYearMonth',
			WP.IsActive		 					AS 	'IsActive',
			CAST (CASE 	WHEN (PJI.PercentAffected IS NOT NULL and
							 WP.StartYearMonth IS NOT NULL AND
							 WP.EndYearMonth IS NOT NULL) THEN 1 
				  ELSE 0 END AS BIT)			AS 'HasPeriodAndInterco',
			@HasBudget							AS 'HasBudget',
			@HasActualOrRevisedData				AS 'HasActualOrRevisedData'
			FROM WORK_PACKAGES AS WP
			INNER JOIN PROJECT_PHASES PH 
				ON WP.IdPhase = PH.Id
			LEFT JOIN PROJECTS_INTERCO AS PJI 
				ON 	PJI.IdProject = WP.IdProject AND
					PJI.IdPhase = WP.IdPhase AND
					PJI.IdWorkPackage = WP.Id 
	WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id	= @IdWP
GO

--Drops the Procedure bpsSelectInitialBudgetWPUnused if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectInitialBudgetWPUnused]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectInitialBudgetWPUnused
GO
CREATE PROCEDURE bpsSelectInitialBudgetWPUnused
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N' only when coming from Follow-up
	@IdAssociate		AS INT,
	@ActiveState		AS CHAR(1)
AS
BEGIN

	SELECT *
	INTO #TempTableIni
	FROM 
		(SELECT DISTINCT
			WP.IdProject 		AS	'IdProjectT1',
			WP.IdPhase			AS	'IdPhaseT1',
			WP.Id				AS	'IdWPT1',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT1'
		FROM WORK_PACKAGES AS WP
		WHERE WP.IdProject = @IdProject AND
	 		WP.IsActive = CASE 	WHEN @ActiveState = 'A' THEN 1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END
			) AS AllWP
		LEFT JOIN 
		(
		--Gets the detail table for WP Preselection functionality
		SELECT DISTINCT
			WP.IdProject 		AS	'IdProjectT2',
			WP.IdPhase		AS	'IdPhaseT2',
			WP.Id		AS	'IdWPT2',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT2'
		FROM WORK_PACKAGES AS WP
		--This join is used to get the work packages for which data exists in the initial budget
		INNER JOIN BUDGET_INITIAL_DETAIL AS BID ON
			WP.IdProject = BID.IdProject AND
			WP.IdPhase = BID.IdPhase AND
			WP.Id = BID.IdWorkPackage
		WHERE WP.IdProject = @IdProject AND
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN 1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END
			AND BID.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BID.IdAssociate
								ELSE @IdAssociate END
		) AS UsedWP
	ON 	AllWP.IdProjectT1 = UsedWP.IdProjectT2 AND
		AllWP.IdPhaseT1 = UsedWP.IdPhaseT2 AND
		AllWP.IdWPT1 = UsedWP.IdWPT2

	SELECT	IdProjectT1 AS 'IdProject',
			IdPhaseT1 AS 'IdPhase',
			IdWPT1 AS 'IdWP',
			WPNameT1 AS 'WPName'
	FROM 	#TempTableIni
	WHERE	IdProjectT2 IS NULL AND
			IdPhaseT2 IS NULL AND
			IdWPT2 IS NULL		

END
GO

--Drops the Procedure bpsSelectInitialBudgetWPUsed if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectInitialBudgetWPUsed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectInitialBudgetWPUsed
GO
CREATE PROCEDURE bpsSelectInitialBudgetWPUsed
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate 		AS INT,		
	@ActiveState		AS CHAR(1)
AS
BEGIN
	
	--Gets the master table for WP Preselection functionality. This table contains only information
	-- about the phases. 
	SELECT DISTINCT
		PH.Id						AS	'IdPhase',
		PH.Code + ' - ' + PH.Name	AS	'PhaseName'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.Id
	--This join is used to get the phases of the work packages for which data exists in the initial budget
	INNER JOIN BUDGET_INITIAL_DETAIL AS BID ON
		WP.IdProject = BID.IdProject AND
		WP.IdPhase = BID.IdPhase AND
		WP.Id = BID.IdWorkPackage
	WHERE WP.IdProject = @IdProject AND
		WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
							WHEN @ActiveState = 'I' THEN 0
							WHEN @ActiveState = 'L' THEN WP.IsActive END AND
		BID.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BID.IdAssociate
						  ELSE @IdAssociate END
	

	--Gets the detail table for WP Preselection functionality
	SELECT DISTINCT
		WP.IdProject 		AS	'IdProject',
		WP.IdPhase		AS	'IdPhase',
		PH.Name		AS	'PhaseName',
		WP.Id		AS	'IdWP',
		WP.Code + ' - ' + WP.Name		AS	'WPName',
		WP.StartYearMonth	AS	'StartYearMonth',
		WP.EndYearMonth	AS	'EndYearMonth',
		WP.IsActive 		AS 	'IsActive',
		CAST (CASE WHEN (PJI.PercentAffected IS NOT NULL AND
						 WP.StartYearMonth IS NOT NULL AND
						 WP.EndYearMonth IS NOT NULL) THEN 1
				   ELSE 0 END AS BIT) AS	'HasPeriodAndInterco',
		CAST (1 AS BIT)			AS 	'HasBudget',
		CAST (0 AS BIT) 		AS 	'HasActualOrRevisedData'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.Id
	--This join is used to get the work packages for which data exists in the initial budget
	INNER JOIN BUDGET_INITIAL_DETAIL AS BID ON
		WP.IdProject = BID.IdProject AND
		WP.IdPhase = BID.IdPhase AND
		WP.Id = BID.IdWorkPackage
	LEFT JOIN PROJECTS_INTERCO AS PJI 
		ON 	PJI.IdProject = WP.IdProject AND
			PJI.IdPhase = WP.IdPhase AND
			PJI.IdWorkPackage = WP.Id
	WHERE WP.IdProject = @IdProject AND
		WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
							WHEN @ActiveState = 'I' THEN 0
							WHEN @ActiveState = 'L' THEN WP.IsActive END AND
		BID.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BID.IdAssociate
								ELSE @IdAssociate END

END
GO

--Drops the Procedure bpsSelectReforecastWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectReforecastWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectReforecastWPInfo
GO
CREATE PROCEDURE bpsSelectReforecastWPInfo
	@IdProject	AS INT, 				--The Id of the Project
	@IdPhase	AS INT,					--The Id of the Phase
	@IdWP		AS INT,					--The Id of the Work Package
	@BudgetVersion	AS CHAR(1) = NULL,	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate	AS INT,
	@WPCode		AS VARCHAR(3)
AS
	DECLARE @ErrorMessage varchar(255)
	IF NULLIF(@WPCode, '') IS NOT NULL AND NOT EXISTS (
			SELECT [Id]
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND
			      IdPhase	= @IdPhase AND
			      Id	= @IdWP AND
			      Code	= @WPCode
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'	
		RAISERROR(@ErrorMessage, 16, 1)
	
	END

	DECLARE @BudgetGeneration INT
	DECLARE @HasBudget BIT
	DECLARE @HasActualOrRevisedData BIT

	SET @HasBudget = 0
	SET @HasActualOrRevisedData = 0

	SET @BudgetGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, @BudgetVersion)

	--If no InProgress generation was found, get the Released generation
	IF (@BudgetGeneration IS NULL AND @BudgetVersion = 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'C')
	END

	IF EXISTS
	(
		SELECT 	IdProject
		FROM	BUDGET_TOCOMPLETION_DETAIL
		WHERE	IdProject = @IdProject AND
			IdGeneration = @BudgetGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SET @HasBudget = 1
	END

	DECLARE @RevisedCurrentGeneration INT
	SET @RevisedCurrentGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, 'C')
	IF 
	(
		EXISTS
		(
			SELECT 	IdProject
			FROM	ACTUAL_DATA_DETAILS_HOURS
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM	ACTUAL_DATA_DETAILS_SALES
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM	ACTUAL_DATA_DETAILS_COSTS
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM 	BUDGET_REVISED_DETAIL
			WHERE	IdProject = @IdProject AND
				IdGeneration = @RevisedCurrentGeneration AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
				IdAssociate = @IdAssociate
		)
	)
	BEGIN
		SET @HasActualOrRevisedData = 1
	END


	SELECT 	WP.IdProject				AS 'IdProject',
			WP.IdPhase 					AS 'IdPhase',
			WP.Id						AS 'IdWP',
			PH.Code + ' - ' + PH.Name	AS 'PhaseName',
			WP.Code + ' - ' + WP.Name	AS 'WPName',
			WP.Code						AS 'WPCode',
			WP.StartYearMonth			AS 'StartYearMonth',
			WP.EndYearMonth				AS 'EndYearMonth',
			WP.IsActive		 			AS 	'IsActive',
			CAST (CASE WHEN (PJI.PercentAffected IS NOT NULL AND
							 WP.StartYearMonth IS NOT NULL AND
							 WP.EndYearMonth IS NOT NULL) THEN 1
				ELSE 0 END AS BIT)		AS 'HasPeriodAndInterco',
			@HasBudget					AS 'HasBudget',
			@HasActualOrRevisedData		AS 'HasActualOrRevisedData'
		FROM WORK_PACKAGES AS WP
		INNER JOIN PROJECT_PHASES PH 
			ON WP.IdPhase = PH.Id
		LEFT JOIN PROJECTS_INTERCO AS PJI
			ON PJI.IdProject = WP.IdProject AND
			   PJI.IdPhase = WP.IdPhase AND
			   PJI.IdWorkPackage = WP.Id 
	WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id	= @IdWP
GO

--Drops the Procedure bpsSelectReforecastWPUnused if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectReforecastWPUnused]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectReforecastWPUnused
GO
CREATE PROCEDURE bpsSelectReforecastWPUnused
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N' only when coming from Follow-up
	@IdAssociate		AS INT,
	@ActiveState		AS CHAR(1)
AS
BEGIN
	DECLARE @BudgetGeneration INT

	IF (@BudgetVersion <> 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, @BudgetVersion)
	END
	ELSE
	BEGIN
		SELECT 	@BudgetGeneration = MAX(IdGeneration)
		FROM 	BUDGET_TOCOMPLETION_STATES BTS
		WHERE 	IdProject = @IdProject AND
			IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTS.IdAssociate ELSE @IdAssociate END AND
			State <> 'V'

		--If no new generation was found, get the released generation
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SELECT 	@BudgetGeneration = MAX(IdGeneration)
			FROM 	BUDGET_TOCOMPLETION_STATES BTS
			WHERE 	IdProject = @IdProject AND
				IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTS.IdAssociate ELSE @IdAssociate END AND
				State = 'V'
		END

		--If the budget generation is still null (when no released version exists for the given user, because he
		--was added to the project at this moment and he has no budget whatsoever), get the generation using
		--dbo.fnGetToCompletionBudgetGeneration function
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SET @BudgetGeneration = ISNULL(dbo.fnGetToCompletionBudgetGeneration (@IdProject, @BudgetVersion), dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'C'))
		END
	END

	IF (@BudgetGeneration IS NULL)
	BEGIN
		RAISERROR('Budget version %s does not exist.', 16, 1, @BudgetVersion)
		RETURN
	END

	SELECT * INTO #TempTableRef
	FROM 
		(SELECT DISTINCT
			WP.IdProject 				AS	'IdProjectT1',
			WP.IdPhase					AS	'IdPhaseT1',
			WP.Id						AS	'IdWPT1',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT1'
		FROM WORK_PACKAGES AS WP
		WHERE WP.IdProject = @IdProject AND
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END
			) AS AllWP
	LEFT JOIN		
	(
		SELECT DISTINCT
			WP.IdProject 				AS	'IdProjectT2',
			WP.IdPhase					AS	'IdPhaseT2',
			WP.Id						AS	'IdWPT2',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT2'
		FROM WORK_PACKAGES AS WP
		--This join is used to get the work packages for which data exists in the revised budget
		INNER JOIN BUDGET_TOCOMPLETION_DETAIL AS BTD ON
			WP.IdProject = BTD.IdProject AND
			WP.IdPhase = BTD.IdPhase AND
			WP.Id = BTD.IdWorkPackage
		LEFT JOIN BUDGET_TOCOMPLETION_DETAIL_COSTS AS BTDC ON
			BTDC.IdProject = BTD.IdProject AND
			BTDC.IdGeneration = BTD.IdGeneration AND
			BTDC.IdPhase = BTD.IdPhase AND
			BTDC.IdWorkPackage = BTD.IdWorkPackage AND
			BTDC.IdCostCenter = BTD.IdCostCenter AND
			BTDC.IdAssociate = BTD.IdAssociate AND
			BTDC.YearMonth = BTD.YearMonth
		WHERE 	WP.IdProject = @IdProject AND
				WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
									WHEN @ActiveState = 'I' THEN 0
									WHEN @ActiveState = 'L' THEN WP.IsActive END AND
				BTD.IdGeneration = @BudgetGeneration AND
				BTD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate
								ELSE @IdAssociate END 
	) AS UsedWP
	ON 	AllWP.IdProjectT1 = UsedWP.IdProjectT2 AND
		AllWP.IdPhaseT1 = UsedWP.IdPhaseT2 AND
		AllWP.IdWPT1 = UsedWP.IdWPT2
	
	SELECT	IdProjectT1 AS 'IdProject',
		IdPhaseT1 AS 'IdPhase',
		IdWPT1 AS 'IdWP',
		WPNameT1 AS 'WPName'
	FROM 	#TempTableRef
	WHERE	IdProjectT2 IS NULL AND
		IdPhaseT2 IS NULL AND
		IdWPT2 IS NULL

END
GO

--Drops the Procedure bpsSelectReforecastWPUsed if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectReforecastWPUsed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectReforecastWPUsed
GO
CREATE PROCEDURE bpsSelectReforecastWPUsed
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate 		AS INT,
	@ActiveState		AS CHAR(1)
AS
BEGIN
	DECLARE @BudgetGeneration INT
	
	IF (@BudgetVersion <> 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetToCompletionBudgetGeneration (@IdProject, @BudgetVersion)
	END
	ELSE
	BEGIN
		SELECT 	@BudgetGeneration = MAX(IdGeneration)
		FROM 	BUDGET_TOCOMPLETION_STATES BTS
		WHERE 	IdProject = @IdProject AND
			IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTS.IdAssociate
							   ELSE @IdAssociate END AND
			State <> 'V'

		--If no InProgress generation was found, get the Released generation
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SELECT 	@BudgetGeneration = MAX(IdGeneration)
			FROM 	BUDGET_TOCOMPLETION_STATES BTS
			WHERE 	IdProject = @IdProject AND
				IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTS.IdAssociate 
								   ELSE @IdAssociate END AND
				State = 'V'
		END
		
		--If the budget generation is still null (when no released version exists for the given user, because he
		--was added to the project at this moment and he has no budget whatsoever), get the generation using
		--dbo.fnGetToCompletionBudgetGeneration function
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SET @BudgetGeneration = ISNULL(dbo.fnGetToCompletionBudgetGeneration (@IdProject, @BudgetVersion), dbo.fnGetToCompletionBudgetGeneration (@IdProject, 'C'))
		END
	END		

	IF (@BudgetGeneration IS NULL)
	BEGIN
		RAISERROR('Budget version %s does not exist.', 16, 1, @BudgetVersion)
		RETURN
	END

	
	DECLARE @RevisedCurrentGeneration INT
	SET @RevisedCurrentGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, 'C')
	
	
	SELECT DISTINCT
		PH.Id							AS	'IdPhase',
		PH.Code + ' - ' + PH.Name		AS	'PhaseName'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH 
		ON WP.IdPhase = PH.Id
	left JOIN BUDGET_TOCOMPLETION_DETAIL AS BTD ON --This join is used to get the phases of the work packages for which data exists in the revised budget
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWorkPackage
	LEFT JOIN BUDGET_TOCOMPLETION_DETAIL_COSTS AS BTDC ON
		BTDC.IdProject = BTD.IdProject AND
		BTDC.IdGeneration = BTD.IdGeneration AND
		BTDC.IdPhase = BTD.IdPhase AND
		BTDC.IdWorkPackage = BTD.IdWorkPackage AND
		BTDC.IdCostCenter = BTD.IdCostCenter AND
		BTDC.IdAssociate = BTD.IdAssociate AND
		BTDC.YearMonth = BTD.YearMonth
	WHERE 	WP.IdProject = @IdProject AND
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END AND
			--BTD.IdGeneration = @BudgetGeneration  AND
			isnull(BTD.IdAssociate,-1) = CASE WHEN @IdAssociate = -1 THEN isnull(BTD.IdAssociate,-1)
									ELSE @IdAssociate END 

	SELECT DISTINCT
		WP.IdProject 		AS	'IdProject',
		WP.IdPhase		AS	'IdPhase',
		PH.Name		AS	'PhaseName',
		WP.Id		AS	'IdWP',
		WP.Code + ' - ' + WP.Name		AS	'WPName',
		WP.StartYearMonth	AS	'StartYearMonth',
		WP.EndYearMonth	AS	'EndYearMonth',
		WP.IsActive 		AS 	'IsActive',
		CAST (CASE 
			WHEN (PJI.PercentAffected IS NOT NULL AND
						 WP.StartYearMonth IS NOT NULL AND
						 WP.EndYearMonth IS NOT NULL)
			 THEN 1
			ELSE 0		
		END AS BIT)		AS	'HasPeriodAndInterco',
		CAST (1 AS BIT)		AS 	'HasBudget',
		CASE WHEN  (
			EXISTS
			(
				SELECT 	IdProject
				FROM	ACTUAL_DATA_DETAILS_HOURS
				WHERE	IdProject = WP.IdProject AND
					IdPhase = WP.IdPhase AND
					IdWorkPackage = WP.Id
			)
			OR
			EXISTS
			(
				SELECT 	IdProject
				FROM	ACTUAL_DATA_DETAILS_SALES
				WHERE	IdProject = WP.IdProject AND
					IdPhase = WP.IdPhase AND
					IdWorkPackage = WP.Id
			)
			OR
			EXISTS
			(
				SELECT 	IdProject
				FROM	ACTUAL_DATA_DETAILS_COSTS
				WHERE	IdProject = WP.IdProject AND
					IdPhase = WP.IdPhase AND
					IdWorkPackage = WP.Id
			)
			OR
			EXISTS
			(
				SELECT 	IdProject
				FROM 	BUDGET_REVISED_DETAIL
				WHERE	IdProject = WP.IdProject AND
					IdGeneration = @RevisedCurrentGeneration AND
					IdPhase = WP.IdPhase AND
					IdWorkPackage = WP.Id AND
					IdAssociate = @IdAssociate
			)
		)
			THEN 
				CAST (1 AS BIT)
			ELSE
				CAST (0 AS BIT)
			END		 AS 	'HasActualOrRevisedData'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH 
		ON WP.IdPhase = PH.Id
	left JOIN BUDGET_TOCOMPLETION_DETAIL AS BTD ON --This join is used to get the work packages for which data exists in the revised budget
		WP.IdProject = BTD.IdProject AND
		WP.IdPhase = BTD.IdPhase AND
		WP.Id = BTD.IdWorkPackage
	LEFT JOIN BUDGET_TOCOMPLETION_DETAIL_COSTS AS BTDC ON
		BTDC.IdProject = BTD.IdProject AND
		BTDC.IdGeneration = BTD.IdGeneration AND
		BTDC.IdPhase = BTD.IdPhase AND
		BTDC.IdWorkPackage = BTD.IdWorkPackage AND
		BTDC.IdCostCenter = BTD.IdCostCenter AND
		BTDC.IdAssociate = BTD.IdAssociate AND
		BTDC.YearMonth = BTD.YearMonth
	LEFT JOIN PROJECTS_INTERCO AS PJI 
		ON 	PJI.IdProject = WP.IdProject AND
			PJI.IdPhase = WP.IdPhase AND
			PJI.IdWorkPackage = WP.Id 
	WHERE 	WP.IdProject = @IdProject AND 
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END AND
			--BTD.IdGeneration = @BudgetGeneration AND
			isnull(BTD.IdAssociate,-1) = CASE WHEN @IdAssociate = -1 THEN isnull(BTD.IdAssociate,-1)
									ELSE @IdAssociate END 
END	
GO
--Drops the Procedure bpsSelectRevisedBudgetWPInfo if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectRevisedBudgetWPInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectRevisedBudgetWPInfo
GO
CREATE PROCEDURE bpsSelectRevisedBudgetWPInfo
	@IdProject	AS INT, 	--The Id of the Project
	@IdPhase	AS INT,		--The Id of the Phase
	@IdWP		AS INT,		--The Id of the Work Package
	@BudgetVersion	AS CHAR(1) = NULL,	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate	AS INT,
	@WPCode		AS VARCHAR(3)
AS

	DECLARE @ErrorMessage varchar(255)
	IF NULLIF(@WPCode, '') IS NOT NULL AND NOT EXISTS (
			SELECT [Id]
			FROM WORK_PACKAGES
			WHERE IdProject = @IdProject AND
			      IdPhase	= @IdPhase AND
			      [Id]	= @IdWP AND
			      Code	= @WPCode
			)
	BEGIN
		SET @ErrorMessage = 'Key information about WP with code '+ @WPCode + ' has been changed by another user. Please refresh your information.'	
		RAISERROR(@ErrorMessage, 16, 1)
	
	END

	DECLARE @BudgetGeneration INT
	DECLARE @HasBudget BIT
	DECLARE @HasActualOrRevisedData BIT

	SET @HasBudget = 0
	SET @HasActualOrRevisedData = 0

	SET @BudgetGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, @BudgetVersion)

	--If no InProgress generation was found, get the Released generation
	IF (@BudgetGeneration IS NULL AND @BudgetVersion = 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, 'C')
	END

	IF EXISTS
	(
		SELECT 	IdProject
		FROM	BUDGET_REVISED_DETAIL
		WHERE	IdProject = @IdProject AND
			IdGeneration = @BudgetGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SET @HasBudget = 1
	END

	SELECT 	WP.IdProject 					AS 'IdProject',
			WP.IdPhase 						AS 'IdPhase',
			WP.Id							AS 'IdWP',
			PH.Code + ' - ' + PH.Name		AS 'PhaseName',
			WP.Code + ' - ' + WP.Name		AS 'WPName',
			WP.Code							AS 'WPCode',
			WP.StartYearMonth				AS 'StartYearMonth',
			WP.EndYearMonth					AS 'EndYearMonth',
			WP.IsActive		 				AS 	'IsActive',
			CAST (CASE WHEN (PJI.PercentAffected IS NOT NULL AND
							 WP.StartYearMonth IS NOT NULL AND
							 WP.EndYearMonth IS NOT NULL) THEN 1
				 ELSE 0	END AS BIT)			AS 'HasPeriodAndInterco',
			@HasBudget						AS 'HasBudget',
			@HasActualOrRevisedData			AS 'HasActualOrRevisedData'
			FROM WORK_PACKAGES AS WP
			INNER JOIN PROJECT_PHASES PH 
				ON WP.IdPhase = PH.Id
			LEFT JOIN PROJECTS_INTERCO PJI
				 ON PJI.IdProject = WP.IdProject AND
					PJI.IdPhase = WP.IdPhase AND
					PJI.IdWorkPackage = WP.Id
	WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id	= @IdWP
GO

--Drops the Procedure bpsSelectRevisedBudgetWPUnused if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectRevisedBudgetWPUnused]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectRevisedBudgetWPUnused
GO
CREATE PROCEDURE bpsSelectRevisedBudgetWPUnused
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N' only when coming from Follow-up
	@IdAssociate		AS INT,
	@ActiveState		AS CHAR(1)
AS
BEGIN

	DECLARE @BudgetGeneration INT

	IF (@BudgetVersion <> 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, @BudgetVersion)
	END
	ELSE
	BEGIN
		SELECT 	@BudgetGeneration = MAX(IdGeneration)
		FROM 	BUDGET_REVISED_STATES BRS
		WHERE 	IdProject = @IdProject AND
			IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRS.IdAssociate ELSE @IdAssociate END AND
			State <> 'V'

		--If no new generation was found, get the released generation
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SELECT 	@BudgetGeneration = MAX(IdGeneration)
			FROM 	BUDGET_REVISED_STATES BRS
			WHERE 	IdProject = @IdProject AND
				IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRS.IdAssociate ELSE @IdAssociate END AND
				State = 'V'
		END

		--If the budget generation is still null (when no released version exists for the given user, because he
		--was added to the project at this moment and he has no budget whatsoever), get the generation using
		--dbo.fnGetRevisedBudgetGeneration function
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SET @BudgetGeneration = ISNULL(dbo.fnGetRevisedBudgetGeneration (@IdProject, @BudgetVersion), dbo.fnGetRevisedBudgetGeneration (@IdProject, 'C'))
		END
	END

	IF (@BudgetGeneration IS NULL)
	BEGIN
		RAISERROR('Budget version %s does not exist.', 16, 1, @BudgetVersion)
		RETURN
	END

	SELECT * INTO #TempTableRev
	FROM 
		(SELECT DISTINCT
			WP.IdProject 			AS	'IdProjectT1',
			WP.IdPhase				AS	'IdPhaseT1',
			WP.Id					AS	'IdWPT1',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT1'
		FROM WORK_PACKAGES AS WP
		WHERE WP.IdProject = @IdProject AND
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END
			) AS AllWP
	LEFT JOIN
	(
		SELECT DISTINCT
			WP.IdProject 			AS	'IdProjectT2',
			WP.IdPhase				AS	'IdPhaseT2',
			WP.Id					AS	'IdWPT2',
			WP.Code + ' - ' + WP.Name		AS	'WPNameT2'
		FROM WORK_PACKAGES AS WP
		--This join is used to get the work packages for which data exists in the revised budget
		INNER JOIN BUDGET_REVISED_DETAIL AS BRD ON
			WP.IdProject = BRD.IdProject AND
			WP.IdPhase = BRD.IdPhase AND
			WP.Id = BRD.IdWorkPackage
		LEFT JOIN BUDGET_REVISED_DETAIL_COSTS AS BRDC ON
			BRDC.IdProject = BRD.IdProject AND
			BRDC.IdGeneration = BRD.IdGeneration AND
			BRDC.IdPhase = BRD.IdPhase AND
			BRDC.IdWorkPackage = BRD.IdWorkPackage AND
			BRDC.IdCostCenter = BRD.IdCostCenter AND
			BRDC.IdAssociate = BRD.IdAssociate AND
			BRDC.YearMonth = BRD.YearMonth
		WHERE 	WP.IdProject = @IdProject AND
				WP.IsActive = CASE WHEN @ActiveState = 'A' THEN	1
									WHEN @ActiveState = 'I' THEN 0
									WHEN @ActiveState = 'L' THEN WP.IsActive END AND
				BRD.IdGeneration = @BudgetGeneration AND
				BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRD.IdAssociate
								ELSE @IdAssociate END 
	) AS UsedWP
	ON 	AllWP.IdProjectT1 = UsedWP.IdProjectT2 AND
		AllWP.IdPhaseT1 = UsedWP.IdPhaseT2 AND
		AllWP.IdWPT1 = UsedWP.IdWPT2

	SELECT	IdProjectT1 AS 'IdProject',
		IdPhaseT1 AS 'IdPhase',
		IdWPT1 AS 'IdWP',
		WPNameT1 AS 'WPName'
	FROM 	#TempTableRev
	WHERE	IdProjectT2 IS NULL AND
		IdPhaseT2 IS NULL AND
		IdWPT2 IS NULL

END
GO

--Drops the Procedure bgtSelectWPPreselectionUsed if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[bpsSelectRevisedBudgetWPUsed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE bpsSelectRevisedBudgetWPUsed
GO
CREATE PROCEDURE bpsSelectRevisedBudgetWPUsed
	@IdProject 			AS INT, 	--The Id of the Project
	@BudgetVersion		AS CHAR(1),	-- @BudgetVersion will be 'P', 'C' or 'N'
	@IdAssociate 		AS INT,
	@ActiveState		AS CHAR(1)
AS
BEGIN

	DECLARE @BudgetGeneration INT

	IF (@BudgetVersion <> 'N')
	BEGIN
		SET @BudgetGeneration = dbo.fnGetRevisedBudgetGeneration (@IdProject, @BudgetVersion)
	END
	ELSE
	BEGIN
		SELECT 	@BudgetGeneration = MAX(IdGeneration)
		FROM 	BUDGET_REVISED_STATES BRS
		WHERE 	IdProject = @IdProject AND
			IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRS.IdAssociate
							   ELSE @IdAssociate END AND
			State <> 'V'

		--If no InProgress generation was found, get the Released generation
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SELECT 	@BudgetGeneration = MAX(IdGeneration)
			FROM 	BUDGET_REVISED_STATES BRS
			WHERE 	IdProject = @IdProject AND
				IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRS.IdAssociate
								   ELSE @IdAssociate END AND
				State = 'V'
		END

		--If the budget generation is still null (when no released version exists for the given user, because he
		--was added to the project at this moment and he has no budget whatsoever), get the generation using
		--dbo.fnGetRevisedBudgetGeneration function
		IF (@BudgetGeneration IS NULL)
		BEGIN
			SET @BudgetGeneration = ISNULL(dbo.fnGetRevisedBudgetGeneration (@IdProject, @BudgetVersion), dbo.fnGetRevisedBudgetGeneration (@IdProject, 'C'))
		END
	END
	
	IF (@BudgetGeneration IS NULL)
	BEGIN
		RAISERROR('Budget version %s does not exist.', 16, 1, @BudgetVersion)
		RETURN
	END

	--Gets the master table for WP Preselection functionality. This table contains only information
	-- about the phases of the active work packages. 
	SELECT DISTINCT
		PH.Id	AS	'IdPhase',
		PH.Code + ' - ' + PH.Name	AS	'PhaseName'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH ON WP.IdPhase = PH.Id
	--This join is used to get the phases of the work packages for which data exists in the revised budget
	INNER JOIN BUDGET_REVISED_DETAIL AS BRD ON
		WP.IdProject = BRD.IdProject AND
		WP.IdPhase = BRD.IdPhase AND
		WP.Id = BRD.IdWorkPackage
	LEFT JOIN BUDGET_REVISED_DETAIL_COSTS AS BRDC ON
		BRDC.IdProject = BRD.IdProject AND
		BRDC.IdGeneration = BRD.IdGeneration AND
		BRDC.IdPhase = BRD.IdPhase AND
		BRDC.IdWorkPackage = BRD.IdWorkPackage AND
		BRDC.IdCostCenter = BRD.IdCostCenter AND
		BRDC.IdAssociate = BRD.IdAssociate AND
		BRDC.YearMonth = BRD.YearMonth
	WHERE 	WP.IdProject = @IdProject AND
			WP.IsActive = CASE 	WHEN @ActiveState = 'A' THEN 1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END AND
			BRD.IdGeneration = @BudgetGeneration  AND
			BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRD.IdAssociate
									ELSE @IdAssociate END 

	SELECT DISTINCT
		WP.IdProject 		AS	'IdProject',
		WP.IdPhase		AS	'IdPhase',
		PH.Name		AS	'PhaseName',
		WP.Id		AS	'IdWP',
		WP.Code + ' - ' + WP.Name		AS	'WPName',
		WP.StartYearMonth	AS	'StartYearMonth',
		WP.EndYearMonth	AS	'EndYearMonth',
		WP.IsActive 		AS 	'IsActive',
		CAST (CASE WHEN (PJI.PercentAffected IS NOT NULL AND
						 WP.StartYearMonth IS NOT NULL AND
						 WP.EndYearMonth IS NOT NULL) THEN 1
					ELSE 0 END AS BIT) AS	'HasPeriodAndInterco',
		CAST (1 AS BIT)		AS 	'HasBudget',
		CAST (0 AS BIT) 	AS 	'HasActualOrRevisedData'
	FROM WORK_PACKAGES AS WP
	INNER JOIN PROJECT_PHASES PH
		ON WP.IdPhase = PH.Id
	INNER JOIN BUDGET_REVISED_DETAIL AS BRD ON --This join is used to get the work packages for which data exists in the revised budget
		WP.IdProject = BRD.IdProject AND
		WP.IdPhase = BRD.IdPhase AND
		WP.Id = BRD.IdWorkPackage
	LEFT JOIN BUDGET_REVISED_DETAIL_COSTS AS BRDC ON
		BRDC.IdProject = BRD.IdProject AND
		BRDC.IdGeneration = BRD.IdGeneration AND
		BRDC.IdPhase = BRD.IdPhase AND
		BRDC.IdWorkPackage = BRD.IdWorkPackage AND
		BRDC.IdCostCenter = BRD.IdCostCenter AND
		BRDC.IdAssociate = BRD.IdAssociate AND
		BRDC.YearMonth = BRD.YearMonth
	LEFT JOIN PROJECTS_INTERCO AS PJI
		ON 	PJI.IdProject = WP.IdProject AND
			PJI.IdPhase = WP.IdPhase AND
			PJI.IdWorkPackage = WP.Id
	WHERE 	WP.IdProject = @IdProject AND
			WP.IsActive = CASE WHEN @ActiveState = 'A' THEN 1
								WHEN @ActiveState = 'I' THEN 0
								WHEN @ActiveState = 'L' THEN WP.IsActive END AND
			BRD.IdGeneration = @BudgetGeneration AND
			BRD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BRD.IdAssociate
									ELSE @IdAssociate END 
END
GO

--Drops the Procedure catDeleteAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteAssociate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteAssociate
GO
CREATE PROCEDURE catDeleteAssociate
	@Id 		AS INT, 	--The Id of the selected Associate
	@IdCountry	AS INT		--The IdCountry of the selected Associate
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Associate'
	SET @MasterName = 'Work package'

	SELECT 	@CountDep = WP.LastUserUpdate
	FROM WORK_PACKAGES AS WP
	WHERE WP.LastUserUpdate = @Id
		
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @MasterName = 'Project Core Team'
	SELECT 	@CountDep = PCT.IdAssociate
	FROM PROJECT_CORE_TEAMS AS PCT
	WHERE PCT.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END

	DECLARE @AssociateName VARCHAR(50)	

	SELECT 	@CountDep = AD.IdAssociate,
		@AssociateName = A.Name
	FROM ACTUAL_DATA_DETAILS_COSTS AS AD
	INNER JOIN ASSOCIATES A ON
		A.Id = AD.IdAssociate
	WHERE AD.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Actual Data.',16,1, @AssociateName)
		RETURN -3
	END

	SELECT 	@CountDep = AD.IdAssociate,
		@AssociateName = A.Name
	FROM ACTUAL_DATA_DETAILS_HOURS AS AD
	INNER JOIN ASSOCIATES A ON
		A.Id = AD.IdAssociate
	WHERE AD.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Actual Data.',16,1, @AssociateName)
		RETURN -3
	END

	SELECT 	@CountDep = AD.IdAssociate,
		@AssociateName = A.Name
	FROM ACTUAL_DATA_DETAILS_SALES AS AD
	INNER JOIN ASSOCIATES A ON
		A.Id = AD.IdAssociate
	WHERE AD.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Actual Data.',16,1, @AssociateName)
		RETURN -3
	END	

	SELECT 	@CountDep = I.IdAssociate,
		@AssociateName = A.Name
	FROM IMPORTS AS I
	INNER JOIN ASSOCIATES A ON
		A.Id = I.IdAssociate
	WHERE I.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Imports.',16,1, @AssociateName)
		RETURN -4
	END
	
	SELECT 	@CountDep = IBI.IdAssociate,
		@AssociateName = A.Name
	FROM IMPORT_BUDGET_INITIAL AS IBI
	INNER JOIN ASSOCIATES A ON
		A.Id = IBI.IdAssociate
	WHERE IBI.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Import Budget Initial.',16,1, @AssociateName)
		RETURN -5
	END


	SELECT 	@CountDep = IBR.IdAssociate,
		@AssociateName = A.Name
	FROM IMPORT_BUDGET_REVISED AS IBR
	INNER JOIN ASSOCIATES A ON
		A.Id = IBR.IdAssociate
	WHERE IBR.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Import Budget Revised.',16,1, @AssociateName)
		RETURN -7
	END

	SELECT 	@CountDep = ABI.IdAssociate,
		@AssociateName = A.Name
	FROM ANNUAL_BUDGET_IMPORTS AS ABI
	INNER JOIN ASSOCIATES A ON
		A.Id = ABI.IdAssociate
	WHERE ABI.IdAssociate= @Id
		
	IF (@CountDep > 0)
	BEGIN
		RAISERROR('Associate ''%s'' cannot be deleted because it is used in Annual Budget Imports.',16,1, @AssociateName)
		RETURN -6
	END

	-- we delete the associate role too
	DELETE FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @Id

	-- added deletion of settings before the actual delete of the associate
	DELETE FROM USER_SETTINGS
	WHERE AssociateId = @Id	 

	DELETE FROM ASSOCIATES
	WHERE 	IdCountry = @IdCountry AND
		[Id] = @Id 


	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteBudgetPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteBudgetPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteBudgetPeriod
GO
CREATE PROCEDURE catDeleteBudgetPeriod
	@Id AS INT 	--The Id of the selected Budget Period
AS
DECLARE @RowCount INT

	DELETE FROM BUDGET_PERIODS
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteCostCenter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteCostCenter]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteCostCenter
GO
CREATE PROCEDURE catDeleteCostCenter
	@Id AS INT 	--The Id of the selected Cost Center
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SELECT 	@CountDep = HR.IdCostCenter
	FROM HOURLY_RATES AS HR
	WHERE HR.IdCostCenter = @Id
	
	SET @ChildName	= 'Cost center'
	SET @MasterName = 'Hourly Rate'
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @CCName VARCHAR(30)

	IF 
	(
		EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	BUDGET_INITIAL_DETAIL
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	BUDGET_REVISED_DETAIL
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	BUDGET_TOCOMPLETION_DETAIL
			WHERE	IdCostCenter = @Id
		)
	)
	BEGIN
		SELECT 	@CCName = [Name]
		FROM	COST_CENTERS
		WHERE 	[Id] = @Id
		RAISERROR('Cost Center %s is used in budget data.', 16, 1, @CCName)
		RETURN -2
	END

	IF 
	(
		EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ACTUAL_DATA_DETAILS_HOURS
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ACTUAL_DATA_DETAILS_SALES
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ACTUAL_DATA_DETAILS_COSTS
			WHERE	IdCostCenter = @Id
		)
	)
	BEGIN
		SELECT 	@CCName = [Name]
		FROM	COST_CENTERS
		WHERE 	[Id] = @Id
		RAISERROR('Cost Center %s is used in actual data.', 16, 1, @CCName)
		RETURN -3
	END

	IF 
	(
		EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ANNUAL_BUDGET_DATA_DETAILS_HOURS
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ANNUAL_BUDGET_DATA_DETAILS_SALES
			WHERE	IdCostCenter = @Id
		)
		OR EXISTS
		(
			SELECT 	IdCostCenter 
			FROM	ANNUAL_BUDGET_DATA_DETAILS_COSTS
			WHERE	IdCostCenter = @Id
		)
	)
	BEGIN
		SELECT 	@CCName = [Name]
		FROM	COST_CENTERS
		WHERE 	[Id] = @Id
		RAISERROR('Cost Center %s is used in annual budget data.', 16, 1, @CCName)
		RETURN -3
	END

	DELETE FROM COST_CENTERS
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteCountry if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteCountry]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteCountry
GO
CREATE PROCEDURE catDeleteCountry
	@Id AS INT 	--The Id of the selected Country
	
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @MasterName = 'G/L Account'
	SET @ChildName	= 'Country'

	SELECT 	@CountDep = GA.IdCountry
	FROM GL_ACCOUNTS AS GA
	WHERE GA.IdCountry = @Id
	

	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @MasterName = 'Inergy Location'

	SELECT 	@CountDep = IL.IdCountry
	FROM INERGY_LOCATIONS AS IL
	WHERE IL.IdCountry = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END

	SET @MasterName = 'Associate'

	DECLARE @CountryCode VARCHAR(3)
	SELECT 	@CountryCode = Code
	FROM 	COUNTRIES
	WHERE 	[Id] = @Id
	
	SELECT 	@CountDep = A.IdCountry
	FROM 	ASSOCIATES AS A
	WHERE 	A.IdCountry = @Id AND
		A.InergyLogin <> @CountryCode + '\null'
		
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3
	END

	------------------------------------------------Delete the null associate of this country---------------------------------------------------
	DECLARE @NullIdAssociate INT
	SELECT 	@NullIdAssociate = [Id]
	FROM	ASSOCIATES
	WHERE	IdCountry = @Id AND
		InergyLogin = @CountryCode + '\null'

	DECLARE @RetVal INT
	EXEC @RetVal = catDeleteAssociate @NullIdAssociate, @Id

	IF (@@ERROR <> 0 OR @RetVal < 0)
		RETURN -4
	--------------------------------------------------------------------------------------------------------------------------------------------
	
	DECLARE @Rank INT
	SELECT @Rank = Rank from COUNTRIES WHERE [ID] = @Id	

	DELETE FROM COUNTRIES
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'COUNTRIES', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteCurrency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteCurrency
GO
CREATE PROCEDURE catDeleteCurrency
	@Id AS INT 	--The Id of the selected Currency
AS
DECLARE @Rowcount INT
	DELETE FROM CURRENCIES
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteCustomerSite if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteCustomerSite]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteCustomerSite
GO
CREATE PROCEDURE catDeleteCustomerSite
	@Id AS INT 	--The Id of the selected Customer Site
AS
DECLARE @RowCount INT

	DELETE FROM CUSTOMER_SITES
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteDepartment if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteDepartment]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteDepartment
GO
CREATE PROCEDURE catDeleteDepartment
	@Id AS INT 	--The Id of the selected Department
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Department'
	SET @MasterName = 'Cost Center'

	SELECT 	@CountDep = CC.IdDepartment
	FROM COST_CENTERS AS CC
	WHERE CC.IdDepartment = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @Rank INT
	SELECT @Rank = Rank from DEPARTMENTS WHERE [ID] = @Id

	DELETE FROM DEPARTMENTS
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'DEPARTMENTS', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteExchangeRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteExchangeRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteExchangeRate
GO
CREATE PROCEDURE catDeleteExchangeRate
	@IdCategory	AS INT, 	--The IdCategory of the selected Exchange Rate
	@YearMonth	AS INT,		--The Year and Month of the selected Exchange Rate
	@IdCurrencyTo	AS INT		--The IdCurrencyTo of the selected Exchange Rate
AS
DECLARE @Rowcount INT

	DELETE FROM EXCHANGE_RATES
	WHERE 	IdCategory = @IdCategory AND
		YearMonth = @YearMonth AND 
		IdCurrencyTo = @IdCurrencyTo

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteFunction if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteFunction]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteFunction
GO
CREATE PROCEDURE catDeleteFunction
	@Id AS INT 	--The Id of the selected Function
AS
DECLARE @RowCount INT

	DELETE FROM [FUNCTIONS]
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteGlAccount if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteGlAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteGlAccount
GO
CREATE PROCEDURE catDeleteGlAccount
	@IdCountry	AS INT,		--The Id of the Country connected to the selected GL Account
	@Id		AS INT		--The Id of the selected GL Account

AS
	DECLARE @RowCount INT
	DECLARE @AccountName VARCHAR(30)

	--Check that the account is not used in the budget tables
	IF (
	EXISTS 
		(SELECT IdAccountHours 
		FROM 	BUDGET_INITIAL_DETAIL
		WHERE 	IdAccountHours = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccountSales
		FROM 	BUDGET_INITIAL_DETAIL
		WHERE 	IdAccountSales = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	BUDGET_INITIAL_DETAIL_COSTS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS 
		(SELECT IdAccountHours 
		FROM 	BUDGET_REVISED_DETAIL
		WHERE 	IdAccountHours = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccountSales
		FROM 	BUDGET_REVISED_DETAIL
		WHERE 	IdAccountSales = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	BUDGET_REVISED_DETAIL_COSTS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS 
		(SELECT IdAccountHours 
		FROM 	BUDGET_TOCOMPLETION_DETAIL
		WHERE 	IdAccountHours = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccountSales
		FROM 	BUDGET_TOCOMPLETION_DETAIL
		WHERE 	IdAccountSales = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	BUDGET_TOCOMPLETION_DETAIL_COSTS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	)
	BEGIN
		SELECT 	@AccountName = [Name] 
		FROM 	GL_ACCOUNTS
		WHERE 	IdCountry = @IdCountry AND
			[Id] = @Id 
		
		RAISERROR('Could not delete the account %s because it is used in the Budget tables',16,1,@AccountName)
		RETURN -1
	END

	--Check that the account is not used in the actual data tables
	IF (
	EXISTS 
		(SELECT IdAccount 
		FROM 	ACTUAL_DATA_DETAILS_HOURS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	ACTUAL_DATA_DETAILS_SALES
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	ACTUAL_DATA_DETAILS_COSTS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	)
	BEGIN
		SELECT 	@AccountName = [Name] 
		FROM 	GL_ACCOUNTS
		WHERE 	IdCountry = @IdCountry AND
			[Id] = @Id 
		
		RAISERROR('Could not delete the account %s because it is used in the ACTUAL DATA Tables',16,1,@AccountName)
		RETURN -2
	END
	
	--Check that the account is not used in the annual tables

	IF (
	EXISTS 
		(SELECT IdAccount 
		FROM 	ANNUAL_BUDGET_DATA_DETAILS_HOURS
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		FROM 	ANNUAL_BUDGET_DATA_DETAILS_SALES
		WHERE 	IdAccount = @Id AND
			IdCountry = @IdCountry)
	OR
	EXISTS
		(SELECT IdAccount
		 FROM	ANNUAL_BUDGET_DATA_DETAILS_COSTS
	 	 WHERE IdAccount = @Id AND
		       IdCountry = @IdCountry)
	)
	BEGIN
		SELECT 	@AccountName = [Name] 
		FROM 	GL_ACCOUNTS
		WHERE 	IdCountry = @IdCountry AND
			[Id] = @Id 
		RAISERROR('Could not delete the account %s because it is used in the Annual tables',16,1,@AccountName)
		RETURN -3
	END

	DELETE FROM GL_ACCOUNTS
	WHERE 	IdCountry = @IdCountry AND
		[Id] = @Id 

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteHourlyRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteHourlyRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteHourlyRate
GO
CREATE PROCEDURE catDeleteHourlyRate
	@IdCostCenter	AS INT, 	--The IdCostCenter of the selected Hourly Rate
	@YearMonth	AS INT		--The Year and Month of the selected Hourly Rate
	
AS	
DECLARE @RowCount INT

	DELETE FROM HOURLY_RATES
	WHERE 	IdCostCenter = @IdCostCenter AND
		YearMonth = @YearMonth

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteInergyLocation if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteInergyLocation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteInergyLocation
GO
CREATE PROCEDURE catDeleteInergyLocation
	@Id AS INT 	--The Id of the selected Inergy Location
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Inergy location'
	SET @MasterName = 'Cost Center'

	SELECT 	@CountDep = CC.IdInergyLocation
	FROM COST_CENTERS AS CC
	WHERE CC.IdInergyLocation = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @Rank INT
	SELECT @Rank = Rank from INERGY_LOCATIONS WHERE [ID] = @Id

	DELETE FROM INERGY_LOCATIONS
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT
	
	exec catUpdateCatalogRank 'INERGY_LOCATIONS', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteOwner if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteOwner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteOwner
GO
CREATE PROCEDURE catDeleteOwner
	@Id AS INT 	--The Id of the selected Owner
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Owner'
	SET @MasterName = 'Programs'

	SELECT 	@CountDep = P.IdOwner
	FROM PROGRAMS AS P
	WHERE P.IdOwner = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @Rank INT
	SELECT @Rank = Rank from OWNERS WHERE [ID] = @Id	

	DELETE FROM OWNERS
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'OWNERS', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeletePhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeletePhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeletePhase
GO
CREATE PROCEDURE catDeletePhase
	@Id AS INT 	--The Id of the selected Phase
AS
DECLARE @Rowcount INT
	DELETE FROM PHASES
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteProgram]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteProgram
GO
CREATE PROCEDURE catDeleteProgram
	@Id AS INT 	--The Id of the selected Program
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Program'
	SET @MasterName = 'Project'

	SELECT 	@CountDep = P.IdProgram
	FROM PROJECTS AS P
	WHERE P.IdProgram = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @Rank INT
	SELECT @Rank = Rank from PROGRAMS WHERE [ID] = @Id	

	DELETE FROM PROGRAMS
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'PROGRAMS', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteProject
GO
CREATE PROCEDURE catDeleteProject
	@Id AS INT 	--The Id of the selected Project
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Project'
	SET @MasterName = 'Work package'

	SELECT 	@CountDep = WP.IdProject
	FROM WORK_PACKAGES AS WP
	WHERE WP.IdProject = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @ChildName	= 'Project'
	SET @MasterName = 'Core Team'

	SELECT 	@CountDep = PCT.IdProject
	FROM PROJECT_CORE_TEAMS AS PCT
	WHERE PCT.IdProject = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END	


	DELETE FROM PROJECTS
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteProjectInterco if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteProjectInterco]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteProjectInterco
GO
CREATE PROCEDURE catDeleteProjectInterco
	@IdProject 	AS INT,		--The Id of the Project that corresponds to the current Project Interco 
	@IdPhase	AS INT,		--The Id of the Phase that corresponds to the current Project Interco 
	@IdWorkPackage	AS INT,		--The Id of the WorkPackage that corresponds to the current Project Interco 
	@IdCountry	AS INT		--The Id of the Country that corresponds to the current Project Interco 
AS
DECLARE @RowCount INT

	DELETE FROM PROJECTS_INTERCO
	WHERE 	IdProject = @IdProject AND 
		IdPhase = @IdPhase AND 
		IdWorkPackage = @IdWorkPackage AND
		IdCountry = @IdCountry 

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteProjectPhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteProjectPhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteProjectPhase
GO
CREATE PROCEDURE catDeleteProjectPhase
	@Id AS INT 	--The Id of the selected Project Phase
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Project phase'
	SET @MasterName = 'Work package'

	SELECT 	@CountDep = WP.IdPhase
	FROM WORK_PACKAGES AS WP
	WHERE WP.IdPhase = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END
	DELETE FROM PROJECT_PHASES
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteProjectType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteProjectType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteProjectType
GO
CREATE PROCEDURE catDeleteProjectType
	@Id AS INT 	--The Id of the selected Project Type
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Project Type'
	SET @MasterName = 'Project'

	SELECT 	@CountDep = P.IdProjectType
	FROM PROJECTS AS P
	WHERE P.IdProjectType = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END
	
	DECLARE @Rank INT
	SELECT @Rank = Rank from PROJECT_TYPES WHERE [ID] = @Id	

	DELETE FROM PROJECT_TYPES
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'PROJECT_TYPES', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteRegion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteRegion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteRegion
GO
CREATE PROCEDURE catDeleteRegion
	@Id AS INT 	--The Id of the selected Region
AS
DECLARE @Rowcount 	INT,
	@CountDep 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Region'
	SET @MasterName = 'Country'

	SELECT 	@CountDep = C.IdRegion
	FROM COUNTRIES AS C
	WHERE C.IdRegion = @Id
	
	IF (@CountDep > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @ChildName,@Parameter2 = @MasterName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END
	
	DECLARE @Rank INT
	SELECT @Rank = Rank from REGIONS WHERE [ID] = @Id	

	DELETE FROM REGIONS
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	exec catUpdateCatalogRank 'Regions', @Rank, 0, NULL

	RETURN @Rowcount
GO

--Drops the Procedure catDeleteWorkPackage if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteWorkPackage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteWorkPackage
GO
CREATE PROCEDURE catDeleteWorkPackage
	@IdProject	AS INT, --The Id representing the Project connected to the selected Work Package
	@IdPhase	AS INT,	--The Id representing the Phase connected to the selected Work Package
	@Id 		AS INT 	--The Id of the selected Work Package
AS


DECLARE @Rowcount 	INT,
	@CountInterco 	INT,
	@ChildName	VARCHAR(50),
	@MasterName	VARCHAR(50),
	@ErrorMessage	VARCHAR(255)

	SET @ChildName	= 'Projects Interco'
	SET @MasterName = 'Work packages'
	
	SELECT 	@CountInterco = COUNT([PI].IdCountry)
	FROM PROJECTS_INTERCO AS [PI]
	WHERE 	([PI].IdProject = @IdProject) AND
		([PI].IdPhase = @IdPhase) AND
		([PI].IdWorkPackage = @Id)
		
	IF (@CountInterco > 0)
	BEGIN
		EXEC   auxSelectErrorMessage_2 @Code = 'DELETE_MANDATORY_COLUMN_2',@IdLanguage = 1,@Parameter1 = @MasterName,@Parameter2 = @ChildName, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	DECLARE @WPName VARCHAR(34)

	IF 
	(
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ACTUAL_DATA_DETAILS_HOURS
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ACTUAL_DATA_DETAILS_SALES
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ACTUAL_DATA_DETAILS_COSTS
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
	)
	BEGIN
		SELECT 	@WPName = WP.Code + '-' + WP.Name
		FROM 	WORK_PACKAGES WP
		WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id = @Id
		RAISERROR('Work package %s cannot be deleted because it has existing actual data.', 16, 1, @WPName)
		RETURN -2
	END

	IF 
	(
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_HOURS
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_SALES
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS
		(
			SELECT 	IdProject
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_COSTS
			WHERE 	IdProject = @IdProject AND
				IdPhase = @IdPhase AND
				IdWorkPackage = @Id
		)
	)
	BEGIN
		SELECT 	@WPName = WP.Code + '-' + WP.Name
		FROM 	WORK_PACKAGES WP
		WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id = @Id
		RAISERROR('Work package %s cannot be deleted because it is used in annual budget.', 16, 1, @WPName)
		RETURN -3
	END

	DECLARE @Rank INT
	SELECT @Rank = Rank from WORK_PACKAGES WHERE [IdProject] = @IdProject AND IdPhase = @IdPhase AND [ID] = @Id

	DELETE FROM WORK_PACKAGES
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase AND
		[Id] = @Id
	SET @Rowcount = @@ROWCOUNT
	exec catUpdateWorkPackageRank 'WORK_PACKAGES', @Rank, 0, NULL, @IdProject, @IdPhase

	
	RETURN @Rowcount
GO

--Drops the Procedure catDeleteWorkPackageTemplate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catDeleteWorkPackageTemplate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catDeleteWorkPackageTemplate
GO
CREATE PROCEDURE catDeleteWorkPackageTemplate
	@IdPhase	AS INT,	--The Id representing the Phase connected to the selected Work Package
	@Id 		AS INT 	--The Id of the selected Work Package
AS


DECLARE @Rowcount 	INT,
	@Rank INT

	SELECT @Rank = Rank from WORK_PACKAGES_TEMPLATE WHERE IdPhase = @IdPhase AND [ID] = @Id

	DELETE FROM WORK_PACKAGES_TEMPLATE
	WHERE 	IdPhase = @IdPhase AND
		[Id] = @Id
	SET @Rowcount = @@ROWCOUNT
	exec catUpdateWorkPackageTemplateRank 'WORK_PACKAGES_TEMPLATE', @Rank, 0, NULL, @IdPhase

	
	RETURN @Rowcount
GO

--Drops the Procedure catGetFunctionForUserAndProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catGetFunctionForUserAndProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catGetFunctionForUserAndProject
GO
CREATE PROCEDURE catGetFunctionForUserAndProject
	@IdAssociate    AS INT,		--The Id of the Associate of the selected Function
	@IdProject 	AS INT		--The IdProject of the selected Function

AS
	
	SELECT 	PCT.IdFunction		AS 'IdFunction'
	FROM PROJECT_CORE_TEAMS AS PCT	
	WHERE 	PCT.IdAssociate = @IdAssociate AND 
		PCT.IdProject = @IdProject
GO

--Drops the Procedure catSelectProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catGetHourlyRateByYearMonthAndCostCenterCode]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catGetHourlyRateByYearMonthAndCostCenterCode
GO
CREATE PROCEDURE catGetHourlyRateByYearMonthAndCostCenterCode
	@StartYearMonth	AS INT, 	
	@EndYearMonth	AS INT, 	
	@CostCenterCode	AS varchar(15)		--The CostCenterCode of the selected Hourly Rate
AS

declare @HourlyRate decimal(12,2)

	SELECT top 1 @HourlyRate = HR.HourlyRate
		FROM HOURLY_RATES HR(NOLOCK)		
		INNER JOIN COST_CENTERS CC(NOLOCK)
			ON HR.IdCostCenter = CC.[Id]
	WHERE 
		HR.YearMonth between @StartYearMonth and @EndYearMonth
		AND	CC.Code = @CostCenterCode
	ORDER BY HR.YearMonth, HR.IdCostCenter

	
	if @HourlyRate is null or @HourlyRate <= 0.1
	  begin
		-- get the last hourly rate for @CostCenterCode in the  year of @StartYearMonth
			SELECT top 1 @HourlyRate = HR.HourlyRate
				FROM HOURLY_RATES HR(NOLOCK)		
				INNER JOIN COST_CENTERS CC(NOLOCK)
					ON HR.IdCostCenter = CC.[Id]
			WHERE 
				floor(HR.YearMonth / 100) = floor(@StartYearMonth/100) 
				AND CC.Code = @CostCenterCode
			ORDER BY HR.YearMonth desc
	  end

	if @HourlyRate is null or @HourlyRate <= 0.1
	  begin
		-- get the last hourly rate for @CostCenterCode in the current year
			SELECT top 1 @HourlyRate = HR.HourlyRate
				FROM HOURLY_RATES HR(NOLOCK)		
				INNER JOIN COST_CENTERS CC(NOLOCK)
					ON HR.IdCostCenter = CC.[Id]
			WHERE 
				floor(HR.YearMonth / 100) = year(getdate()) 
				AND CC.Code = @CostCenterCode
			ORDER BY HR.YearMonth desc
	  end

select @HourlyRate

GO

--Drops the Procedure catInsertAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertAssociate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertAssociate
GO
CREATE PROCEDURE catInsertAssociate
	@IdCountry		INT,		--The Id of the Country that is connected to the Associate you want to insert
 	@EmployeeNumber		VARCHAR(15),	--The Employee Number of the Associate you want to Insert
	@Name			VARCHAR(50),	--The Name of the Associate you want to Insert
	@InergyLogin		VARCHAR(50),	--The Inergy Login of the Associate you want to Insert
	@PercentageFullTime 	INT,		--The AvailabilityPercent of the Associate you want to Insert
	@IsActive		BIT,		--The IsActive of the Associate you want to Insert
	@IsSubContractor	BIT		--The IsSubContractor of the Associate you want to Insert

AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(50)
	

	IF NOT EXISTS( SELECT *
	FROM COUNTRIES AS C(TABLOCKX)
	WHERE 	C.[Id] = @IdCountry) 
	BEGIN
		RAISERROR('The selected country does not exists anymore',16,1)
		RETURN
	END

	SET @LogicalKey = 'Country, Employee Number'

	IF EXISTS( SELECT *
	FROM ASSOCIATES AS A (TABLOCKX)
	WHERE 	A.EmployeeNumber = @EmployeeNumber AND
		A.IdCountry = @IdCountry) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @LogicalKey = 'Inergy Login, Country'

	IF EXISTS( SELECT *
	FROM ASSOCIATES AS A (TABLOCKX)
	WHERE 	A.InergyLogin = @InergyLogin AND
		A.IdCountry = @IdCountry
	)
	SET @ValidateLogicKey = 1

	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @EmployeeNumber IS NULL OR 
	   @Name IS NULL OR 
	   @InergyLogin IS NULL OR 
	   @PercentageFullTime IS NULL OR 
	   @IsActive IS NULL OR 
	   @IsSubContractor IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END
	SELECT @Id = ISNULL(MAX(A.[Id]), 0) + 1
	FROM ASSOCIATES AS A (TABLOCKX)

	INSERT INTO ASSOCIATES ([Id],IdCountry,EmployeeNumber,[Name],InergyLogin,PercentageFullTime,IsActive,IsSubContractor)
	VALUES		       (@Id,@IdCountry,@EmployeeNumber,@Name,@InergyLogin,@PercentageFullTime,@IsActive,@IsSubContractor)
	
	RETURN @Id
GO



--Drops the Procedure catInsertBudgetPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertBudgetPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertBudgetPeriod
GO
CREATE PROCEDURE catInsertBudgetPeriod
	@Code	VARCHAR(1),	--The Code of the Budget Period you want to Insert
	@Name	VARCHAR(50)	--The Name of the Budget Period you want to Insert
	
AS
DECLARE @Id	INT

	SELECT @Id = ISNULL(MAX(C.[Id]), 0) + 1
	FROM BUDGET_PERIODS AS C (TABLOCKX)
	
	INSERT INTO BUDGET_PERIODS ([Id],Code,[Name])
	VALUES		      	   (@Id,@Code,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertCostCenter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertCostCenter]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertCostCenter
GO
CREATE PROCEDURE catInsertCostCenter
	@IdInergyLocation	INT,		--The Id of the Inergy Location related to the Cost Center
	@IdDepartment		INT,		--The Id of the Department related to the Cost Center
	@IsActive		BIT,		--Specifies if the Cost Center is active or not
 	@Code			VARCHAR(15),	--The Code of the Cost Center you want to Insert
	@Name			VARCHAR(30)	--The Name of the Cost Center you want to Insert
	
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	IF NOT EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS I(TABLOCKX)
	WHERE 	I.[Id] = @IdInergyLocation) 
	BEGIN
		RAISERROR('The selected Inergy Location does not exists anymore',16,1)
		RETURN
	END

	IF NOT EXISTS( SELECT *
	FROM DEPARTMENTS AS D(TABLOCKX)
	WHERE 	D.[Id] = @IdDepartment) 
	BEGIN
		RAISERROR('The selected department does not exists anymore',16,1)
		RETURN
	END



	--first we get the country of the newly inserted code 
	Declare @IdCountry int
	SELECT @IdCountry = IdCountry
	from INERGY_LOCATIONS
	WHERE Id = @IdInergyLocation

	SET @LogicalKey = 'Country, Code'
	IF EXISTS( SELECT *
		   FROM COST_CENTERS CC(TABLOCKX)
		   INNER JOIN INERGY_LOCATIONS IL
  			ON CC.IdInergyLocation = IL.Id
		   WHERE CC.Code = @Code and
			 IL.IdCountry = @IdCountry) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdInergyLocation IS NULL OR 
	   @IdDepartment IS NULL OR 
	   @IsActive IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(CC.[Id]), 0) + 1
	FROM COST_CENTERS AS CC (TABLOCKX)
	
	INSERT INTO COST_CENTERS([Id], IdInergyLocation, IdDepartment, IsActive, Code, [Name])
	VALUES		   	(@Id,@IdInergyLocation,@IdDepartment,@IsActive,@Code,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertCountry if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertCountry]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertCountry
GO
CREATE PROCEDURE catInsertCountry
 	@Code		VARCHAR(3),	--The Code of the Country you want to Insert
	@Name		VARCHAR(30),	--The Name of the Country you want to Insert
	@IdRegion	INT = NULL,		--The Region from REGIONS table
	@IdCurrency	INT,		--The Currency from Currencies table
	@Email		VARCHAR(50),
	@Rank INT
	
AS
BEGIN
	DECLARE @Id					INT,
			@ValidateLogicKey	BIT,
			@ErrorMessage		VARCHAR(200),
			@LogicalKey			VARCHAR(20)
	
	SET @LogicalKey = 'Country Name'

	IF (@IdRegion IS NOT NULL)
	BEGIN
		IF NOT EXISTS( SELECT *
		FROM REGIONS AS R(TABLOCKX)
		WHERE 	R.[id] = @IdRegion) 
		BEGIN
			RAISERROR('The selected region does not exist anymore',16,1)
			RETURN
		END
	END

	IF NOT EXISTS( SELECT *
	FROM CURRENCIES AS C(TABLOCKX)
	WHERE 	C.[Id] = @IdCurrency) 
	BEGIN
		RAISERROR('The selected currency does not exist anymore',16,1)
		RETURN
	END

	IF EXISTS( SELECT *
	FROM COUNTRIES AS C(TABLOCKX)
	WHERE 	C.[Name] = @Name) 
	SET @ValidateLogicKey = 1

	IF EXISTS( SELECT *
	FROM COUNTRIES AS C
	WHERE 	C.Code = @Code) 
	BEGIN
		SET @ValidateLogicKey = 1
		SET @LogicalKey= 'Code'
	END
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL OR 
	   @Name IS NULL OR 
	   @IdCurrency IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(C.[Id]), 0) + 1
	FROM COUNTRIES AS C (TABLOCKX)

	DECLARE @RetVal INT	

	exec @RetVal = catUpdateCatalogRank 'COUNTRIES', @Rank,1,NULL
	IF (@@ERROR <> 0 OR @RetVal < 0)
		return -3

	INSERT INTO COUNTRIES ([Id],Code,[Name],IdRegion,IdCurrency,Email, [Rank])
	VALUES       (@Id,@Code,@Name,@IdRegion,@IdCurrency, @Email,@Rank)

	--Insert the 7 corresponding GL Accounts only if this country is an InergyCountry (it has a region)
	IF (@IdRegion IS NOT NULL)
	BEGIN
		DECLARE CostIncomeCursor CURSOR FAST_FORWARD FOR
		SELECT 	[Id],
			[Name],
			DefaultAccount
		FROM	COST_INCOME_TYPES

		OPEN CostIncomeCursor
		DECLARE @IdCostIncome INT
		DECLARE @NameCostIncome VARCHAR(50)
		DECLARE @DefaultAccountCostIncome VARCHAR(20)
	
		FETCH NEXT FROM CostIncomeCursor INTO @IdCostIncome, @NameCostIncome, @DefaultAccountCostIncome		
		WHILE @@FETCH_STATUS = 0
		BEGIN
			EXEC @RetVal = catInsertGlAccount @Id, @DefaultAccountCostIncome, @NameCostIncome, @IdCostIncome
			IF (@@ERROR <> 0 OR @RetVal < 0)
			BEGIN
				CLOSE CostIncomeCursor
				DEALLOCATE CostIncomeCursor
				RETURN -4
			END
			FETCH NEXT FROM CostIncomeCursor INTO @IdCostIncome, @NameCostIncome, @DefaultAccountCostIncome		
		END
		CLOSE CostIncomeCursor
		DEALLOCATE CostIncomeCursor
	END

	----------------------------------------Insert the null associate for this country---------------------------------------------
	DECLARE @NullEmpNo VARCHAR(15)
	DECLARE @NullInergyLogin VARCHAR(50)
	DECLARE @NullName VARCHAR(50)
	--change null associate : Issue 0051621
	SET @NullEmpNo = '0'
	SET @NullInergyLogin = @Code + '\null'
	set @NullName = 'NA, cost or sales'

	EXEC catInsertAssociate @Id, @NullEmpNo, @NullName,@NullInergyLogin, 0, 0, 0
	-------------------------------------------------------------------------------------------------------------------------------
	RETURN @Id

END
GO

--Drops the Procedure catInsertCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertCurrency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertCurrency
GO
CREATE PROCEDURE catInsertCurrency
	@Code	VARCHAR(3),	--The Code of the Currency you want to Insert
	@Name	VARCHAR(50)	--The Name of the Currency you want to Insert
	
AS
DECLARE @Id	INT

	SELECT @Id = ISNULL(MAX(C.[Id]), 0) + 1
	FROM CURRENCIES AS C (TABLOCKX)
	
	INSERT INTO CURRENCIES ([Id],Code,[Name])
	VALUES		      (@Id,@Code,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertDepartment if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertDepartment]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertDepartment
GO
CREATE PROCEDURE catInsertDepartment
	@IdFunction	INT,		--The Id of the function that coresponds to this Department
	@Name		VARCHAR(50),	--The Name of the Department you want to Insert
	@Rank		INT
	
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	--Function catalogue does not have a UI so no verifications for Function should be done
	
	SET @LogicalKey = 'Name'

	IF EXISTS( SELECT *
	FROM DEPARTMENTS AS D(TABLOCKX)
	WHERE 	D.[Name] = @Name) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdFunction IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(D.[Id]), 0) + 1
	FROM DEPARTMENTS AS D (TABLOCKX)
	
	exec @RetVal = catUpdateCatalogRank 'DEPARTMENTS', @Rank,1,NULL

	IF (@@ERROR <> 0 OR @RetVal < 0)
		return -3

	INSERT INTO DEPARTMENTS ([Id],IdFunction,[Name], [Rank])
	VALUES		        (@Id,@IdFunction,@Name,  @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertExchangeRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertExchangeRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertExchangeRate
GO
CREATE PROCEDURE catInsertExchangeRate
 	@IdCurrencyTo	INT,		--The Id of the currency that is connected to the Exchange Rate you want to insert
	@YearMonth	INT,		--The Year and Month of the Exchange Rate you want to Insert
	@ConversionRate	DECIMAL(8,4),	--The Conversion Rate of the Exchange Rate you want to Insert,
	@IdCategory	INT		--The Category related to the Exchange rate you want to Insert
AS

--validation yearmonth section
Declare	@ErrorMessage		VARCHAR(255),
	@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end
--end validation section

	INSERT INTO EXCHANGE_RATES (IdCurrencyTo,[YearMonth],ConversionRate,IdCategory)
	VALUES		   	   (@IdCurrencyTo,@YearMonth,@ConversionRate,@IdCategory)
	
	--there is no unique id to return
	RETURN 1
GO

--Drops the Procedure catInsertFunction if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertFunction]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertFunction
GO
CREATE PROCEDURE catInsertFunction
	@Name		VARCHAR(50)	--The Name of the Function you want to Insert
	
AS
DECLARE @Id		INT

	SELECT @Id = ISNULL(MAX(F.[Id]), 0) + 1
	FROM [FUNCTIONS] AS F (TABLOCKX)

	INSERT INTO [FUNCTIONS] ([Id],[Name])
	VALUES		      	(@Id,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertGlAccount if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertGlAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertGlAccount
GO
CREATE PROCEDURE catInsertGlAccount
	@IdCountry	INT,
 	@Account	VARCHAR(20),	--The Code of the Inergy Location you want to Insert
	@Name		VARCHAR(30),	--The Name of the Inergy Location you want to Insert
	@IdCostType	INT		--The Id of the cost type related to the GL_ACCOUNT you want to insert
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	IF NOT EXISTS( SELECT *
	FROM COUNTRIES AS C(TABLOCKX)
	WHERE 	C.[Id] = @IdCountry) 
	BEGIN
		RAISERROR('The selected country does not exists anymore',16,1)
		RETURN
	END

	SET @LogicalKey = 'Country, Account'

	IF EXISTS( SELECT *
	FROM GL_ACCOUNTS AS GA(TABLOCKX)
	WHERE 	GA.Account = @Account AND 
		GA.IdCountry = @IdCountry) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @Account IS NULL OR 
	   @Name IS NULL OR 
	   @IdCostType IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(GA.[Id]), 0) + 1
	FROM GL_ACCOUNTS AS GA (TABLOCKX)
	WHERE IdCountry = @IdCountry 
	
	INSERT INTO GL_ACCOUNTS ([Id],IdCountry,Account,[Name],IdCostType)
	VALUES		   	(@Id,@IdCountry,@Account,@Name,@IdCostType)
	
	RETURN @Id
GO

--Drops the Procedure catInsertHourlyRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertHourlyRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertHourlyRate
GO
CREATE PROCEDURE catInsertHourlyRate
 	@IdCostCenter	INT,		--The Id of the Cost Center that is connected to the Hourly Rate you want to insert 	
	@YearMonth	INT,		--The Year and Month of the Hourly Rate you want to Insert
	@Value		DECIMAL(12,2) = NULL	--The Value of the Hourly Rate you want to Insert
AS

	IF NOT EXISTS( SELECT *
	FROM COST_CENTERS AS CC(TABLOCKX)
	WHERE 	CC.[Id] = @IdCostCenter) 
	BEGIN
		RAISERROR('The selected cost center does not exists anymore',16,1)
		RETURN -1
	END
	
--validation yearmonth section
Declare	@ErrorMessage		VARCHAR(255),
	@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -2
	end
--end validation section

DECLARE @ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(40)
	
	SET @LogicalKey = 'Year, Month, Cost Center'

	IF EXISTS( SELECT *
	FROM HOURLY_RATES AS HR(TABLOCKX)
	WHERE 	HR.YearMonth = @YearMonth AND
		HR.IdCostCenter = @IdCostCenter)
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3
	END

	IF(@IdCostCenter IS NULL OR 	  
	   @YearMonth IS NULL OR 
	   @Value IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -4		
	END

	INSERT INTO HOURLY_RATES (IdCostCenter,YearMonth,HourlyRate)
	VALUES		   	 (@IdCostCenter,@YearMonth,@Value)
	

GO

--Drops the Procedure catInsertInergyLocation if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertInergyLocation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertInergyLocation
GO
CREATE PROCEDURE catInsertInergyLocation
	@IdCountry	INT,
 	@Code		VARCHAR(3),	--The Code of the Inergy Location you want to Insert
	@Name		VARCHAR(50),	--The Name of the Inergy Location you want to Insert
	@Rank INT
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	IF NOT EXISTS( SELECT *
	FROM COUNTRIES AS C(TABLOCKX)
	WHERE 	C.[Id] = @IdCountry) 
	BEGIN
		RAISERROR('The selected country does not exists anymore',16,1)
		RETURN
	END

	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS IL(TABLOCKX)
	WHERE 	IL.[Code] = @Code) 
	SET @ValidateLogicKey = 1

	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @ValidateLogicKey =0
	SET @LogicalKey= 'Name'

	IF EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS IL
	WHERE 	IL.[Name] = @Name) 
	SET @ValidateLogicKey = 1

	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(IL.[Id]), 0) + 1
	FROM INERGY_LOCATIONS AS IL (TABLOCKX)
	
	exec @RetVal = catUpdateCatalogRank 'INERGY_LOCATIONS', @Rank,1,NULL

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO INERGY_LOCATIONS ([Id],IdCountry,Code,[Name], [Rank])
	VALUES		   	     (@Id,@IdCountry,@Code,@Name, @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertOrUpdateExchangeRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertOrUpdateExchangeRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertOrUpdateExchangeRate
GO
CREATE PROCEDURE catInsertOrUpdateExchangeRate
	@IdCategory			INT,		--The Category that is connected to the Exchange rate that is to be updated 
 	@CurrencyFrom			VARCHAR(3),	--The Id of the currency that is connected to the Exchange Rate you want to Update
	@Year				INT,		--The Year of the Exchange Rate you want to Update
	@Month				INT,		--The Month of the Exchange Rate you want to Update
	@NewExchangeRate		DECIMAL(9,4)	--The Value of the Exchange Rate you want to Update
	
AS
DECLARE @IdUpdate		INT,
	@IdCurrencyTo		INT,
	@YearMonth		INT,
	@ExchangeRateExists	BIT,
	@ErrorMessage		VARCHAR(255),
	@Rowcount		INT,
	@YMValidationResult	INT,
	@IndevCategoryId	INT
	
	SET @ExchangeRateExists = 0
	SET @YearMonth = @Year*100+@Month

	--verify if we have all the mandatory parameters
	IF(@IdCategory IS NULL OR 
	   @CurrencyFrom IS NULL OR 
	   @YearMonth IS NULL OR 
	   @NewExchangeRate IS NULL )
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1		
	END

	--verify if the exchangte rate category exists
	SELECT @IndevCategoryId = ERC.Id
	FROM EXCHANGE_RATE_CATEGORIES AS ERC(nolock)
	WHERE ERC.InFinanceCategoryId = @IdCategory
	
	IF(@IndevCategoryId IS NULL)
	BEGIN
		SET @ErrorMessage = 'The INFinance Exchange Rate Category ' + convert(varchar(10), @IdCategory) + ' does not exists in INDEV Exchange Rate Categories catalogue'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -2
	END


	--verify if the currency exists
	SELECT @IdCurrencyTo = C.[Id]
	FROM CURRENCIES AS C(nolock)
	WHERE UPPER(C.Code) = UPPER (@CurrencyFrom)  
	
	IF(@IdCurrencyTo IS NULL)
	BEGIN
		SET @ErrorMessage = 'The Currency ' + @CurrencyFrom + ' does not exists in INDEV Currencies catalogue'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -3
	END

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -4
	end

	-- verify the new exchange rate to be strict positive
	IF(@NewExchangeRate <= 0)
	BEGIN
		SET @ErrorMessage = 'The New Exchange Rate ' + convert(varchar(10), @NewExchangeRate) + ' is not a strict positive value'
		RAISERROR(@ErrorMessage, 16, 1)
		RETURN -5
	END

------------------End validation section -------------------------------



	--decide if we do an insert or update	
	IF EXISTS( SELECT *
	FROM EXCHANGE_RATES AS ER
	WHERE 	ER.IdCategory = @IndevCategoryId AND
		ER.YearMonth = @YearMonth AND
		ER.IdCurrencyTo = @IdCurrencyTo) 
	SET @ExchangeRateExists = 1

	IF (@ExchangeRateExists <> 1)
	BEGIN
		INSERT INTO EXCHANGE_RATES (IdCategory, YearMonth, IdCurrencyTo, ConversionRate)
		VALUES			   (@IndevCategoryId, @YearMonth, @IdCurrencyTo, 1 / @NewExchangeRate) 
	END
	ELSE
	BEGIN
		UPDATE EXCHANGE_RATES 	
		SET ConversionRate = (1 / @NewExchangeRate)	    
		WHERE IdCategory = @IndevCategoryId AND
		      IdCurrencyTo = @IdCurrencyTo AND
		      YearMonth = @YearMonth

	END

	SELECT 1 / @NewExchangeRate
GO
--Drops the Procedure catInsertOwner if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertOwner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertOwner
GO
CREATE PROCEDURE catInsertOwner
	@Code		VARCHAR(10),	--The Code of the Owner you want to Insert
	@Name		VARCHAR(30),	--The Name of the Owner you want to Insert
	@IdOwnerType	INT,		--The Type of the Owner
	@Rank		INT
	
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	--Owner Type catalogue does not have a UI so no chack should be done on this field

	SET @LogicalKey = 'Code'
	IF EXISTS( SELECT *
		FROM OWNERS AS O(nolock)
		WHERE 	O.Code = @Code) 
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @LogicalKey= 'Name'
	IF EXISTS( SELECT *
		FROM OWNERS AS O(nolock)
		WHERE 	O.Name = @Name) 
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END


	IF(@Code IS NULL OR 
	   @IdOwnerType IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3		
	END

	SELECT @Id = ISNULL(MAX(O.[Id]), 0) + 1
	FROM OWNERS AS O (TABLOCKX)
	
	exec @RetVal = catUpdateCatalogRank 'OWNERS', @Rank,1,NULL

	IF (@@ERROR<>0 OR @RetVal < 0)
		return -4

	INSERT INTO OWNERS ([Id],Code,[Name],IdOwnerType, [Rank])
	VALUES		   (@Id,@Code,@Name,@IdOwnerType, @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertPhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertPhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertPhase
GO
CREATE PROCEDURE catInsertPhase
	@Code	VARCHAR(3),	--The Code of the Phase you want to Insert
	@Name	VARCHAR(50)	--The Name of the Phase you want to Insert
	
AS
DECLARE @Id	INT

	SELECT @Id = ISNULL(MAX(P.[Id]), 0) + 1
	FROM PHASES AS P (TABLOCKX)
	
	INSERT INTO PHASES ([Id],Code,[Name])
	VALUES		   (@Id,@Code,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertProgram]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertProgram
GO
CREATE PROCEDURE catInsertProgram
	@IdOwner	INT,		--The Id of the Owner that is connected to the Program you want to insert
	@Code		VARCHAR(10),	--The Code of the Program you want to Insert
 	@Name		VARCHAR(50),	--The Name of the Program you want to Insert
	@IsActive	BIT,		--Shows if the Program is Active or not
	@Rank INT
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	IF NOT EXISTS( SELECT *
	FROM OWNERS AS O(TABLOCKX)
	WHERE 	O.[Id] = @IdOwner) 
	BEGIN
		RAISERROR('The selected owner does not exists anymore',16,1)
		RETURN
	END
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM PROGRAMS AS P
	WHERE 	P.Code = @Code) 
	SET @ValidateLogicKey = 1

	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdOwner IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(P.[Id]), 0) + 1
	FROM PROGRAMS AS P (TABLOCKX)

	exec @RetVal = catUpdateCatalogRank 'PROGRAMS', @Rank,1,NULL

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO PROGRAMS ([Id],Code,[Name],IdOwner,IsActive, [Rank])
	VALUES		     (@Id,@Code,@Name,@IdOwner,@IsActive, @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertProject
GO
CREATE PROCEDURE catInsertProject
	@Code		VARCHAR(10),	--The Code of the Project you want to Insert
	@Name		VARCHAR(50),	--The Name of the Project you want to Insert
	@IdProgram	INT,		--The Program related to this project
	@IdProjectType	INT,		--The type of the project 
	@IsActive	BIT,		--This option shos if the project is active or not
	@UseWorkPackageTemplate bit,
	@IdAssociate int
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	IF NOT EXISTS( SELECT *
	FROM PROGRAMS AS P(TABLOCKX)
	WHERE 	P.[Id] = @IdProgram) 
	BEGIN
		RAISERROR('The selected program does not exists anymore',16,1)
		RETURN
	END

	IF NOT EXISTS( SELECT *
	FROM PROJECT_TYPES AS PT(TABLOCKX)
	WHERE 	PT.[Id] = @IdProjectType) 
	BEGIN
		RAISERROR('The selected project type does not exists anymore',16,1)
		RETURN
	END

	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM PROJECTS AS P
	WHERE 	P.Code = @Code) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END


	IF(@Code IS NULL OR 
	   @IdProgram IS NULL OR 
	   @Name IS NULL OR 
	   @IdProjectType IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3		
	END

	SELECT @Id = ISNULL(MAX(P.[Id]), 0) + 1
	FROM PROJECTS AS P (TABLOCKX)
	
	INSERT INTO PROJECTS ([Id],Code,[Name],IdProgram,IdProjectType,IsActive)
	VALUES		     (@Id,@Code,@Name,@IdProgram,@IdProjectType,@IsActive)


	IF (@Id > 0 and @UseWorkPackageTemplate = 1)
	BEGIN

		EXEC   catInsertWorkPackagesfromTemplate  @Id, @IdAssociate 

		IF(@@ERROR<>0)
		begin
		RAISERROR('Add work package error',16,1)
		RETURN -4
		end
	END
	
	RETURN @Id
GO

--Drops the Procedure catInsertProjectPhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertProjectPhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertProjectPhase
GO
CREATE PROCEDURE catInsertProjectPhase
	@Code		VARCHAR(3),	--The Code of the ProjectPhase you want to Insert
	@Name		VARCHAR(50)	--The Name of the ProjectPhase you want to Insert
	
AS
DECLARE @Id	INT

	SELECT @Id = ISNULL(MAX(PP.[Id]), 0) + 1
	FROM PROJECT_PHASES AS PP (TABLOCKX)
	
	INSERT INTO PROJECT_PHASES ([Id],Code,[Name])
	VALUES		   	   (@Id,@Code,@Name)
	
	RETURN @Id
GO

--Drops the Procedure catInsertProjectType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertProjectType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertProjectType
GO
CREATE PROCEDURE catInsertProjectType
	@Type	VARCHAR(20),		--The Type of the Project Type you want to Insert
	@Rank	INT	
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Type'

	IF EXISTS( SELECT *
	FROM PROJECT_TYPES AS PT
	WHERE 	PT.[Type] = @Type) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Type IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(PT.[Id]), 0) + 1
	FROM PROJECT_TYPES AS PT (HOLDLOCK)
	
	exec @RetVal = catUpdateCatalogRank 'PROJECT_TYPES', @Rank,1,NULL

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO PROJECT_TYPES ([Id],Type, [Rank])
	VALUES		          (@Id,@Type, @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertRegion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertRegion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertRegion
GO
CREATE PROCEDURE catInsertRegion
	@Code	VARCHAR(8),	--The Code of thge Region you want to Insert
	@Name	VARCHAR(50),	--The Name of the Region you want to Insert
	@Rank INT		
	
AS
DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM REGIONS AS R
	WHERE 	R.Code = @Code) 
	SET @ValidateLogicKey = 1

	IF EXISTS( SELECT *
	FROM REGIONS AS R
	WHERE 	R.[Name] = @Name) 
	BEGIN
		SET @ValidateLogicKey = 1
		SET @LogicalKey= 'Name'
	END
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(R.[Id]), 0) + 1
	FROM REGIONS AS R (TABLOCKX)

	exec @RetVal = catUpdateCatalogRank 'Regions', @Rank,1,NULL

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO REGIONS ([Id],Code,[Name],[Rank])
	VALUES		    (@Id,@Code,@Name, @Rank)
	
	RETURN @Id
GO

--Drops the Procedure catInsertWorkPackage if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertWorkPackage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertWorkPackage
GO
CREATE PROCEDURE catInsertWorkPackage
	@IdPhase	INT,		--The Id of the Phase that is connected to the Work Package you want to insert
 	@Code		VARCHAR(3),	--The Code of the Work Package you want to Insert
	@Name		VARCHAR(50),	--The Name of the Work Package you want to Insert
	@Rank		INT,		--The Rank Number of the Work Package you want to Insert
	@IdProject	INT,		--The Project related to this Work Package
	@IsActive	BIT,		--Specifies if the Work Package is Active or not
	@StartYearMonth	INT,		--The Start Date of the work Package
	@EndYearMonth	INT,		--The End Date of the work Package
	@LastUserUpdate	INT		--The Last User Update of the work Package	
AS

	DECLARE @RetVal INT
	--The Phase catalogue does not have a UI so no check is required for this catalogue

	IF NOT EXISTS( SELECT *
	FROM PROJECTS AS P(TABLOCKX)
	WHERE 	P.[Id] = @IdProject) 
	BEGIN
		RAISERROR('The selected project does not exists anymore',16,1)
		RETURN
	END

	--validation yearmonth section
	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT
	
	if (@StartYearMonth is not null)
	begin
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@StartYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -1
		end
	end
	
	if (@EndYearMonth is not null)
	begin
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@EndYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -2
		end
	end
	--end validation section

DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(20)
	
	SET @LogicalKey = 'Code, Project'

	IF EXISTS( SELECT *
	FROM WORK_PACKAGES AS WP
	WHERE 	WP.Code = @Code AND
		WP.IdProject = @IdProject) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdPhase IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @Rank IS NULL OR 
	   @IdProject IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(WP.[Id]), 0) + 1
	FROM WORK_PACKAGES AS WP (TABLOCKX)
	WHERE 	WP.IdProject = @IdProject AND 
		WP.IdPhase = @IdPhase

	exec @RetVal = catUpdateWorkPackageRank 'WORK_PACKAGES', @Rank,1,NULL, @IdProject, @IdPhase

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO WORK_PACKAGES ([Id],IdPhase,Code,[Name], Rank, IdProject, IsActive, StartYearMonth, EndYearMonth, LastUpdate, LastUserUpdate)
	VALUES		          (@Id,@IdPhase,@Code,@Name,@Rank,@IdProject,@IsActive,@StartYearMonth,@EndYearMonth,GETDATE(),@LastUserUpdate)

	
	RETURN @Id
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[catInsertWorkPackagesFromTemplate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[catInsertWorkPackagesFromTemplate]
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE procedure catInsertWorkPackagesFromTemplate
	@IdProject int,
	@LastUserUpdate int 
as
declare @RetVal INT
Declare	@ErrorMessage		VARCHAR(255)

declare @IdPhase int
declare @Code varchar(3)
declare @Name varchar(30)
declare @Rank int
declare @IsActive bit
set @Rank = (select dbo.fnGetWorkPackageMaxRank())


declare WP_Template_Cursor CURSOR FAST_FORWARD FOR
select 
	IdPhase,
	Code, 
	[Name],
	IsActive
from WORK_PACKAGES_TEMPLATE
order by Rank
open WP_Template_Cursor
fetch next from WP_Template_Cursor
into @IdPhase, @Code, @Name, @IsActive
while @@fetch_status = 0
begin


	IF(@IdPhase IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @Rank IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1		
	END

	exec @RetVal =  catInsertWorkPackage 
			@IdPhase,
			@Code,
			@Name,
			@Rank,
			@IdProject,
			@IsActive,
			null,
			null,
			@LastUserUpdate	
			

	
	IF(@@ERROR<>0 OR @RetVal < 0)
	begin
		close WP_Template_Cursor
		deallocate WP_Template_Cursor
		return -2
	end	

	set @Rank = @Rank + 1


fetch next from WP_Template_Cursor
into @IdPhase, @Code, @Name, @IsActive
end
close WP_Template_Cursor
deallocate WP_Template_Cursor


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--Drops the Procedure catInsertWorkPackageTemplate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catInsertWorkPackageTemplate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catInsertWorkPackageTemplate
GO
CREATE PROCEDURE catInsertWorkPackageTemplate
	@IdPhase	INT,		--The Id of the Phase that is connected to the Work Package you want to insert
 	@Code		VARCHAR(3),	--The Code of the Work Package you want to Insert
	@Name		VARCHAR(50),	--The Name of the Work Package you want to Insert
	@Rank		INT,		--The Rank Number of the Work Package you want to Insert
	@IsActive	BIT,		--Specifies if the Work Package is Active or not
	@LastUserUpdate	INT		--The Last User Update of the work Package	
AS

	DECLARE @RetVal INT
	--The Phase catalogue does not have a UI so no check is required for this catalogue

	
	DECLARE @Id			INT,
	@ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(20),
	@ErrorMessage		VARCHAR(255)

	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM WORK_PACKAGES_TEMPLATE AS WP
	WHERE 	WP.Code = @Code) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdPhase IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @Rank IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	SELECT @Id = ISNULL(MAX(WP.[Id]), 0) + 1
	FROM WORK_PACKAGES_TEMPLATE AS WP (TABLOCKX)
	WHERE 	WP.IdPhase = @IdPhase

	exec @RetVal = catUpdateWorkPackageTemplateRank 'WORK_PACKAGES_TEMPLATE', @Rank,1,NULL, @IdPhase

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	INSERT INTO WORK_PACKAGES_TEMPLATE ([Id],IdPhase,Code,[Name], Rank, IsActive, LastUpdate, LastUserUpdate)
	VALUES		          (@Id,@IdPhase,@Code,@Name,@Rank,@IsActive,GETDATE(),@LastUserUpdate)

	
	RETURN @Id
GO

--Drops the Procedure catIsUserCountryChangeAllowed if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catIsUserCountryChangeAllowed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catIsUserCountryChangeAllowed
GO
CREATE PROCEDURE catIsUserCountryChangeAllowed
	@IdAssociate	INT		--The Id of the associate
AS
BEGIN
	--Check actual data
	IF 
	(
		EXISTS
		(
			SELECT	IdAssociate
			FROM	ACTUAL_DATA_DETAILS_COSTS
			WHERE	IdAssociate = @IdAssociate	
		)
		OR
		EXISTS
		(
			SELECT	IdAssociate
			FROM	ACTUAL_DATA_DETAILS_HOURS
			WHERE	IdAssociate = @IdAssociate	
		)
		OR
		EXISTS
		(
			SELECT	IdAssociate
			FROM	ACTUAL_DATA_DETAILS_SALES
			WHERE	IdAssociate = @IdAssociate	
		)
	)
	BEGIN
		RAISERROR('Country cannot be changed when actual data exists for associate.', 16, 1)
		RETURN -1
	END

	--Check initial budget
	IF EXISTS
	(
		SELECT	IdAssociate
		FROM	BUDGET_INITIAL_STATES
		WHERE	IdAssociate = @IdAssociate	
	)
	BEGIN
		RAISERROR('Country cannot be changed when initial budget data exists for associate.', 16, 1)
		RETURN -2
	END

	--Check revised budget
	IF EXISTS
	(
		SELECT	IdAssociate
		FROM	BUDGET_REVISED_STATES
		WHERE	IdAssociate = @IdAssociate	
	)
	BEGIN
		RAISERROR('Country cannot be changed when revised budget data exists for associate.', 16, 1)
		RETURN -3
	END

	--Check budget to completion
	IF EXISTS
	(
		SELECT	IdAssociate
		FROM	BUDGET_TOCOMPLETION_STATES
		WHERE	IdAssociate = @IdAssociate	
	)
	BEGIN
		RAISERROR('Country cannot be changed when budget to completion data exists for associate.', 16, 1)
		RETURN -4
	END
END
GO

--Drops the Procedure bgtMassInsertOrUpdateHourlyRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catMassInsertOrUpdateHourlyRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catMassInsertOrUpdateHourlyRate
GO
CREATE PROCEDURE catMassInsertOrUpdateHourlyRate
 	@IdInergyLocation	INT,			--The Id of the Cost Center that is connected to the Hourly Rate you want to insert 	
	@StartYearMonth		INT,			--The Year and Month of the Hourly Rate you want to Insert
	@EndYearMonth		INT,			--The Year and Month of the Hourly Rate you want to Insert	
	@Value			DECIMAL(12,2) = NULL	--The Value of the Hourly Rate you want to Insert
AS
DECLARE @IdCostCenter		INT,
	@CurrentCostCenter	INT,
	@EndYear		SMALLINT,	
	@EndMonth		SMALLINT,
	@StartMonth		SMALLINT,
	@StartYear		SMALLINT,
	@HourlyRate		DECIMAL(12,2),
	@Date			INT

	DECLARE @RetVal INT

	IF (@StartYearMonth > @EndYearMonth)
	BEGIN
		RAISERROR('Start Date cannot be greater than End Date',16,1)
		RETURN -1
	END

	--validation yearmonth section
	Declare	@ErrorMessage		VARCHAR(255),
		@YMValidationResult	INT
	
	if (@StartYearMonth <> -1)
	BEGIN
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@StartYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -2
		end
	END

	if (@EndYearMonth <> -1)
	begin
		-- verify if the yearmonth value is valid
		Select @YMValidationResult = ValidationResult,
		       @ErrorMessage = ErrorMessage
		from fnValidateYearMonth(@EndYearMonth)
	
		if (@YMValidationResult < 0)
		begin
		 	RAISERROR(@ErrorMessage, 16, 1)
			RETURN -3
		end
	end
--end validation section

	IF NOT EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS IL(TABLOCKX)
	WHERE 	IL.[Id] = @IdInergyLocation) 
	BEGIN
		RAISERROR('The selected Inergy Location does not exist',16,1)
		RETURN -4
	END

	DECLARE @UpdatedCCCount INT
	SELECT 	@UpdatedCCCount = COUNT(CC.[Id])
	FROM 	COST_CENTERS AS CC
	WHERE 	CC.IdInergyLocation = @IdInergyLocation AND
		CC.IsActive = 1

	DECLARE CostCenters CURSOR FAST_FORWARD FOR
	SELECT CC.[Id] 
	FROM COST_CENTERS AS CC
	WHERE 	CC.IdInergyLocation = @IdInergyLocation AND
		CC.IsActive = 1


	OPEN CostCenters
	FETCH NEXT FROM CostCenters 
	INTO @IdCostCenter

	WHILE @@FETCH_STATUS = 0 
	BEGIN

		SET @StartYear = @StartYearMonth / 100
		SET @StartMonth = @StartYearMonth % 100
		SET @EndYear = @EndYearMonth / 100
		SET @EndMonth = @EndYearMonth % 100
	
		WHILE ((@StartYear < @EndYear) OR (@StartYear = @EndYear AND @StartMonth <= @EndMonth))
		BEGIN
			SET @HourlyRate = NULL
			SET @Date = @StartYear * 100 + @StartMonth

			SELECT @HourlyRate = HR.HourlyRate
			FROM HOURLY_RATES AS HR
			WHERE 	HR.IdCostCenter = @IdCostCenter AND 
				HR.YearMonth = @Date 

			IF(ISNULL(@HourlyRate,-1) = -1)
			BEGIN
				EXEC @RetVal = catInsertHourlyRate @IdCostCenter = @IdCostCenter,
							 @YearMonth = @Date, 
							 @Value = @Value 
				IF (@@ERROR<>0 OR @RetVal < 0)
				BEGIN
					CLOSE CostCenters
					DEALLOCATE CostCenters
					RETURN -5
				END
			END
			ELSE 
			BEGIN
				EXEC @RetVal = catUpdateHourlyRate @IdCostCenter = @IdCostCenter,
							 @YearMonth = @Date, 
							 @Value = @Value
				IF (@@ERROR<>0 OR @RetVal < 0)
				BEGIN
					CLOSE CostCenters
					DEALLOCATE CostCenters
					RETURN -6
				END
			END
		
			IF(@StartMonth = 12)
			BEGIN
				SET @StartYear = @StartYear + 1
				SET @StartMonth = 1
			END
			ELSE
			BEGIN
				SET @StartMonth = @StartMonth + 1
			END

		END

		FETCH NEXT FROM CostCenters 
		INTO @IdCostCenter
	END
	CLOSE CostCenters
	DEALLOCATE CostCenters

	RETURN @UpdatedCCCount
GO

--Drops the Procedure catSelectAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectActiveAssociates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectActiveAssociates
GO
CREATE PROCEDURE catSelectActiveAssociates
	@IdCountry 	INT
AS
	SELECT 	
		C.Name			AS 'CountryName',
		A.EmployeeNumber	AS 'EmployeeNumber',
		A.Name			AS 'Name',
		A.InergyLogin		AS 'InergyLogin',
		A.IsActive		AS 'IsActive',
		A.PercentageFullTime 	AS 'PercentageFullTime',
		A.IsSubContractor 	AS 'IsSubContractor',
		A.Id			AS 'Id',
		A.IdCountry		AS 'IdCountry'
	FROM ASSOCIATES AS A(nolock)
	INNER JOIN COUNTRIES AS C(nolock)
		ON A.IdCountry = C.Id
	WHERE 	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
		ISNULL(C.IdRegion,0) <> 0 AND
		A.IsActive = 1
	ORDER BY A.Name
GO
--Drops the Procedure catSelectAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectAssociate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectAssociate
GO
CREATE PROCEDURE catSelectAssociate
	@Id 		AS INT, 	--The Id of the selected Associate
	@IdCountry	AS INT 		--The Id of the Country selected for this Associate
AS
	SELECT 	
		C.Name			AS 'CountryName',
		A.EmployeeNumber	AS 'EmployeeNumber',
		A.Name			AS 'Name',
		A.InergyLogin		AS 'InergyLogin',
		A.IsActive		AS 'IsActive',
		A.PercentageFullTime 	AS 'PercentageFullTime',
		A.IsSubContractor 	AS 'IsSubContractor',
		A.Id			AS 'Id',
		A.IdCountry		AS 'IdCountry'
	FROM ASSOCIATES AS A(nolock)
	INNER JOIN COUNTRIES AS C(nolock)
		ON A.IdCountry = C.Id
	WHERE 	A.Id = case when @Id=-1 then A.Id else @Id end AND
		A.IdCountry = case when @IdCountry=-1 then A.IdCountry else @IdCountry end AND
		ISNULL(C.IdRegion,0) <> 0 AND
		A.InergyLogin <> C.Code + '\null'
	ORDER BY C.Name, A.Name
GO
--Drops the Procedure catSelectBudgetPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectBudgetPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectBudgetPeriod
GO
CREATE PROCEDURE catSelectBudgetPeriod
	@Id AS INT 	--The Id of the selected Budget Period
AS
	--If @Id has the value -1, it will return all Budget Periods
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			BP.Code		AS 'Code',
			BP.Id		AS 'Id',
			BP.Name		AS 'Name'
		FROM BUDGET_PERIODS AS BP(nolock)
		
		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Budget Period
	SELECT 	BP.Id		AS 'Id',
		BP.Code 	AS 'Code',
		BP.Name		AS 'Name'
	FROM BUDGET_PERIODS AS BP(nolock)
	WHERE BP.Id = @Id
GO

--Drops the Procedure catSelectCostCenter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCostCenter]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCostCenter
GO
CREATE PROCEDURE catSelectCostCenter
	@Id AS INT, 	--The Id of the selected Cost Center
	@IdInergyLocation AS INT --The Id of the selected Inergy Location
AS
	--If @Id has the value -1, it will return all Cost Centers
	SELECT 	
		
		IL.Name			AS 'InergyLocation',
		CC.Code			AS 'Code',
		CC.Name			AS 'Name',
		CC.IsActive		AS 'IsActive',
		D.Name			AS 'DepartmentName',
		F.Name			AS 'FunctionName',
		CC.Id			AS 'Id',	
		CC.IdInergyLocation	AS 'IdInergyLocation',	
		CC.IdDepartment		AS 'IdDepartment',
		F.Id			AS 'IdFunction'
	FROM COST_CENTERS AS CC(nolock)
	INNER JOIN INERGY_LOCATIONS AS IL(nolock)
		ON CC.IdInergyLocation = IL.[Id]
	INNER JOIN DEPARTMENTS AS D(nolock)
		ON CC.IdDepartment = D.[Id]
	INNER JOIN FUNCTIONS AS F(nolock)
		ON D.IdFunction = F.[Id]
	WHERE CC.Id = CASE @Id WHEN -1 THEN CC.Id ELSE @Id END
		AND CC.IdInergyLocation = CASE @IdInergyLocation WHEN -1 THEN CC.IdInergyLocation 
										ELSE @IdInergyLocation END
	ORDER BY CC.Name
GO

--Drops the Procedure catSelectCostCenterCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCostCenterCurrency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCostCenterCurrency
GO
CREATE PROCEDURE catSelectCostCenterCurrency
	@Id AS INT 	--The Id of the selected Cost Center
AS
	SELECT
		CR.Code		AS	'CurrencyCode',
		CR.Name		AS	'CurrencyName',
		CR.[Id]		AS	'IdCurrency'
	FROM COST_CENTERS AS CC(nolock)
	INNER JOIN INERGY_LOCATIONS AS IL(nolock)
		ON CC.IdInergyLocation = IL.[Id]
	INNER JOIN COUNTRIES AS CT(nolock) 
		ON CT.[Id] = IL.IdCountry
	INNER JOIN CURRENCIES AS CR(nolock) 
		ON CR.[Id] = CT.IdCurrency
	WHERE CC.[Id] = @Id
GO



--Drops the Procedure catSelectCostIncomeType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCostIncomeType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCostIncomeType
GO
CREATE PROCEDURE catSelectCostIncomeType
	@Id AS INT 	--The Id of the selected Cost Income Type
AS
	--If @Id has the value -1, it will return all Cost Income Types
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			CIT.Name	AS 'Name',
			CIT.Id		AS 'Id',
			CIT.DefaultAccount AS 'DefaultAccount'
		FROM COST_INCOME_TYPES CIT(nolock)
		ORDER BY Rank
		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Cost Income Type
	SELECT 	CIT.Id		AS 'Id',
		CIT.Name	AS 'Name',
		CIT.DefaultAccount AS 'DefaultAccount'
	FROM COST_INCOME_TYPES CIT(nolock)
	WHERE CIT.Id = @Id
GO

--Drops the Procedure catSelectCountry if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCountry]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCountry
GO
CREATE PROCEDURE catSelectCountry
	@Id AS INT 	--The Id of the selected Country
AS
	--If @Id has the value -1, it will return all Countries
	--if @id has the value -2 it will return new rank
IF @Id=-1
BEGIN
	SELECT 	
		C.Code		AS 'Code',
		C.Name		AS 'Name',
		R.Name		AS 'RegionName',
		CR.Name		AS 'CurrencyName',
		C.Email		AS 'Email',
		C.Rank		AS 'Rank',
		C.Id		AS 'Id',
		C.IdRegion	AS 'IdRegion',
		C.IdCurrency	AS 'IdCurrency'
		
	FROM COUNTRIES AS C(nolock)
	INNER JOIN CURRENCIES AS CR(nolock)
		ON C.IdCurrency = CR.Id
	LEFT JOIN REGIONS AS R(nolock)
		ON C.IdRegion = R.Id
	ORDER BY C.Rank
END
IF @Id=-2
BEGIN
	SELECT 	
		CAST(NULL AS VARCHAR(3))	AS 'Code',
		CAST(NULL AS VARCHAR(30))	AS 'Name',
		CAST(NULL AS VARCHAR(30))	AS 'RegionName',
		CAST(NULL AS VARCHAR(30))	AS 'CurrencyName',
		CAST(NULL AS INT)		AS 'Id',
		CAST(NULL AS INT)		AS 'IdRegion',
		CAST(NULL AS INT)		AS 'IdCurrency',
		CAST(NULL AS VARCHAR(30))	AS 'Email',
		ISNULL(MAX(C.Rank),0)+1		AS 'Rank'
	FROM COUNTRIES AS C(nolock)
	INNER JOIN CURRENCIES AS CR(nolock)
		ON C.IdCurrency = CR.Id
	LEFT JOIN REGIONS AS R(nolock)
		ON C.IdRegion = R.Id
	
END

IF @ID>0
BEGIN
	SELECT 	
		C.Code		AS 'Code',
		C.Name		AS 'Name',
		R.Name		AS 'RegionName',
		CR.Name		AS 'CurrencyName',
		C.Email		AS 'Email',
		C.Rank		AS 'Rank',
		C.Id		AS 'Id',
		C.IdRegion	AS 'IdRegion',
		C.IdCurrency	AS 'IdCurrency'
				
	FROM COUNTRIES AS C(nolock)
	INNER JOIN CURRENCIES AS CR(nolock)
		ON C.IdCurrency = CR.Id
	LEFT JOIN REGIONS AS R(nolock)
		ON C.IdRegion = R.Id
	WHERE C.Id =  @Id
END

GO

--Drops the Procedure catSelectCountry_InergyLocation if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCountry_InergyLocation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCountry_InergyLocation
GO
CREATE PROCEDURE catSelectCountry_InergyLocation
	@Id AS INT, 	--The Id of the  selected country
	@IdInergyLocation AS INT --The Id of the selected inergylocation
AS
	--If @Id has the value -1, it will return all Countries
	IF @IdInergyLocation = -1
		SELECT 	C.Id		AS 'Id',		
			C.Name		AS 'Name'		
		FROM COUNTRIES AS C(nolock)	
		LEFT JOIN INERGY_LOCATIONS IL
			ON C.ID = IL.IdCountry 
		WHERE C.Id =CASE @Id
					WHEN -1 THEN C.Id
					ELSE @Id
					END	
		GROUP BY C.Id, C.Name
		ORDER BY C.Name
	ELSE
		SELECT 	C.Id		AS 'Id',		
			C.Name		AS 'Name'		
		FROM COUNTRIES AS C(nolock)	
		LEFT JOIN INERGY_LOCATIONS IL
			ON C.ID = IL.IdCountry 
		WHERE ISNULL(IL.Id,0) =@IdInergyLocation
		GROUP BY C.Id, C.Name
		ORDER BY C.Name
GO
--Drops the Procedure catSelectCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCurrency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCurrency
GO
CREATE PROCEDURE catSelectCurrency
	@Id AS INT 	--The Id of the selected Currency
AS
	--If @Id has the value -1, it will return all Currency
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			C.Code		AS 'Code',
			C.Name		AS 'Name',
			C.Id		AS 'Id'
		FROM CURRENCIES C(nolock)
	END

	--If @Id doesn't have the value -1 or -2 it will return the selected Currencies
	SELECT 	C.Id		AS 'Id',
		C.Code 		AS 'Code',
		C.Name		AS 'Name'
	FROM CURRENCIES C(nolock)
	WHERE C.Id = @Id
GO

--Drops the Procedure catSelectCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectCurrencyForDisplay]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectCurrencyForDisplay
GO
CREATE PROCEDURE catSelectCurrencyForDisplay
as

declare @t table (Id int, Code varchar(4))

insert into @t
SELECT 	C.Id,
	C.Code
FROM CURRENCIES C(nolock)
where Code in ('EUR', 'USD')
order by Id

insert into @t
SELECT 	C.Id,
	C.Code
FROM CURRENCIES C(nolock)
WHERE C.Code not in ('EUR', 'USD', 'GBP', 'SKK', 'ZAR', 'IRR', 'RUB')
order by Code

select * from @t

GO

--Drops the Procedure catSelectDepartment if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectDepartment]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectDepartment
GO
CREATE PROCEDURE catSelectDepartment
	@Id AS INT 	--The Id of the selected Department
AS
	--If @Id has the value -1, it will return all Departments

IF @Id=-1
BEGIN
	SELECT 	
		D.Name		AS 'Name',
		F.Name		AS 'FunctionName',
		D.Rank		AS 'Rank',
		D.Id		AS 'Id',
		D.IdFunction	AS 'IdFunction'
	FROM DEPARTMENTS AS D(nolock)
	INNER JOIN [FUNCTIONS] AS F(nolock)
		ON D.IdFunction = F.Id
	ORDER BY D.Rank

END

IF @Id=-2
BEGIN
	SELECT 	
		CAST(NULL AS VARCHAR(30))		AS 'Name',
		CAST(NULL AS VARCHAR(30))		AS 'FunctionName',
		ISNULL(MAX(D.Rank),0)+1			AS 'Rank',
		CAST(NULL AS INT)			AS 'Id',
		CAST(NULL AS INT)			AS 'IdFunction'
	FROM DEPARTMENTS AS D(nolock)
	INNER JOIN [FUNCTIONS] AS F(nolock)
		ON D.IdFunction = F.Id
END

IF @Id>0
BEGIN
	SELECT 	
		D.Name		AS 'Name',
		F.Name		AS 'FunctionName',
		D.Rank		AS 'Rank',
		D.Id		AS 'Id',
		D.IdFunction	AS 'IdFunction'
	FROM DEPARTMENTS AS D(nolock)
	INNER JOIN [FUNCTIONS] AS F(nolock)
		ON D.IdFunction = F.Id
	WHERE D.Id = @Id
END
GO

--Drops the Procedure catSelectExchangeRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectExchangeRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectExchangeRate
GO
CREATE PROCEDURE catSelectExchangeRate
	@Id AS INT 	--The Id of the selected Exchange Rate
AS
	--If @Id has the value -1, it will return all Exchange Rates
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			ER.[Year]				AS 'Year',
			ER.[Month]				AS 'Month',
			CAST(ER.ConversionRate AS DECIMAL(9,2))	AS 'ConversionRate',
			C.[Name]				AS 'Currency',
			CAT.[Name]				AS 'Category',
			ER.[Id]					AS 'Id',
			ER.IdCurrencyTo				AS 'IdCurrencyTo'
		FROM EXCHANGE_RATES ER(nolock)
		INNER JOIN CURRENCIES C(nolock)
			ON ER.IdCurrencyTo = C.[Id]	
		INNER JOIN CATEGORIES CAT(nolock)
			ON ER.IdCategory = CAT.[Id]

		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Exchange Rates
	SELECT 	ER.[Id]					AS 'Id',
		ER.[Year]				AS 'Year',
		ER.[Month]				AS 'Month',
		ER.IdCurrencyTo				AS 'IdCurrencyTo',
		CAST(ER.ConversionRate AS DECIMAL(9,2))	AS 'ConversionRate',
		C.[Name]				AS 'Currency',
		CAT.[Name]				AS 'Category'
	FROM EXCHANGE_RATES ER(nolock)
	INNER JOIN CURRENCIES C(nolock)
		ON ER.IdCurrencyTo = C.[Id]	
	INNER JOIN CATEGORIES CAT(nolock)
		ON ER.IdCategory = CAT.[Id]
	WHERE ER.[Id] = @Id
GO

--Drops the Procedure catSelectExchangeRates if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectExchangeRates]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectExchangeRates
GO
CREATE PROCEDURE catSelectExchangeRates
	@Year AS INT
AS

		CREATE TABLE #TempExchangeRates
	(
		IdCurrency int,
		Currency varchar(3),
		BudgetExchangeRate decimal(9,4),
		January decimal(9,4),
		February decimal(9,4),
		March decimal(9,4),
		April decimal(9,4),
		May decimal(9,4),
		June decimal(9,4),
		July decimal(9,4),
		August decimal(9,4),
		September decimal(9,4),
		October decimal(9,4),
		November decimal(9,4),
		December decimal(9,4)
	)

	INSERT INTO #TempExchangeRates
	SELECT
		C.Id as IdCurrency,
		C.Code AS Currency,	
		0 as 'BudgetExchangeRate',			  	  
		0 AS  'January',
		0 AS  'February',
		0 AS  'March',
		0 AS  'April',
		0 AS  'May',
		0 AS  'June',
		0 AS  'July',
		0 AS  'August',
		0 AS  'September',
		0 AS  'October',
		0 AS  'November',
		0 AS  'December'
	FROM CURRENCIES C

	UPDATE T
	SET T.BudgetExchangeRate = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 2 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 1

	UPDATE T
	SET T.January = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 1

	UPDATE T
	SET T.February = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 2

	UPDATE T
	SET T.March = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 3

	UPDATE T
	SET T.April = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 4

	UPDATE T
	SET T.May = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 5

	UPDATE T
	SET T.June = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 6

	UPDATE T
	SET T.July = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 7

	UPDATE T
	SET T.August = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 8

	UPDATE T
	SET T.September = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 9

	UPDATE T
	SET T.October = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 10

	UPDATE T
	SET T.November = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 11

	UPDATE T
	SET T.December = ER.ConversionRate
	FROM #TempExchangeRates T
	INNER JOIN EXCHANGE_RATES ER ON ER.IdCurrencyTo = T.IdCurrency
	WHERE 	ER.IdCategory = 1 AND
		ER.YearMonth / 100 = @Year AND
		ER.YearMonth % 100 = 12			
	
	SELECT IdCurrency,
		   Currency,
		   BudgetExchangeRate,
		   January,
		   February,
		   March,
		   April,
		   May,
		   June,
		   July,
		   August,
		   September,
		   October,
		   November,
		   December
	FROM #TempExchangeRates
	ORDER BY Currency

GO

--Drops the Procedure catSelectFunction if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectFunction]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectFunction
GO
CREATE PROCEDURE catSelectFunction
	@Id AS INT 	--The Id of the selected Function
AS
	--If @Id has the value -1, it will return all Functions
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			F.[Name]	AS 'Name',
			F.[Id]		AS 'Id'
		FROM FUNCTIONS F(nolock)
		ORDER BY F.Rank

		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Function
	SELECT 	F.[Id]		AS 'Id',
		F.[Name]	AS 'Name'
	FROM FUNCTIONS AS F(nolock)
	WHERE F.[Id] = @Id
GO

--Drops the Procedure catSelectGlAccount if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectGlAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectGlAccount
GO
CREATE PROCEDURE catSelectGlAccount
	@Id 		AS INT, 	--The Id of the selected GlAccount
	@IdCountry	AS INT		--The Id of the Country associated to this GLAccount
AS
	--it will return the selected GlAccount(s)
	SELECT 	
		C.Name		AS 'CountryName',
		GL.Account	AS 'G/L Account',
		GL.Name		AS 'Name',
		CT.Name		AS 'CostType',
		GL.Id		AS 'Id',
		GL.IdCountry	AS 'IdCountry',
		GL.IdCostType	AS 'IdCostType'
	FROM GL_ACCOUNTS GL(nolock)
	INNER JOIN COUNTRIES C(nolock)
		ON GL.IdCountry = C.Id
	INNER JOIN COST_INCOME_TYPES  CT(nolock)
		ON GL.IdCostType = CT.Id
	WHERE 	GL.[Id] = CASE WHEN @Id = -1 THEN GL.Id ELSE @Id END AND 
		GL.IdCountry = CASE WHEN  @IdCountry = -1 THEN GL.IdCountry ELSE @IdCountry END
	ORDER BY C.Name, GL.Account
GO

--Drops the Procedure catSelectHourlyRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectHourlyRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectHourlyRate
GO

-- exec catSelectHourlyRate @YearMonth = NULL, @IdCostCenter = -1, @IdCountry = -1
CREATE PROCEDURE catSelectHourlyRate
	@YearMonth	AS INT, 	--The Year of the selected Hourly Rate	
	@IdCostCenter	AS INT,		--The IdCostCenter of the selected Hourly Rate
	@IdCountry	AS INT		--The IdCountry of the selected Hourly Rate
AS
	--If @Id has the value -1, it will return all Hourly Rates
	IF (@YearMonth IS NULL AND @IdCostCenter = -1)
	BEGIN 
		SELECT DISTINCT
			IL.Name		AS 'InergyLocationName',
			CC.[Code]	AS 'CostCenterCode',
			C.Name		AS 'CurrencyName',
			HR.HourlyRate	AS 'Value',
			CO.Id		AS 'IdCountry',
			HR.YearMonth	AS 'YearMonth',
			CC.[Name]	AS 'CostCenterName',
			IL.ID		AS 'IdInergyLocation',
			HR.IdCostCenter	AS 'IdCostCenter',
			C.Id		AS 'IdCurrency'
		FROM HOURLY_RATES HR(NOLOCK)		
		INNER JOIN COST_CENTERS CC(NOLOCK)
			ON HR.IdCostCenter = CC.[Id]
		INNER JOIN INERGY_LOCATIONS IL(NOLOCK)
			ON CC.IdInergyLocation = IL.Id
		INNER JOIN COUNTRIES CO(NOLOCK)
			ON IL.IdCountry = CO.Id
		INNER JOIN CURRENCIES C
			ON CO.IdCurrency  = C.Id
		WHERE CO.[Id] = CASE WHEN @IdCountry = -1 THEN CO.[Id] ELSE @IdCountry END
		ORDER BY HR.YearMonth, HR.IdCostCenter
		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Hourly Rates
	SELECT 
		IL.Name		AS 'InergyLocationName',
		CC.[Code]	AS 'CostCenterCode',
		C.Name		AS 'CurrencyName',
		HR.HourlyRate	AS 'Value',
		CO.Id		AS 'IdCountry',
		HR.YearMonth	AS 'YearMonth',
		CC.[Name]	AS 'CostCenterName',
		IL.ID		AS 'IdInergyLocation',
		HR.IdCostCenter	AS 'IdCostCenter',
		C.Id		AS 'IdCurrency'
		FROM HOURLY_RATES HR(NOLOCK)		
		INNER JOIN COST_CENTERS CC(NOLOCK)
			ON HR.IdCostCenter = CC.[Id]
		INNER JOIN INERGY_LOCATIONS IL(NOLOCK)
			ON CC.IdInergyLocation = IL.Id
		INNER JOIN COUNTRIES CO(NOLOCK)
			ON IL.IdCountry = CO.Id
		INNER JOIN CURRENCIES C
			ON CO.IdCurrency  = C.Id
	WHERE CO.[Id] = CASE WHEN @IdCountry = -1 THEN CO.[Id] ELSE @IdCountry END AND
		HR.YearMonth = @YearMonth AND
		HR.IdCostCenter = @IdCostCenter
	ORDER BY HR.YearMonth, HR.IdCostCenter
GO

--Drops the Procedure catSelectInergyCountry if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectInergyCountry]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectInergyCountry
GO
CREATE PROCEDURE catSelectInergyCountry
	@Id AS INT 	--The Id of the selected Country
AS
	--If @Id has the value -1, it will return all Countries
	SELECT 	
		C.Code		AS 'Code',
		C.[Name]	AS 'Name',
		R.[Name]	AS 'RegionName',
		CR.[Name]	AS 'CurrencyName',
		C.[Id]		AS 'Id',
		C.IdRegion	AS 'IdRegion',
		C.IdCurrency	AS 'IdCurrency',
		C.Email		AS 'Email'
	FROM COUNTRIES AS C(nolock)
	INNER JOIN CURRENCIES AS CR(nolock)
		ON C.IdCurrency = CR.[Id]
	INNER JOIN REGIONS AS R(nolock)
		ON C.IdRegion = R.[Id]
	WHERE C.Id = CASE @Id WHEN -1 THEN C.Id ELSE @Id END
	ORDER BY C.Rank
GO

--Drops the Procedure catSelectInergyLocation if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectInergyLocation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectInergyLocation
GO
CREATE PROCEDURE catSelectInergyLocation
	@Id AS INT 	--The Id of the selected Inergy Location
AS
	--If @Id has the value -1, it will return all Inergy Locations
IF @Id=-1
BEGIN
	SELECT 	
		IL.Code		AS 'Code',
		IL.Name		AS 'Name',
		C.Name		AS 'CountryName',
		IL.Rank		AS 'Rank',
		CURR.Name	AS 'CurrencyName',
		IL.Id		AS 'Id',
		IL.IdCountry	AS 'IdCountry',
		CURR.Id		As 'IdCurrency'
	FROM INERGY_LOCATIONS IL(nolock)
	INNER JOIN COUNTRIES C(nolock)
		ON IL.IdCountry	= C.Id
	LEFT JOIN CURRENCIES CURR ON C.IdCurrency = CURR.Id
	ORDER BY IL.Rank
END
IF @Id=-2
BEGIN
	SELECT 	
		CAST(NULL AS VARCHAR(8))	AS 'Code',
		CAST(NULL AS VARCHAR(30))	AS 'Name',
		CAST(NULL AS VARCHAR(30))	AS 'CountryName',
		ISNULL(MAX(IL.Rank),0)+1	AS 'Rank',
		CAST(NULL AS VARCHAR(30))	AS 'CurrencyName',
		CAST(NULL AS INT)		AS 'Id',
		CAST(NULL AS INT)		AS 'IdCountry',
		CAST(NULL AS INT)		As 'IdCurrency'
	FROM INERGY_LOCATIONS IL(nolock)
	INNER JOIN COUNTRIES C(nolock)
		ON IL.IdCountry	= C.Id
	LEFT JOIN CURRENCIES CURR ON C.IdCurrency = CURR.Id
	
END

IF @Id>0
BEGIN
	SELECT 	
		IL.Code		AS 'Code',
		IL.Name		AS 'Name',
		C.Name		AS 'CountryName',
		IL.Rank		AS 'Rank',
		CURR.Name	AS 'CurrencyName',
		IL.Id		AS 'Id',
		IL.IdCountry	AS 'IdCountry',
		CURR.Id		As 'IdCurrency'
	FROM INERGY_LOCATIONS IL(nolock)
	INNER JOIN COUNTRIES C(nolock)
		ON IL.IdCountry	= C.Id
	LEFT JOIN CURRENCIES CURR ON C.IdCurrency = CURR.Id
	WHERE IL.Id = @Id
END

GO

--Drops the Procedure catSelectInergyLocation_Country if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectInergyLocation_Country]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectInergyLocation_Country
GO
CREATE PROCEDURE catSelectInergyLocation_Country
	@Id AS INT 	--The Id of the selected Id Country
AS
	--If @Id has the value -1, it will return all Inergy Locations
	SELECT 	IL.Id		AS 'Id',
		IL.IdCountry	AS 'IdCountry',
		IL.Code		AS 'Code',
		IL.Name		AS 'Name',
		C.Name		AS 'CountryName',
		CURR.Id		As 'IdCurrency',
		CURR.Name	AS 'CurrencyName'
	FROM INERGY_LOCATIONS IL(nolock)
	INNER JOIN COUNTRIES C(nolock)
		ON IL.IdCountry	= C.Id
	LEFT JOIN CURRENCIES CURR ON C.IdCurrency = CURR.Id
	WHERE IL.IdCountry = CASE @Id WHEN -1 THEN IL.IDCountry ELSE @Id END
-- 	WHERE IL.Id = CASE @Id WHEN -1 THEN IL.Id ELSE @Id END
	ORDER BY IL.Name
GO

--Drops the Procedure catSelectIntercoCountries if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectIntercoCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectIntercoCountries
GO
CREATE PROCEDURE catSelectIntercoCountries
	@IdProject 	AS INT 	--The IdProject of the project
AS
	--Given a project, returns the Countries that have interco for this project
	SELECT 	C.[Id],
		C.[Code],
		C.[Name],
		C.Email
	FROM 	COUNTRIES AS C
	INNER 	JOIN PROJECTS_INTERCO_LAYOUT AS PIL
	ON	C.[Id] = PIL.IdCountry
	WHERE	PIL.IdProject = @IdProject
GO

--Drops the Procedure catSelectOwner if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectOwner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectOwner
GO
CREATE PROCEDURE catSelectOwner
	@Id AS INT 	--The Id of the selected Owner
AS
	--If @Id has the value -1, it will return all Owners

IF @Id=-1
BEGIN
	SELECT 	
		O.Code 		AS 'Code',
		O.Name		AS 'Name',
		OT.Name		AS 'OwnerType',
		O.Rank		AS 'Rank',
		O.Id		AS 'Id',
		O.IdOwnerType	AS 'IdOwnerType'
	FROM OWNERS AS O(nolock)
	INNER JOIN OWNER_TYPES AS OT(nolock)
		ON O.IdOwnerType = OT.[Id]	
	ORDER BY O.Rank

END

IF @Id=-2
BEGIN
	SELECT 	
		CAST(NULL AS VARCHAR(10)) 		AS 'Code',
		CAST(NULL AS VARCHAR(30))		AS 'Name',
		CAST(NULL AS VARCHAR(50))		AS 'OwnerType',
		ISNULL(MAX(O.Rank),0) + 1		AS 'Rank',		
		CAST(NULL AS INT)			AS 'Id',
		CAST(NULL AS INT)			AS 'IdOwnerType'
	FROM OWNERS AS O(nolock)
	INNER JOIN OWNER_TYPES AS OT(nolock)
		ON O.IdOwnerType = OT.[Id]
END

IF @Id>0
BEGIN
	SELECT 	
		O.Code 		AS 'Code',
		O.Name		AS 'Name',
		OT.Name	AS 	'OwnerType',
		O.Rank		AS 'Rank',
		O.Id		AS 'Id',
		O.IdOwnerType	AS 'IdOwnerType'
	FROM OWNERS AS O(nolock)
	INNER JOIN OWNER_TYPES AS OT(nolock)
		ON O.IdOwnerType = OT.[Id]
	WHERE O.Id = @Id
END

GO

--Drops the Procedure catSelectOwnerType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectOwnerType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectOwnerType
GO
CREATE PROCEDURE catSelectOwnerType
	@Id AS INT 	--The Id of the selected Function
AS
	--If @Id has the value -1, it will return all Owner Types
	IF (@Id = -1)
	BEGIN 
		SELECT 	
			OT.[Name]	AS 'Name',
			OT.[Id]		AS 'Id'
		FROM OWNER_TYPES OT(nolock)
	
		RETURN
	END

	--If @Id doesn't have the value -1 it will return the selected Owner Type
	SELECT 	OT.[Id]		AS 'Id',
		OT.[Name]	AS 'Name'
	FROM OWNER_TYPES OT(nolock)
	WHERE OT.[Id] = @Id
GO

--Drops the Procedure catSelectProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectProgram]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectProgram
GO
CREATE PROCEDURE catSelectProgram
	@Id AS INT, 	--The Id of the selected Program
	@OnlyActive AS BIT --flag to take only active programs or not
AS

	--return only active programs
	--If @Id has the value -1, it will return all Programs

IF @Id=-1
BEGIN
	SELECT 	
		P.Code 		AS 'Code',
		P.Name		AS 'Name',
		O.Name		AS 'OwnerName',
		OT.Name		AS 'OwnerType',
		P.IsActive	AS 'IsActive',
		P.Rank		AS 'Rank',
		P.Id		AS 'Id',
		P.IdOwner	AS 'IdOwner',
		OT.Id		AS 'IdOwnerType'
	FROM PROGRAMS P(nolock)
	INNER JOIN OWNERS O(nolock)
		ON P.IdOwner = O.Id
	INNER JOIN OWNER_TYPES OT(nolock)
		ON O.IdOwnerType = OT.Id
	WHERE ISNULL(P.IsActive,0) = CASE @OnlyActive WHEN 0 THEN ISNULL(P.IsActive,0) ELSE 1  END
	ORDER BY P.Rank

END

IF @Id=-2
BEGIN
	
	SELECT 	
		CAST(NULL AS VARCHAR(10)) 		AS 'Code',
		CAST(NULL AS VARCHAR(50))		AS 'Name',
		CAST(NULL AS VARCHAR(30))		AS 'OwnerName',
		CAST(NULL AS VARCHAR(50))		AS 'OwnerType',
		CAST(NULL AS BIT)			AS 'IsActive',
		ISNULL(MAX(P.Rank),0) + 1		AS 'Rank',
		CAST(NULL AS INT)			AS 'Id',
		CAST(NULL AS INT)			AS 'IdOwner',
		CAST(NULL AS INT)			AS 'IdOwnerType'
	FROM PROGRAMS P(nolock)
	INNER JOIN OWNERS O(nolock)
		ON P.IdOwner = O.Id
	INNER JOIN OWNER_TYPES OT(nolock)
		ON O.IdOwnerType = OT.Id
	WHERE ISNULL(P.IsActive,0) = CASE @OnlyActive WHEN 0 THEN ISNULL(P.IsActive,0) ELSE 1  END
	--ORDER BY P.Rank
	
END

IF @Id>0
BEGIN
	SELECT 	
		P.Code 		AS 'Code',
		P.Name		AS 'Name',
		O.Name		AS 'OwnerName',
		OT.Name		AS 'OwnerType',
		P.IsActive	AS 'IsActive',
		P.Rank		AS 'Rank',
		P.Id		AS 'Id',
		P.IdOwner	AS 'IdOwner',
		OT.Id		AS 'IdOwnerType'
	FROM PROGRAMS P(nolock)
	INNER JOIN OWNERS O(nolock)
		ON P.IdOwner = O.Id
	INNER JOIN OWNER_TYPES OT(nolock)
		ON O.IdOwnerType = OT.Id
	WHERE P.Id =  @Id 
		AND ISNULL(P.IsActive,0) = CASE @OnlyActive WHEN 0 THEN ISNULL(P.IsActive,0) ELSE 1  END
	ORDER BY P.Rank
END

GO

--Drops the Procedure catSelectProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectProject
GO
CREATE PROCEDURE catSelectProject
	@Id AS INT 	--The Id of the selected Project
AS
	DECLARE @HasActualData INT
	SET @HasActualData = 0
	
	IF @Id <> -1
		BEGIN
			-- Create 1st January of the current year
			declare @FirstJanuary datetime
			set @FirstJanuary = cast('1/1/' + cast(year(getdate()) as varchar(4)) as datetime)
			
			IF EXISTS(SELECT IdProject FROM ACTUAL_DATA WHERE IdProject = @Id and [Date] >= @FirstJanuary)
				SET @HasActualData = 1
		END
		
	--If @Id has the value -1, it will return all Projects
	SELECT 	
		P.Code 			AS 'Code',
		P.[Name]		AS 'Name',
		PR.[Code]		AS 'ProgramCode',
		PT.Type			AS 'ProjectType',
		P.IsActive		AS 'IsActive',
		(SELECT COUNT(IdAssociate) FROM PROJECT_CORE_TEAMS WHERE IsActive = 1 AND IdProject = CASE WHEN @Id=-1 THEN P.Id ELSE @Id END)
					AS 'ActiveMembers',
		dbo.fnGetPercentageWpWithTimingAndInterco(P.Id)	AS 'TimingIntercoPercent',
		ISNULL((SELECT IsValidated FROM BUDGET_INITIAL WHERE IdProject = CASE WHEN @Id=-1 THEN P.Id ELSE @Id END), 0) 
					AS 'IsInitialBudgetValidated',
		PR.[Name]		AS 'ProgramName',
		P.[Id]			AS 'Id',
		P.IdProgram		AS 'IdProgram',
		P.IdProjectType 	AS 'IdProjectType',
		@HasActualData	AS 'HasActualData'
	FROM PROJECTS P(nolock)
	INNER JOIN PROGRAMS PR(nolock)
		ON P.IdProgram = PR.[Id]
	INNER JOIN PROJECT_TYPES PT(nolock)
		ON P.IdProjectType = PT.[Id]
	WHERE P.Id = CASE WHEN @Id=-1 THEN P.Id ELSE @Id END
	ORDER BY P.Code
GO

--Drops the Procedure catSelectProjectPhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectProjectPhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectProjectPhase
GO
CREATE PROCEDURE catSelectProjectPhase
	@Id AS INT 	--The Id of the selected ProjectPhase
AS
	--If @Id has the value -1, it will return all PROJECT_PHASES
	IF (@Id = -1)
	BEGIN 
		SELECT 	P.[Id]		AS 'Id',
			P.Code		AS 'Code',
			P.[Name]	AS 'Name'
		FROM PROJECT_PHASES P(nolock)

		RETURN
	END

	SELECT 	P.[Id]		AS 'Id',
		P.Code 		AS 'Code',
		P.[Name]	AS 'Name'
	FROM PROJECT_PHASES P(nolock)
	WHERE P.[Id] = @Id
GO

--Drops the Procedure catSelectProjectType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectProjectType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectProjectType
GO
CREATE PROCEDURE catSelectProjectType
	@Id AS INT 	--The Id of the selected Project Type
AS
	--If @Id has the value -1, it will return all Project Types

IF @Id=-1
BEGIN
	SELECT 	
		PT.Type		AS 'Type',
		PT.Rank		AS 'Rank',
		PT.[Id]		AS 'Id'
	FROM PROJECT_TYPES PT(nolock)	
	ORDER BY PT.Rank

END

IF @Id=-2
BEGIN
	SELECT 	
		CAST(NULL AS VARCHAR(20))		AS 'Type',
		ISNULL(MAX(PT.Rank),0) + 1		AS 'Rank',
		CAST(NULL AS INT)			AS 'Id'
	FROM PROJECT_TYPES PT(nolock)
END

IF @Id>0
BEGIN
	SELECT 	
		PT.Type		AS 'Type',
		PT.Rank		AS 'Rank',
		PT.[Id]		AS 'Id'
	FROM PROJECT_TYPES PT(nolock)
	WHERE PT.[Id] = @Id
END

GO

--Drops the Procedure catSelectRegion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectRegion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectRegion
GO
CREATE PROCEDURE catSelectRegion
	@Id AS INT 	--The Id of the selected Region
AS
	--If @Id has the value -1 it will return all Regions
	--if @id has the value -2 it will return new rank
SET NOCOUNT ON

IF @Id=-1
BEGIN
	SELECT 	
		R.Code		AS 'Code',
		R.Name		AS 'Name',
		R.Rank		AS 'Rank',
		R.Id		AS 'Id'		
		
	FROM REGIONS R(nolock)
	WHERE R.Id =R.Id
	ORDER BY R.Rank
END

IF @Id=-2
BEGIN
	
			
	SELECT
		CAST(NULL AS VARCHAR(8)) 	AS 'Code',
		CAST(NULL AS VARCHAR(30)) 	AS 'Name',
		ISNULL(MAX(R.Rank),0) + 1 	AS 'Rank',
		CAST(NULL AS INT) 		AS 'Id'
	FROM REGIONS R(nolock)
END

IF @Id>0
BEGIN
	SELECT 	
		R.Code		AS 'Code',
		R.Name		AS 'Name',
		R.Rank		AS 'Rank',
		R.Id		AS 'Id'		
		
	FROM REGIONS R(nolock)
	WHERE R.Id =@Id
	ORDER BY R.Rank
END

-- exec catSelectRegion @Id = -1
GO

--Drops the Procedure catSelectWorkPackage if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectWorkPackage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectWorkPackage
GO
CREATE PROCEDURE catSelectWorkPackage
	@IdProject 	AS INT, 	--The IdProject of the selected WorkPackage
	@IdPhase	AS INT,		--The IdPhase of the selected WorkPackage
	@Id		AS INT,	 	--The Id of the WorkPackage
	@IdAssociate	AS INT 		--The Id of the Associate that holds the project in ProjectCoreTeams. If the Associate is -1 then all 
					--work packages will be returned, else, we will check if the associate has any project where he is 
					--Program Manager. If there is one, it will return the Work Package for that Project
AS
	--If @Id has the value -1, it will return all WorkPackages


IF @Id=-1
BEGIN
	IF (@IdAssociate = -1)
		BEGIN
			SELECT 	
				PP.Name			AS 'ProjectPhase',
				WP.Code 		AS 'Code',
				WP.Name			AS 'Name',
				WP.Rank			AS 'Rank',
				WP.IsActive		AS 'IsActive',
				WP.StartYearMonth	AS 'StartYearMonth',
				WP.EndYearMonth		AS 'EndYearMonth',
				WP.LastUpdate		AS 'LastUpdate',
				A.Name			AS 'LastUserUpdate',
				CAST (0 AS BIT) 	AS 'IsProgramManager',
				P.Name			AS 'ProjectName',	
				WP.LastUserUpdate	AS 'IdLastUserUpdate',
				WP.Id			AS 'Id',
				WP.IdPhase		AS 'IdPhase',
				WP.IdProject		AS 'IdProject',
				CAST(-1 AS INT)		AS 'IdProjectFunction'
			FROM WORK_PACKAGES AS WP	
			INNER JOIN PROJECTS AS P
				ON WP.IdProject = P.Id 
			INNER JOIN PROJECT_PHASES AS PP
				ON WP.IdPhase = PP.Id
			INNER JOIN ASSOCIATES AS A
				ON WP.LastUserUpdate = A.Id
			WHERE WP.IdProject = case when @IdProject = -1 then WP.IdProject else @IdProject end
			ORDER BY WP.Rank
		END
		ELSE
		BEGIN
			SELECT 	
				PP.Name			AS 'ProjectPhase',
				WP.Code 		AS 'Code',
				WP.Name			AS 'Name',
				WP.Rank			AS 'Rank',
				WP.IsActive		AS 'IsActive',
				WP.StartYearMonth	AS 'StartYearMonth',
				WP.EndYearMonth		AS 'EndYearMonth',
				WP.LastUpdate		AS 'LastUpdate',
				A.Name			AS 'LastUserUpdate',
				dbo.fnIsAssociatePMOnProject(WP.IdProject, @IdAssociate) AS 'IsProgramManager',
				P.Name			AS 'ProjectName',	
				WP.LastUserUpdate	AS 'IdLastUserUpdate',
				WP.Id			AS 'Id',
				WP.IdPhase		AS 'IdPhase',
				WP.IdProject		AS 'IdProject',
				PCT.IdFunction		AS 'IdProjectFunction'
			FROM WORK_PACKAGES AS WP	
			INNER JOIN PROJECTS AS P
				ON WP.IdProject = P.Id 
			INNER JOIN PROJECT_PHASES AS PP
				ON WP.IdPhase = PP.Id
			INNER JOIN ASSOCIATES AS A
				ON WP.LastUserUpdate = A.Id
			INNER JOIN PROJECT_CORE_TEAMS AS PCT
				ON  PCT.IdProject = P.[Id]
				AND PCT.IdAssociate = @IdAssociate
				AND PCT.IsActive = 1
			WHERE WP.IdProject = case when @IdProject = -1 then WP.IdProject else @IdProject end
			ORDER BY WP.Rank
		END
END

IF @Id=-2
BEGIN
	IF (@IdAssociate = -1)
		BEGIN
			SELECT 	
				CAST(NULL AS VARCHAR(3))	AS 'ProjectPhase',
				CAST(NULL AS VARCHAR(3)) 	AS 'Code',
				CAST(NULL AS VARCHAR(30))	AS 'Name',
				ISNULL(MAX(WP.Rank),0)+1	AS 'Rank',
				CAST(NULL AS BIT)		AS 'IsActive',
				CAST(NULL AS INT)		AS 'StartYearMonth',
				CAST(NULL AS INT)		AS 'EndYearMonth',
				CAST(NULL AS datetime)		AS 'LastUpdate',
				CAST(NULL AS INT)		AS 'LastUserUpdate',
				CAST (0 AS BIT) 		AS 'IsProgramManager',
				CAST(NULL AS VARCHAR(50))	AS 'ProjectName',	
				CAST(NULL AS INT)		AS 'IdLastUserUpdate',
				CAST(NULL AS INT)		AS 'Id',
				CAST(NULL AS INT)		AS 'IdPhase',
				CAST(NULL AS INT)		AS 'IdProject',
				CAST(-1	  AS INT)		AS 'IdProjectFunction'
			FROM WORK_PACKAGES AS WP	
			INNER JOIN PROJECTS AS P
				ON WP.IdProject = P.Id 
			INNER JOIN PROJECT_PHASES AS PP
				ON WP.IdPhase = PP.Id
			INNER JOIN ASSOCIATES AS A
				ON WP.LastUserUpdate = A.Id
			WHERE WP.IdProject = case when @IdProject = -1 then WP.IdProject else @IdProject end
		END
		ELSE
		BEGIN
			SELECT 	
				CAST(NULL AS VARCHAR(3))	AS 'ProjectPhase',
				CAST(NULL AS VARCHAR(3)) 	AS 'Code',
				CAST(NULL AS VARCHAR(30))	AS 'Name',
				ISNULL(MAX(WP.Rank),0)+1	AS 'Rank',
				CAST(NULL AS BIT)		AS 'IsActive',
				CAST(NULL AS INT)		AS 'StartYearMonth',
				CAST(NULL AS INT)		AS 'EndYearMonth',
				CAST(NULL AS datetime)		AS 'LastUpdate',
				CAST(NULL AS INT)		AS 'LastUserUpdate',
				CAST (0 AS BIT)			AS 'IsProgramManager',
				CAST(NULL AS VARCHAR(50))	AS 'ProjectName',	
				CAST(NULL AS INT)		AS 'IdLastUserUpdate',
				CAST(NULL AS INT)		AS 'Id',
				CAST(NULL AS INT)		AS 'IdPhase',
				CAST(NULL AS INT)		AS 'IdProject',
				CAST(-1	  AS INT)		AS 'IdProjectFunction'
			FROM WORK_PACKAGES AS WP	
			INNER JOIN PROJECTS AS P
				ON WP.IdProject = P.Id 
			INNER JOIN PROJECT_PHASES AS PP
				ON WP.IdPhase = PP.Id
			INNER JOIN ASSOCIATES AS A
				ON WP.LastUserUpdate = A.Id
			INNER JOIN PROJECT_CORE_TEAMS AS PCT
				ON  PCT.IdProject = P.[Id]
				AND PCT.IdAssociate = @IdAssociate
				AND PCT.IsActive = 1
			WHERE WP.IdProject = case when @IdProject = -1 then WP.IdProject else @IdProject end
		END
END

IF @Id>0
BEGIN
	SELECT 	
		PP.Name			AS 'ProjectPhase',
		WP.Code 		AS 'Code',
		WP.Name			AS 'Name',
		WP.Rank			AS 'Rank',
		WP.IsActive		AS 'IsActive',
		WP.StartYearMonth	AS 'StartYearMonth',
		WP.EndYearMonth		AS 'EndYearMonth',
		WP.LastUpdate		AS 'LastUpdate',
		A.Name			AS 'LastUserUpdate',
		dbo.fnIsAssociatePMOnProject(WP.IdProject, @IdAssociate) AS 'IsProgramManager',
		P.Name			AS 'ProjectName',
		WP.LastUserUpdate	AS 'IdLastUserUpdate',
		WP.Id			AS 'Id',
		WP.IdPhase		AS 'IdPhase',
		WP.IdProject		AS 'IdProject',
		ISNULL(PCT.IdFunction, -1) AS 'IdProjectFunction'
	FROM WORK_PACKAGES AS WP	
	INNER JOIN PROJECTS AS P
		ON WP.IdProject = P.Id
	INNER JOIN PROJECT_PHASES AS PP
		ON WP.IdPhase = PP.Id
	INNER JOIN ASSOCIATES AS A
		ON WP.LastUserUpdate = A.Id
	LEFT JOIN PROJECT_CORE_TEAMS AS PCT
		ON  PCT.IdProject = P.Id AND
		    PCT.IdAssociate = @IdAssociate AND
		    PCT.IsActive = 1
	WHERE 	WP.IdProject = @IdProject AND
			WP.IdPhase = @IdPhase AND
			WP.Id = @Id
	ORDER BY WP.Rank
END

GO

--Drops the Procedure catSelecWorkPackageNewKeys if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectWorkPackageNewKeys]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectWorkPackageNewKeys
GO
CREATE PROCEDURE catSelectWorkPackageNewKeys
	@IdProject	AS INT, --The Id representing the Project connected to the selected Work Package
	@CODE 		AS VARCHAR(3)
AS

--SELECT NEW KEYS AFTER UPDATE PROCEDURE BASED ON UNIQUE CONSTRAINT IdProject, Code
	SELECT 	IdProject,
		IdPhase,
		[Id] as 'Id'
	FROM WORK_PACKAGES
	WHERE IdProject = @IdProject AND
	      Code	= @Code

GO


--Drops the Procedure catSelectWorkPackageTemplate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catSelectWorkPackageTemplate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catSelectWorkPackageTemplate
GO
CREATE PROCEDURE catSelectWorkPackageTemplate
	@IdPhase	AS INT,		--The IdPhase of the selected WorkPackage
	@Id		AS INT	 	--The Id of the WorkPackage
	
AS
	--If @Id has the value -1, it will return all WorkPackagesTemplate


IF @Id=-1
BEGIN
	
	SELECT 	
		PP.Name			AS 'ProjectPhase',
		WP.Code 		AS 'Code',
		WP.Name			AS 'Name',
		WP.Rank			AS 'Rank',
		WP.IsActive		AS 'IsActive',
		WP.LastUpdate		AS 'LastUpdate',
		A.Name			AS 'LastUserUpdate',
		CAST (0 AS BIT) 	AS 'IsProgramManager',
		WP.LastUserUpdate	AS 'IdLastUserUpdate',
		WP.Id			AS 'Id',
		WP.IdPhase		AS 'IdPhase'
	FROM WORK_PACKAGES_TEMPLATE AS WP	
	INNER JOIN PROJECT_PHASES AS PP
		ON WP.IdPhase = PP.Id
	INNER JOIN ASSOCIATES AS A
		ON WP.LastUserUpdate = A.Id
	ORDER BY WP.Rank
	
END

IF @Id=-2
BEGIN
	
	SELECT 	
		CAST(NULL AS VARCHAR(3))	AS 'ProjectPhase',
		CAST(NULL AS VARCHAR(3)) 	AS 'Code',
		CAST(NULL AS VARCHAR(30))	AS 'Name',
		ISNULL(MAX(WP.Rank),0)+1	AS 'Rank',
		CAST(NULL AS BIT)		AS 'IsActive',
		CAST(NULL AS datetime)		AS 'LastUpdate',
		CAST(NULL AS INT)		AS 'LastUserUpdate',
		CAST (0 AS BIT) 		AS 'IsProgramManager',
		CAST(NULL AS INT)		AS 'IdLastUserUpdate',
		CAST(NULL AS INT)		AS 'Id',
		CAST(NULL AS INT)		AS 'IdPhase'
	FROM WORK_PACKAGES_TEMPLATE AS WP	
	INNER JOIN PROJECT_PHASES AS PP
		ON WP.IdPhase = PP.Id
	INNER JOIN ASSOCIATES AS A
		ON WP.LastUserUpdate = A.Id
	
END

IF @Id>0
BEGIN
	SELECT 	
		PP.Name			AS 'ProjectPhase',
		WP.Code 		AS 'Code',
		WP.Name			AS 'Name',
		WP.Rank			AS 'Rank',
		WP.IsActive		AS 'IsActive',
		WP.LastUpdate		AS 'LastUpdate',
		A.Name			AS 'LastUserUpdate',
		CAST (0 AS BIT) 	AS 'IsProgramManager',
		WP.LastUserUpdate	AS 'IdLastUserUpdate',
		WP.Id			AS 'Id',
		WP.IdPhase		AS 'IdPhase'
	FROM WORK_PACKAGES_TEMPLATE AS WP	
	INNER JOIN PROJECT_PHASES AS PP
		ON WP.IdPhase = PP.Id
	INNER JOIN ASSOCIATES AS A
		ON WP.LastUserUpdate = A.Id
	WHERE 	WP.IdPhase = @IdPhase AND
			WP.Id = @Id
	ORDER BY WP.Rank
END

GO

--Drops the Procedure catUpdateAssociate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateAssociate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateAssociate
GO
CREATE PROCEDURE catUpdateAssociate
	@Id			INT,		--The Id of the selected Associate
	@IdCountry		INT,		--The Id of the Country that is connected to the Associate you want to insert
 	@EmployeeNumber		VARCHAR(15),	--The Employee Number of the Associate you want to Insert
	@Name			VARCHAR(50),	--The Name of the Associate you want to Insert
	@InergyLogin		VARCHAR(50),	--The Inergy Login of the Associate you want to Insert
	@PercentageFullTime 	INT,		--The AvailabilityPercent of the Associate you want to Insert
	@IsActive		BIT,		--The IsActive of the Associate you want to Insert
	@IsSubContractor	BIT		--The IsSubContractor of the Associate you want to Insert
	
AS
DECLARE	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(50),
	@Rowcount		INT,
	@RetVal			INT
	
	SET @LogicalKey = 'Country, Employee Number'

	IF EXISTS( SELECT *
	FROM ASSOCIATES AS A
	WHERE 	A.EmployeeNumber = @EmployeeNumber AND
		A.IdCountry = @IdCountry AND 
		A.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END
	
	SET @LogicalKey = 'Inergy Login, Country'

	IF EXISTS( SELECT *
	FROM ASSOCIATES AS A (TABLOCKX)
	WHERE 	A.InergyLogin = @InergyLogin AND
		A.IdCountry = @IdCountry AND 
		A.[Id] <> @Id
	)
	SET @ValidateLogicKey = 1

	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @EmployeeNumber IS NULL OR 
	   @Name IS NULL OR 
	   @InergyLogin IS NULL OR 
	   @PercentageFullTime IS NULL OR 
	   @IsActive IS NULL OR 
	   @IsSubContractor IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	--If the current associate is made from active to inactive, check whether he is active as a core team member on at least 1 project.
	--If this is true, an error will be raised
	DECLARE @OldIsActive BIT
	SELECT 	@OldIsActive = IsActive
	FROM 	ASSOCIATES
	WHERE 	[Id] = @Id

	IF (@OldIsActive = 1 AND @IsActive = 0)
	BEGIN
		IF EXISTS
		(
			SELECT 	IdAssociate
			FROM	PROJECT_CORE_TEAMS
			WHERE 	IdAssociate = @Id AND
				IsActive = 1
		)
		BEGIN
			RAISERROR('Cannot make this associate inactive because he/she is an active core team member on at least one project.', 16, 1)
			RETURN -3
		END
	END

	--If the current associate has data in any budget and the country is changed, raise an error
	DECLARE @OldIdCountry INT
	SELECT  @OldIdCountry = IdCountry
	FROM 	ASSOCIATES
	WHERE 	[Id] = @Id

	IF (@OldIdCountry <> @IdCountry)
	BEGIN
		EXEC @RetVal = catIsUserCountryChangeAllowed @IdAssociate = @Id
		IF (@@ERROR <> 0 OR @RetVal < 0)
			RETURN -4
	END

	
	UPDATE ASSOCIATES 	
	SET EmployeeNumber = @EmployeeNumber,
	    [Name] = @Name,
	    InergyLogin = @InergyLogin,
	    PercentageFullTime = @PercentageFullTime,
	    IsActive = @IsActive,
	    IsSubContractor = @IsSubContractor,
	    IdCountry = @IdCountry
	WHERE 	[Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

/****** Object:  StoredProcedure [dbo].[catUpdateBudgetExchangeRate]    Script Date: 03/18/2015 11:31:54 ******/
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = OBJECT_ID(N'[dbo].[catUpdateBudgetExchangeRate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[catUpdateBudgetExchangeRate]
GO

/****** Object:  StoredProcedure [dbo].[catUpdateBudgetExchangeRate]    Script Date: 03/18/2015 11:31:54 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

create procedure [dbo].[catUpdateBudgetExchangeRate]

@IdCategory int,
@Year int,
@IdCurrency int,
@Rate numeric(10,4)

as
-- Rate for Budget is same in all months of the year
-- Insert records if they don't exist. One can insert for all currencies
insert into EXCHANGE_RATES
(IdCurrencyTo, YearMonth, IdCategory, ConversionRate)
select a.IdCurrencyTo,b.YearMonth, 2 as IdCategory, 0 as ConversionRate 
from
(
	select distinct IdCurrencyTo 
	from EXCHANGE_RATES 
	where floor(YearMonth/100) = @Year-1
	and IdCategory=1
) a
cross join
(
	select @Year*100+1 as YearMonth
	union
	select @Year*100+2
	union
	select @Year*100+3
	union
	select @Year*100+4
	union
	select @Year*100+5
	union
	select @Year*100+6
	union
	select @Year*100+7
	union
	select @Year*100+8
	union
	select @Year*100+9
	union
	select @Year*100+10
	union
	select @Year*100+11
	union
	select @Year*100+12
) b
left join EXCHANGE_RATES c on c.IdCurrencyTo = a.IdCurrencyTo and c.YearMonth = b.YearMonth and c.IdCategory=2
where c.IdCurrencyTo is null

update dbo.EXCHANGE_RATES
set ConversionRate = @Rate
where IdCurrencyTo = @IdCurrency and floor(YearMonth/100) = @Year
and IdCategory=2


GO

--Drops the Procedure catUpdateBudgetPeriod if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateBudgetPeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateBudgetPeriod
GO
CREATE PROCEDURE catUpdateBudgetPeriod
	@Id		INT,		--The Id of the selected Budget Period
 	@Code		VARCHAR(3),	--The Code of the Budget Period you want to Update
	@Name		VARCHAR(50)	--The Name of the Budget Period you want to Update
	
AS
DECLARE @IdUpdate		INT,
	@Rowcount 	INT

	SELECT @IdUpdate = BP.[Id]
	FROM BUDGET_PERIODS AS BP(HOLDLOCK)
	WHERE BP.[Id] = @Id

	IF(@IdUpdate = NULL)
	BEGIN
		RAISERROR('The selected Id of the Budget Period does not exists in the BUDGET_PERIODS table',16,1)
	END

	UPDATE BUDGET_PERIODS 	
	SET Code = @Code,
	    [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateCatalogRank if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateCatalogRank]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateCatalogRank
GO
CREATE PROCEDURE catUpdateCatalogRank
	@TableName	NVARCHAR(200),	--The Name of the table you want to Update
	@Rank 		INT,
	@Direction	INT,		-- UP (Rank+1), DOWN (Rank-1)
	@Id		INT		-- id of the row that change rank
AS

DECLARE @SQL  NVARCHAR(500)

IF (@Rank<1)
BEGIN 
	RAISERROR('Rank field must be bigger than 0',16,1)		
	RETURN -1
END

--DELETE OPERATION
IF(@Direction=0)
BEGIN
-- 	PRINT 'HERE 0 '
	SET @SQL = 'UPDATE '+ @TableName + ' SET Rank = Rank - 1 WHERE Rank> '+ CAST(@Rank AS NVARCHAR(9))
	EXEC(@SQL)
	RETURN
END

--INSERT OPERATION
IF(@Direction=1)
BEGIN
-- 	PRINT 'HERE 1'
	SET @SQL = 'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL = @SQL + 'UPDATE '+ @TableName + ' SET Rank = Rank +1 WHERE Rank>= '+ CAST(@Rank AS NVARCHAR(9))		
-- 	PRINT @SQL
	EXEC(@SQL)
	RETURN
END
--UPDATE OPERATION
IF(@Direction=2)
BEGIN
-- PRINT 'HERE 2'
	SET @SQL=N'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL=@SQL + ' BEGIN ' + CHAR(13)
	SET @SQL=@SQL + ' DECLARE @OLDRANK INT;' + CHAR(13)
	SET @SQL=@SQL + ' SELECT @OLDRANK=RANK FROM ' + @TableName + ' WHERE ID='+CAST(@ID AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank = -1 WHERE Id ='+ CAST(@Id AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' IF @OLDRANK<'+CAST(@RANK AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank-1 WHERE Rank>@OLDRANK AND Rank <=' + CAST(@Rank AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' IF @OLDRANK>'+CAST(@RANK AS NVARCHAR(9))+ CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank+1 WHERE Rank>=' + CAST(@Rank AS NVARCHAR(9))+' AND Rank<@OLDRANK;' + CHAR(13)
	SET @SQL=@SQL + ' END '
	
--  	PRINT @SQL
	EXEC sp_executesql @SQL
--BEGIN TRAN;exec catUpdateOwner @Id = 6, @Code = N'43t', @Name = N'435432', @IdOwnerType = 3, @Rank = 3;SELECT * FROM OWNERS;ROLLBACK TRAN	

END




GO



--Drops the Procedure catUpdateCostCenter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateCostCenter]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateCostCenter
GO
CREATE PROCEDURE catUpdateCostCenter
	@Id			INT,		--The Id of the cost center
	@IdInergyLocation	INT,		--The Id of the Inergy Location related to the Cost Center
	@IdDepartment		INT,		--The Id of the Department related to the Cost Center
	@IsActive		BIT,		--Specifies if the Cost Center is active or not
 	@Code			VARCHAR(15),	--The Code of the Cost Center you want to Insert
	@Name			VARCHAR(30)	--The Name of the Cost Center you want to Insert
AS
DECLARE	@RowCount		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)


	
	SET @LogicalKey = 'Country, Code'

	--first we get the country of the newly inserted code 
	Declare @IdCountry int
	SELECT @IdCountry = IdCountry
	from INERGY_LOCATIONS
	WHERE Id = @IdInergyLocation

	IF EXISTS(SELECT *
		  FROM COST_CENTERS CC (TABLOCKX)
	          INNER JOIN INERGY_LOCATIONS IL
	  		ON CC.IdInergyLocation = IL.Id
		  WHERE CC.Code = @Code AND
			IL.IdCountry = @IdCountry AND
			CC.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END





	IF(@IdInergyLocation IS NULL OR 
	   @IdDepartment IS NULL OR 
	   @IsActive IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	DECLARE @Old_IdCountry INT
	DECLARE @New_IdCountry INT
	DECLARE @Old_InergyLocation INT
	DECLARE @Old_CountryName varchar(30)

	SELECT  @Old_IdCountry = IL.IdCountry, 
		@Old_CountryName = C.Name,
	 	@Old_InergyLocation = CC.IdInergyLocation
	FROM COST_CENTERS CC
	INNER JOIN INERGY_LOCATIONS IL
		ON CC.IdInergyLocation = IL.Id
	INNER JOIN COUNTRIES C
		ON IL.IdCountry = C.Id
	WHERE CC.Id = @Id

	SELECT @New_IdCountry =IdCountry
	FROM INERGY_LOCATIONS
	WHERE Id = @IdInergyLocation

	IF ISNULL(@Old_IdCountry,0)<> ISNULL(@New_IdCountry,0)
	BEGIN
		SET @ValidateLogicKey = dbo.fnCheckCostCenterExistenceInAllCategories(@Id)
		if @ValidateLogicKey=1
		BEGIN
			RAISERROR('Inergy Location cannot be changed for this Cost Center. Only Inergy Locations from the same country (%s) are allowed when the cost center has budget or actual data.',16,1,@Old_CountryName)
			RETURN -3		
		END
	END

	
	UPDATE COST_CENTERS 	
	SET IdInergyLocation = @IdInergyLocation,
	    IdDepartment = @IdDepartment,
	    IsActive = @IsActive, 
	    Code = @Code,
	    [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateCountry if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateCountry]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateCountry
GO
CREATE PROCEDURE catUpdateCountry
	@Id		INT,			--The Id of the Country you want to update
 	@Code		VARCHAR(3),	--The Code of the Country you want to Insert
	@Name		VARCHAR(30),	--The Name of the Country you want to Insert
	@IdRegion	INT = NULL,		--The Region from REGIONS table
	@IdCurrency	INT,		--The Currency from Currencies table
	@Email 		VARCHAR(50),
	@Rank INT
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Country Name'

	IF EXISTS( SELECT *
	FROM COUNTRIES AS C
	WHERE 	C.[Name] = @Name AND
		C.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF EXISTS( SELECT *
	FROM COUNTRIES AS C
	WHERE 	C.Code = @Code AND
		C.[Id] <> @Id)  
	BEGIN
		SET @ValidateLogicKey = 1
		SET @LogicalKey= 'Name'
	END

	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL OR 
	   @Name IS NULL OR 
	   @IdCurrency IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	--Check that the selected region still exists
	IF (@IdRegion IS NOT NULL)
	BEGIN
		IF NOT EXISTS
		(
			SELECT 	[Id]
			FROM 	Regions
			WHERE 	[Id] = @IdRegion
		)
		BEGIN
			RAISERROR('The selected region does not exist anymore',16,1)
			RETURN -3
		END
	END

	DECLARE @OldIdRegion INT
	SELECT 	@OldIdRegion = IdRegion
	FROM 	COUNTRIES
	WHERE	[Id] = @Id

	exec @RetVal = catUpdateCatalogRank 'COUNTRIES', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -4

	UPDATE COUNTRIES 	
	SET Code = @Code,
	    [Name] = @Name,
	    IdRegion = @IdRegion,
	    IdCurrency = @IdCurrency,
	    Email = @Email,
	    [Rank] = @Rank
	WHERE [Id] = @Id
	SET @Rowcount = @@ROWCOUNT

	DECLARE CostIncomeCursor CURSOR FAST_FORWARD FOR
	SELECT 	[Id],
		[Name],
		DefaultAccount
	FROM	COST_INCOME_TYPES

	OPEN CostIncomeCursor
	DECLARE @IdCostIncome INT
	DECLARE @NameCostIncome VARCHAR(50)
	DECLARE @DefaultAccountCostIncome VARCHAR(20)
	

	FETCH NEXT FROM CostIncomeCursor INTO @IdCostIncome, @NameCostIncome, @DefaultAccountCostIncome		
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF (@IdRegion IS NOT NULL)
		BEGIN
			IF (@OldIdRegion IS NULL)
			BEGIN
				IF NOT EXISTS
				(
					SELECT * FROM GL_ACCOUNTS
					WHERE 	IdCountry = @Id AND
						Account = @NameCostIncome
				)
				BEGIN
					EXEC @RETVAL = catInsertGlAccount @Id, @DefaultAccountCostIncome, @NameCostIncome, @IdCostIncome
					IF @RETVAL<0 OR @@ERROR<>0
					BEGIN
						CLOSE CostIncomeCursor
						DEALLOCATE CostIncomeCursor
						RETURN -5
					END
				END
			END
		END
		ELSE
		BEGIN
			IF (@OldIdRegion IS NOT NULL)
			BEGIN
				DECLARE @IdGlAccount INT
				
				SELECT 	@IdGlAccount = [Id]
				FROM	GL_ACCOUNTS
				WHERE	IdCountry = @Id AND
					Account = @DefaultAccountCostIncome
				
				EXEC @RETVAL =   catDeleteGlAccount @Id, @IdGlAccount
				IF @RETVAL<0 OR @@ERROR<>0
				BEGIN
					CLOSE CostIncomeCursor
					DEALLOCATE CostIncomeCursor
					RETURN -6
				END
			END
		END
		FETCH NEXT FROM CostIncomeCursor INTO @IdCostIncome, @NameCostIncome, @DefaultAccountCostIncome
	END
	
	CLOSE CostIncomeCursor
	DEALLOCATE CostIncomeCursor

	RETURN @Rowcount
GO

--Drops the Procedure catUpdateCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateCurrency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateCurrency
GO
CREATE PROCEDURE catUpdateCurrency
	@Id		INT,		--The Id of the selected Currency
 	@Code		VARCHAR(3),	--The Code of the Currency you want to Update
	@Name		VARCHAR(50)	--The Name of the Currency you want to Update
	
AS
DECLARE @IdUpdate	INT,
	@Rowcount 	INT

	SELECT @IdUpdate = C.[Id]
	FROM CURRENCIES AS C(HOLDLOCK)
	WHERE C.[Id] = @Id

	IF(@IdUpdate = NULL)
	BEGIN
		RAISERROR('The selected Id of the Currency does not exists in the CURRENCIES table',16,1)
	END

	UPDATE CURRENCIES 	
	SET Code = @Code,
	    [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateDepartment if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateDepartment]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateDepartment
GO
CREATE PROCEDURE catUpdateDepartment
	@Id		INT,			--The Id of the selected Department
	@IdFunction	INT,		--The Id of the function that coresponds to this Department
	@Name		VARCHAR(50),	--The Name of the Department you want to Insert
	@Rank		INT
	
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Name'

	IF EXISTS( SELECT *
	FROM DEPARTMENTS AS D
	WHERE 	D.[Name] = @Name AND 
		D.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdFunction IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	exec @RetVal = catUpdateCatalogRank 'DEPARTMENTS', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE DEPARTMENTS 	
	SET IdFunction = @IdFunction,
	    [Name] = @Name,
            [Rank] = @Rank
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateFunction if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateFunction]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateFunction
GO
CREATE PROCEDURE catUpdateFunction
	@Id		INT,		--The Id of the selected Function
	@Name		VARCHAR(50)	--The Name of the Function you want to Update
	
AS
DECLARE @IdUpdate	INT,
	@Rowcount 	INT

	SELECT @IdUpdate = F.[Id]
	FROM [FUNCTION] AS F(HOLDLOCK)
	WHERE F.[Id] = @Id

	IF(@IdUpdate = NULL)
	BEGIN
		RAISERROR('The selected Id of the Function does not exists in the FUNCTION table',16,1)
	END

	UPDATE [FUNCTION] 	
	SET   [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateGlAccount if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateGlAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateGlAccount
GO
CREATE PROCEDURE catUpdateGlAccount
	@Id		INT,		--The Id of the selected GlAccount
	@IdCountry	INT,		--The Id of the country
 	@Account	VARCHAR(20),	--The Code of the Inergy Location you want to Insert
	@Name		VARCHAR(30),	--The Name of the Inergy Location you want to Insert
	@IdCostType	INT		--The Id of the updated cost type related to the GL_ACCOUNT 
	
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	SET @LogicalKey = 'Country, Account'

	IF EXISTS( SELECT *
	FROM GL_ACCOUNTS AS GA
	WHERE 	GA.Account = @Account AND 
		GA.IdCountry = @IdCountry AND
		GA.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @Account IS NULL OR 
	   @Name IS NULL OR 
	   @IdCostType IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END


	 -- A. check cost type change in the actual data
	IF (@IdCostType <> 6 AND
		EXISTS
		(
			SELECT 	IdAccount
			FROM 	ACTUAL_DATA_DETAILS_HOURS
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		)
	   )
	BEGIN
		RAISERROR('Cost type cannot be changed because account is used in Actual Data.', 16, 1)
		RETURN -3
	END

	IF (@IdCostType <> 7 AND
		EXISTS
		(
			SELECT 	IdAccount
			FROM 	ACTUAL_DATA_DETAILS_SALES
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		)
	   )
	BEGIN
		RAISERROR('Cost type cannot be changed because account is used in Actual Data.', 16, 1)
		RETURN -4
	END

	IF EXISTS
		(
			SELECT 	IdAccount
			FROM 	ACTUAL_DATA_DETAILS_COSTS
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry AND
				IdCostType <> @IdCostType
		)
	BEGIN

		IF @IdCostType NOT IN (6, 7) -- if the new cost type is still of type cost, change is allowed and update is made
		BEGIN
			UPDATE 	ACTUAL_DATA_DETAILS_COSTS
			SET IdCostType  = @IdCostType
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		END

		IF @IdCostType IN (6, 7)
		BEGIN
			RAISERROR('Cost type cannot be changed because account is used in Actual Data.', 16, 1)
			RETURN -5
		END
	END






	 -- B. check cost type change in the annual budget
	IF (@IdCostType <> 6 AND
		EXISTS
		(
			SELECT 	IdAccount
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_HOURS
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		)
	   )
	BEGIN
		RAISERROR('Cannot change the cost type because account is used in Annual Budget.', 16, 1)
		RETURN -6
	END

	IF (@IdCostType <> 7 AND
		EXISTS
		(
			SELECT 	IdAccount
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_SALES
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		)
	   )
	BEGIN
		RAISERROR('Cannot change the cost type because account is used in Annual Budget.', 16, 1)
		RETURN -7
	END

	IF (EXISTS
		(
			SELECT 	IdAccount
			FROM 	ANNUAL_BUDGET_DATA_DETAILS_COSTS
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry AND
				IdCostType <> @IdCostType
		)
	   )
	BEGIN
		IF @IdCostType NOT IN (6, 7) -- if the new cost type is still of type cost, change is allowed and update is made
		BEGIN
			UPDATE 	ANNUAL_BUDGET_DATA_DETAILS_COSTS
			SET IdCostType  = @IdCostType
			WHERE 	IdAccount = @Id AND
				IdCountry = @IdCountry
		END

		IF @IdCostType IN (6, 7)
		BEGIN
			RAISERROR('Cannot change the cost type because account is used in Annual Budget.', 16, 1)
			RETURN -8
		END
	END

		

	UPDATE GL_ACCOUNTS 	
	SET Account = @Account,
	    [Name] = @Name,
	    IdCostType = @IdCostType
	WHERE 	[Id] = @Id AND 
		IdCountry = @IdCountry

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateHourlyRate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateHourlyRate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateHourlyRate
GO
CREATE PROCEDURE catUpdateHourlyRate
 	@IdCostCenter	INT,		--The Id of the Cost Center that is connected to the Hourly Rate you want to insert 	
	@YearMonth	INT,		--The Year and Month of the Hourly Rate you want to Insert
	@Value		DECIMAL(12,2)	--The Value of the Hourly Rate you want to Insert	
AS

--validation yearmonth section
Declare	@ErrorMessage		VARCHAR(255),
	@YMValidationResult	INT

	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@YearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -1
	end
--end validation section

DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(40)
	
	SET @LogicalKey = 'Year, Month, Cost Center'

	IF EXISTS( SELECT *
	FROM HOURLY_RATES AS HR
	WHERE 	HR.YearMonth = @YearMonth AND
		HR.IdCostCenter = @IdCostCenter ) 
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2
	END

	IF(@IdCostCenter IS NULL OR 
	   @YearMonth IS NULL OR 
	   @Value IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3	
	END

	UPDATE HOURLY_RATES 	
	SET  HourlyRate = @Value
	WHERE 	YearMonth = @YearMonth AND
		IdCostCenter = @IdCostCenter

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateInergyLocation if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateInergyLocation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateInergyLocation
GO
CREATE PROCEDURE catUpdateInergyLocation
	@Id		INT,			--The Id of the selected Inergy Location
	@IdCountry	INT,
 	@Code		VARCHAR(3),	--The Code of the Inergy Location you want to Insert
	@Name		VARCHAR(50),	--The Name of the Inergy Location you want to Insert
	@Rank INT
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS IL
	WHERE 	IL.[Code] = @Code AND
		IL.[Id] <> @Id) 
	SET @ValidateLogicKey = 1

	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	SET @ValidateLogicKey = 0
	SET @LogicalKey= 'Name'

	IF EXISTS( SELECT *
	FROM INERGY_LOCATIONS AS IL
	WHERE 	IL.[Name] = @Name AND
		IL.[Id] <> @Id) 
	SET @ValidateLogicKey = 1

	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@IdCountry IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	IF NOT EXISTS( SELECT Id
		   FROM INERGY_LOCATIONS
		   WHERE Id = @Id AND
		   IdCountry = @IdCountry)
	BEGIN
		SELECT @ValidateLogicKey = dbo.fnCheckInergyLocationExistenceInAllCategories(@Id)
		DECLARE @Old_CountryName varchar(30),
			@Old_InergyLocation varchar(30)

		SELECT @Old_CountryName  = C.Name,
		       @Old_InergyLocation = IL.Name
		FROM INERGY_LOCATIONS IL
		INNER JOIN COUNTRIES C
			ON IL.IdCountry = C.Id
		WHERE IL.Id = @Id

		IF @ValidateLogicKey = 1
		BEGIN		
			RAISERROR('Country  %s cannot be changed. %s has at least one cost center with budget data.',16,1,@Old_CountryName, @Old_InergyLocation)
		RETURN -1
		END
	END
	
	exec @RetVal = catUpdateCatalogRank 'INERGY_LOCATIONS', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE INERGY_LOCATIONS 	
	SET IdCountry = @IdCountry,
	    Code = @Code,
	    [Name] = @Name,
	    [Rank] = @Rank
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateOwner if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateOwner]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateOwner
GO
CREATE PROCEDURE catUpdateOwner
	@Id		INT,		--The Id of the selected Owner
	@Code		VARCHAR(10),	--The Code of the Owner you want to Insert
	@Name		VARCHAR(30),	--The Name of the Owner you want to Insert
	@IdOwnerType	INT,		--The Type of the Owner
	@Rank		INT
	
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM OWNERS AS O
	WHERE 	O.Code = @Code AND
		O.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	

	IF EXISTS( SELECT *
	FROM OWNERS AS O
	WHERE 	O.[Name] = @Name AND
		O.[Id] <> @Id)  
	BEGIN
		SET @ValidateLogicKey = 1
		SET @LogicalKey= 'Name'
	END
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL OR 
	   @IdOwnerType IS NULL OR 
	   @Name IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	exec  @RetVal = catUpdateCatalogRank 'OWNERS', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE OWNERS 	
	SET Code = @Code,
	    [Name] = @Name,
	    IdOwnerType = @IdOwnerType,
	    [Rank] = @Rank
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdatePhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdatePhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdatePhase
GO
CREATE PROCEDURE catUpdatePhase
	@Id		INT,		--The Id of the selected Phase
 	@Code		VARCHAR(3),	--The Code of the Phase you want to Update
	@Name		VARCHAR(50)	--The Name of the Phase you want to Update
	
AS
DECLARE @IdUpdate	INT,
	@Rowcount 	INT

	SELECT @IdUpdate = P.[Id]
	FROM PHASES AS P(HOLDLOCK)
	WHERE P.[Id] = @Id

	IF(@IdUpdate = NULL)
	BEGIN
		RAISERROR('The selected Id of the Phase does not exists in the PHASES table',16,1)
	END

	UPDATE PHASES 	
	SET Code = @Code,
	    [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateProgram]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateProgram
GO
CREATE PROCEDURE catUpdateProgram
	@Id		INT,		--The Id of the selected Program
	@IdOwner	INT,		--The Id of the Owner that is connected to the Program you want to insert
	@Code		VARCHAR(10),	--The Code of the Program you want to Insert
 	@Name		VARCHAR(50),	--The Name of the Program you want to Insert
	@IsActive	BIT,		--Shows if the Program is Active or not
	@Rank		INT
	
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT

	--If the active flag is set to false, check if there are any active projects for this program. In this case
	--throw error
	IF (@IsActive = 0)
	BEGIN
		DECLARE @NoProjects INT
		SELECT 
			@NoProjects = COUNT([Id]) 
		FROM PROJECTS 
		WHERE IsActive = 1 AND IdProgram = @Id
		IF (@NoProjects > 0)
		BEGIN
			RAISERROR('Could not set program to inactive because it has %d active projects dependencies',16,1,@NoProjects)
			RETURN -1
		END
	END
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
		FROM PROGRAMS AS P(nolock)
		WHERE 	P.Code = @Code AND
			P.Id <> @Id) 
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END


	IF(@IdOwner IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -3	
	END

	exec @RetVal = catUpdateCatalogRank 'PROGRAMS', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE PROGRAMS 	
	SET Code = @Code,
	    [Name] = @Name,
	    IdOwner = @IdOwner,
	    IsActive = @IsActive,
	    [Rank] = @Rank
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateProject
GO
CREATE PROCEDURE catUpdateProject
	@Id		INT,		--The Id of the selected Project
	@Code		VARCHAR(10) = NULL,	--The Code of the Project you want to Insert
	@Name		VARCHAR(50) = NULL,	--The Name of the Project you want to Insert
	@IdProgram	INT = NULL,		--The Program related to this project
	@IdProjectType	INT = NULL,		--The type of the project 
	@IsActive	BIT = NULL		--This option shos if the project is active or not	
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM PROJECTS AS P
	WHERE 	P.Code = @Code AND
		P.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL OR 
	   @IdProgram IS NULL OR 
	   @Name IS NULL OR 
	   @IdProjectType IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	UPDATE PROJECTS 	
	SET Code = @Code,
	    [Name] = @Name,
	    IdProgram = @IdProgram,
	    IdProjectType = @IdProjectType,
	    IsActive = @IsActive
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateProjectPhase if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateProjectPhase]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateProjectPhase
GO
CREATE PROCEDURE catUpdateProjectPhase
	@Id		INT,		--The Id of the selected ProjectPhase
 	@Code		VARCHAR(3),	--The Code of the ProjectPhase you want to Update
	@Name		VARCHAR(50)	--The Name of the ProjectPhase you want to Update
	
AS
DECLARE @IdUpdate	INT,
	@Rowcount 	INT

	SELECT @IdUpdate = PP.[Id]
	FROM PROJECT_PHASES AS PP(HOLDLOCK)
	WHERE PP.[Id] = @Id

	IF(@IdUpdate = NULL)
	BEGIN
		RAISERROR('The selected Id of the ProjectPhase does not exists in the PROJECT_PHASES table',16,1)
	END

	UPDATE PROJECT_PHASES 	
	SET Code = @Code,
	    [Name] = @Name
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateProjectType if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateProjectType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateProjectType
GO
CREATE PROCEDURE catUpdateProjectType
	@Id		INT,		--The Id of the selected Project Type
 	@Type		VARCHAR(20),	--The Type of the Project Type you want to Update
	@Rank		INT
AS
DECLARE @IdUpdate	INT,
	@Rowcount 	INT

DECLARE	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Type'

	IF EXISTS( SELECT *
	FROM PROJECT_TYPES AS PT
	WHERE 	PT.[Type] = @Type AND
		PT.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Type IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END
	
	exec @RetVal = catUpdateCatalogRank 'PROJECT_TYPES', @Rank,2, @Id

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE PROJECT_TYPES 	
	SET Type = @Type,
	    [Rank] = @Rank
	WHERE [Id] = @Id

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateRegion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateRegion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateRegion
GO
CREATE PROCEDURE catUpdateRegion
	@Id	INT,		--The Id of the selected Region
	@Code	VARCHAR(8),	--The Code of the Region you want to Update
	@Name	VARCHAR(50),	--The Name of the Region you want to Update
	@Rank INT
AS
DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)

	DECLARE @RetVal INT
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM REGIONS AS R
	WHERE 	R.Code = @Code AND
		R.[Id] <> @Id) 
	SET @ValidateLogicKey = 1

	IF EXISTS( SELECT *
	FROM REGIONS AS R
	WHERE 	R.[Name] = @Name AND R.[Id] <> @Id)  
	BEGIN
		SET @ValidateLogicKey = 1
		SET @LogicalKey= 'Name'
	END
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -1
	END

	IF(@Code IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	exec @RetVal = catUpdateCatalogRank 'Regions', @Rank,2, @Id
	IF(@@ERROR<>0 OR @RetVal < 0)
		return -3

	UPDATE REGIONS 	
	SET 	Code = @Code,
		[Name] = @Name,
		[Rank] = @Rank
	WHERE [Id] = @Id	

	SET @Rowcount = @@ROWCOUNT
	RETURN @Rowcount
GO

--Drops the Procedure catUpdateWorkPackage if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateWorkPackage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateWorkPackage
GO
CREATE PROCEDURE catUpdateWorkPackage
	@Id		INT,		--The Id of the selected WorkPackage
	@IdPhase	INT,		--The Id of the Phase that is connected to the Work Package you want to insert
 	@Code		VARCHAR(3),	--The Code of the Work Package you want to Insert
	@Name		VARCHAR(50),	--The Name of the Work Package you want to Insert
	@Rank		INT,		--The Rank of the Work Package you want to Insert
	@IdProject	INT,		--The Project related to this Work Package
	@IsActive	BIT,		--Specifies if the Work Package is Active or not
	@StartYearMonth	INT,	--The Start Date of the work Package
	@EndYearMonth	INT,	--The End Date of the work Package
	@LastUserUpdate	INT		--The Last User Update of the work Package	
AS

	DECLARE @RetVal INT

--validation yearmonth section
Declare	@ErrorMessage		VARCHAR(255),
	@YMValidationResult	INT

	--Identify the original IdPhase
	DECLARE @IdPhase_Original int

 	SELECT @IdPhase_Original = WP.IdPhase
	FROM WORK_PACKAGES AS WP
	WHERE 	WP.Code = @Code AND
		WP.IdProject = @IdProject


if (@StartYearMonth is not null)
begin
	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@StartYearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -2
	end
end

if (@EndYearMonth is not null)
begin
	-- verify if the yearmonth value is valid
	Select @YMValidationResult = ValidationResult,
	       @ErrorMessage = ErrorMessage
	from fnValidateYearMonth(@EndYearMonth)

	if (@YMValidationResult < 0)
	begin
	 	RAISERROR(@ErrorMessage, 16, 1)
		RETURN -3
	end
end
--end validation section

DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(30)
	
	SET @LogicalKey = 'Code, Project'

	IF EXISTS( SELECT *
	FROM WORK_PACKAGES AS WP
	WHERE 	WP.Code = @Code AND
		WP.IdProject = @IdProject AND
		WP.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -4
	END

	IF(@IdPhase IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @Rank IS NULL OR 
	   @IdProject IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -5		
	END



	--If this work package has data in any budget and the startYM or endYM is null, raise an error
	IF 
	(
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_INITIAL_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase_Original AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_REVISED_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase_Original AND
				IdWorkPackage = @Id
		)
		OR
		EXISTS 
		(
			SELECT 	IdWorkPackage
			FROM 	BUDGET_TOCOMPLETION_DETAIL
			WHERE	IdProject = @IdProject AND
				IdPhase = @IdPhase_Original AND
				IdWorkPackage = @Id
		)
	)
	BEGIN
		IF (@StartYearMonth IS NULL OR @EndYearMonth IS NULL)
		BEGIN
			RAISERROR('This Work Package must have the period correctly defined because it contains budget data. ', 16, 1)
			RETURN -6
		END
	END

	--Check if the period has changed (the updated values of startyearmonth and endyearmonth are different than
	--the ones already saved in the database
	DECLARE @OldStartYearMonth INT
	DECLARE @OldEndYearMonth INT

	SELECT 	@OldStartYearMonth = StartYearMonth,
		@OldEndYearMonth = EndYearMonth
	FROM 	WORK_PACKAGES
	WHERE 	IdProject = @IdProject AND
		IdPhase = @IdPhase_Original AND
		[Id] = @Id
	
	IF (@OldStartYearMonth <> @StartYearMonth OR @OldEndYearMonth <> @EndYearMonth)
	BEGIN
		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_TOCOMPLETION_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase_Original AND
					IdWorkPackage = @Id
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateToCompletionWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase_Original, @IdWP = @Id, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR<>0 OR @RetVal < 0)
				RETURN -7
		END

		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_REVISED_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase_Original AND
					IdWorkPackage = @Id
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateRevisedWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase_Original, @IdWP = @Id, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR<>0 OR @RetVal < 0)
				RETURN -8
		END

		IF 
		(
			EXISTS 
			(
				SELECT 	IdWorkPackage
				FROM 	BUDGET_INITIAL_DETAIL
				WHERE	IdProject = @IdProject AND
					IdPhase = @IdPhase_Original AND
					IdWorkPackage = @Id
			)
		)
		BEGIN
			EXEC @RetVal = bgtUpdateInitialWPPeriod @IdProjectParam = @IdProject, @IdPhaseParam = @IdPhase_Original, @IdWP = @Id, @StartYearMonth = @StartYearMonth, @EndYearMonth = @EndYearMonth
			IF (@@ERROR<>0 OR @RetVal < 0)
				RETURN -9
		END
	END

	exec @RetVal = catUpdateWorkPackageRank 'WORK_PACKAGES', @Rank,2, @Id, @IdProject, @IdPhase_Original

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -10


	--check to see if idphase has changed
	IF @IdPhase <> @IdPhase_Original
	BEGIN
		--Update old record with a new code for unique constraint reasons
		DECLARE @TempWPCode varchar(3)
		select @TempWPCode = '_' + RIGHT( CAST(DATEPART(ms,GETDATE()) as VARCHAR(100)),2)	
--  		PRINT @TempWPCode


		UPDATE WORK_PACKAGES 	
		SET   	Code = @TempWPCode
		WHERE 	[Id] = @Id AND
			IdPhase = @IdPhase_Original AND
			IdProject = @IdProject

		--create new record with new data

-- 		get a new max rank
		DECLARE @NewRank int
		SELECT @NewRank = dbo.fnGetWorkPackageMaxRank()	
		

		DECLARE @IdWorkPackageNew int		
		exec @IdWorkPackageNew = catInsertWorkPackage @IdPhase, @Code, @Name, @NewRank, @IdProject, @IsActive, @StartYearMonth, @EndYearMonth, @LastUserUpdate
		
		IF(@@ERROR<>0 OR @IdWorkPackageNew < 0)
			return -11
		
		--UPDATE RELATED TABLES

		exec @RetVal = catUpdateWPKeyReferences @IdProject, @IdPhase, @IdWorkPackageNew, @Id, @IdPhase_Original
		IF(@@ERROR<>0 OR @RetVal < 0)
			return -12
		--delete old record from workpackage		
		

		exec  catDeleteWorkPackage @IdProject, @IdPhase_Original,@Id 
		SET @Rowcount = @@ROWCOUNT	
	END
	ELSE
	BEGIN

		UPDATE WORK_PACKAGES 	
		SET   	Code = @Code,
			[Name] = @Name,
			Rank = @Rank,
			IsActive = @IsActive,
			StartYearMonth = @StartYearMonth,
			EndYearMonth = @EndYearMonth,
			LastUpdate = GETDATE(),
			LastUserUpdate = @LastUserUpdate
		WHERE 	[Id] = @Id AND
			IdPhase = @IdPhase AND
			IdProject = @IdProject

		SET @Rowcount = @@ROWCOUNT

	END
	
	RETURN @Rowcount

GO

--Drops the Procedure catUpdateWorkPackageRank if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateWorkPackageRank]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateWorkPackageRank
GO
CREATE PROCEDURE catUpdateWorkPackageRank
	@TableName	NVARCHAR(200),	--The Name of the table you want to Update
	@Rank 		INT,
	@Direction	INT,		-- UP (Rank+1), DOWN (Rank-1)
	@Id		INT,		-- id of the row that change rank
	@IdProject	INT,
	@IdPhase	INT
AS

DECLARE @SQL  NVARCHAR(500)

IF (@Rank<1)
BEGIN 
	RAISERROR('Rank field must be bigger than 0',16,1)		
	RETURN -1
END

DECLARE @RANK_ORIGINAL INT
SELECT @RANK_ORIGINAL = ISNULL(Rank,0)
FROM WORK_PACKAGES
WHERE IdProject = @IdProject AND
      IdPhase = @IdPhase AND
      Id = @Id

IF(@Rank = @RANK_ORIGINAL)
	RETURN

--DELETE OPERATION
IF(@Direction=0)
BEGIN
-- 	PRINT @Rank
	SET @SQL = 'UPDATE '+ @TableName + ' SET Rank = Rank - 1 WHERE Rank> '+ CAST(@Rank AS NVARCHAR(9))
-- 	PRINT @SQL
	EXEC(@SQL)
	RETURN
END

--INSERT OPERATION
IF(@Direction=1)
BEGIN
-- 	PRINT 'HERE 1'
	SET @SQL = 'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL = @SQL + 'UPDATE '+ @TableName + ' SET Rank = Rank +1 WHERE Rank>= '+ CAST(@Rank AS NVARCHAR(9))		
--  	PRINT @SQL
	EXEC(@SQL)
	RETURN
END
--UPDATE OPERATION
IF(@Direction=2)
BEGIN
-- PRINT 'HERE 2'
	SET @SQL=N'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL=@SQL + ' BEGIN ' + CHAR(13)
	SET @SQL=@SQL + ' DECLARE @OLDRANK INT;' + CHAR(13)
	SET @SQL=@SQL + ' SELECT @OLDRANK=RANK FROM ' + @TableName + ' WHERE ID='+ CAST(@ID AS NVARCHAR(9))+  + CHAR(13)
	SET @SQL=@SQL + ' AND IdProject='+ CAST(@IdProject AS NVARCHAR(9))+  + CHAR(13)
	SET @SQL=@SQL + ' AND IdPhase='+ CAST(@IdPhase AS NVARCHAR(9))+  + CHAR(13)

	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank = -1 WHERE Id ='+ CAST(@Id AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' AND IdProject='+ CAST(@IdProject AS NVARCHAR(9))+  + CHAR(13)
	SET @SQL=@SQL + ' AND IdPhase='+ CAST(@IdPhase AS NVARCHAR(9))+  + CHAR(13)

	SET @SQL=@SQL + ' IF @OLDRANK<'+CAST(@RANK AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank-1 WHERE Rank>@OLDRANK AND Rank <=' + CAST(@Rank AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' IF @OLDRANK>'+CAST(@RANK AS NVARCHAR(9))+ CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank+1 WHERE Rank>=' + CAST(@Rank AS NVARCHAR(9))+' AND Rank<@OLDRANK;' + CHAR(13)
	SET @SQL=@SQL + ' END '
	
--    	PRINT @SQL
	EXEC sp_executesql @SQL
--BEGIN TRAN;exec catDeleteWorkPackage @IdProject = 26, @IdPhase = 1, @Id = 1;SELECT * FROM WORK_PACKAGES;ROLLBACK TRAN	

END




GO



--Drops the Procedure catUpdateWorkPackageTemplate if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateWorkPackageTemplate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateWorkPackageTemplate
GO
CREATE PROCEDURE catUpdateWorkPackageTemplate
	@Id		INT,		--The Id of the selected WorkPackage
	@IdPhase	INT,		--The Id of the Phase that is connected to the Work Package you want to insert
 	@Code		VARCHAR(3),	--The Code of the Work Package you want to Insert
	@Name		VARCHAR(50),	--The Name of the Work Package you want to Insert
	@Rank		INT,		--The Rank of the Work Package you want to Insert
	@IsActive	BIT,		--Specifies if the Work Package is Active or not
	@LastUserUpdate	INT		--The Last User Update of the work Package	
AS

	DECLARE @RetVal INT

Declare	@ErrorMessage		VARCHAR(255)

	--Identify the original IdPhase
	DECLARE @IdPhase_Original int

 	SELECT @IdPhase_Original = WP.IdPhase
	FROM WORK_PACKAGES_TEMPLATE AS WP
	WHERE 	WP.Code = @Code




DECLARE @Rowcount 		INT,
	@ValidateLogicKey	BIT,
	@LogicalKey		VARCHAR(30)
	
	SET @LogicalKey = 'Code'

	IF EXISTS( SELECT *
	FROM WORK_PACKAGES_TEMPLATE AS WP
	WHERE 	WP.Code = @Code AND
		WP.[Id] <> @Id) 
	SET @ValidateLogicKey = 1
	
	IF (@ValidateLogicKey = 1)
	BEGIN
		EXEC   auxSelectErrorMessage_1 @Code = 'DUPLICATE_LOGIC_KEY_1',@IdLanguage = 1,@Parameter1 = @LogicalKey, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -4
	END

	IF(@IdPhase IS NULL OR 
	   @Code IS NULL OR 
	   @Name IS NULL OR 
	   @Rank IS NULL OR 
	   @IsActive IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -5		
	END

	exec @RetVal = catUpdateWorkPackageTemplateRank 'WORK_PACKAGES_TEMPLATE', @Rank,2, @Id, @IdPhase_Original

	IF(@@ERROR<>0 OR @RetVal < 0)
		return -10


	--check to see if idphase has changed
	IF @IdPhase <> @IdPhase_Original
	BEGIN
		--Update old record with a new code for unique constraint reasons
		DECLARE @TempWPCode varchar(3)
		select @TempWPCode = '_' + RIGHT( CAST(DATEPART(ms,GETDATE()) as VARCHAR(100)),2)	
--  		PRINT @TempWPCode


		UPDATE WORK_PACKAGES_TEMPLATE 	
		SET   	Code = @TempWPCode
		WHERE 	[Id] = @Id AND
			IdPhase = @IdPhase_Original

		--create new record with new data

-- 		get a new max rank
		DECLARE @NewRank int
		SELECT @NewRank = dbo.fnGetWorkPackageTemplateMaxRank()	
		

		DECLARE @IdWorkPackageTemplateNew int		
		exec @IdWorkPackageTemplateNew = catInsertWorkPackageTemplate @IdPhase, @Code, @Name, @NewRank, @IsActive, @LastUserUpdate
		
		IF(@@ERROR<>0 OR @IdWorkPackageTemplateNew < 0)
			return -11
		
		exec  catDeleteWorkPackageTemplate @IdPhase_Original,@Id 
		SET @Rowcount = @@ROWCOUNT	
	END
	ELSE
	BEGIN

		UPDATE WORK_PACKAGES_TEMPLATE 	
		SET   	Code = @Code,
			[Name] = @Name,
			Rank = @Rank,
			IsActive = @IsActive,
			LastUpdate = GETDATE(),
			LastUserUpdate = @LastUserUpdate
		WHERE 	[Id] = @Id AND
			IdPhase = @IdPhase

		SET @Rowcount = @@ROWCOUNT

	END
	
	RETURN @Rowcount

GO

--Drops the Procedure catUpdateWorkPackageTemplateRank if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateWorkPackageTemplateRank]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateWorkPackageTemplateRank
GO
CREATE PROCEDURE catUpdateWorkPackageTemplateRank
	@TableName	NVARCHAR(200),	--The Name of the table you want to Update
	@Rank 		INT,
	@Direction	INT,		-- UP (Rank+1), DOWN (Rank-1)
	@Id		INT,		-- id of the row that change rank
	@IdPhase	INT
AS

DECLARE @SQL  NVARCHAR(500)

IF (@Rank<1)
BEGIN 
	RAISERROR('Rank field must be bigger than 0',16,1)		
	RETURN -1
END

DECLARE @RANK_ORIGINAL INT
SELECT @RANK_ORIGINAL = ISNULL(Rank,0)
FROM WORK_PACKAGES_TEMPLATE
WHERE IdPhase = @IdPhase AND
      Id = @Id

IF(@Rank = @RANK_ORIGINAL)
	RETURN

--DELETE OPERATION
IF(@Direction=0)
BEGIN
-- 	PRINT @Rank
	SET @SQL = 'UPDATE '+ @TableName + ' SET Rank = Rank - 1 WHERE Rank> '+ CAST(@Rank AS NVARCHAR(9))
-- 	PRINT @SQL
	EXEC(@SQL)
	RETURN
END

--INSERT OPERATION
IF(@Direction=1)
BEGIN
-- 	PRINT 'HERE 1'
	SET @SQL = 'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL = @SQL + 'UPDATE '+ @TableName + ' SET Rank = Rank +1 WHERE Rank>= '+ CAST(@Rank AS NVARCHAR(9))		
--  	PRINT @SQL
	EXEC(@SQL)
	RETURN
END
--UPDATE OPERATION
IF(@Direction=2)
BEGIN
-- PRINT 'HERE 2'
	SET @SQL=N'DECLARE @IDTEST INT; SELECT @IDTEST=ID FROM ' + @TableName + ' WHERE RANK ='+CAST(ISNULL(@Rank,0) AS NVARCHAR(9)) + CHAR(13)
	SET @SQL = @SQL + ' IF @IDTEST>0 ' + CHAR(13)
	SET @SQL=@SQL + ' BEGIN ' + CHAR(13)
	SET @SQL=@SQL + ' DECLARE @OLDRANK INT;' + CHAR(13)
	SET @SQL=@SQL + ' SELECT @OLDRANK=RANK FROM ' + @TableName + ' WHERE ID='+ CAST(@ID AS NVARCHAR(9))+  + CHAR(13)
	SET @SQL=@SQL + ' AND IdPhase='+ CAST(@IdPhase AS NVARCHAR(9))+  + CHAR(13)

	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank = -1 WHERE Id ='+ CAST(@Id AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' AND IdPhase='+ CAST(@IdPhase AS NVARCHAR(9))+  + CHAR(13)

	SET @SQL=@SQL + ' IF @OLDRANK<'+CAST(@RANK AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank-1 WHERE Rank>@OLDRANK AND Rank <=' + CAST(@Rank AS NVARCHAR(9)) + CHAR(13)
	SET @SQL=@SQL + ' IF @OLDRANK>'+CAST(@RANK AS NVARCHAR(9))+ CHAR(13)
	SET @SQL=@SQL + ' UPDATE '+ @TableName + ' SET Rank =Rank+1 WHERE Rank>=' + CAST(@Rank AS NVARCHAR(9))+' AND Rank<@OLDRANK;' + CHAR(13)
	SET @SQL=@SQL + ' END '
	
--    	PRINT @SQL
	EXEC sp_executesql @SQL
--BEGIN TRAN;exec catDeleteWorkPackage @IdProject = 26, @IdPhase = 1, @Id = 1;SELECT * FROM WORK_PACKAGES;ROLLBACK TRAN	

END




GO



--Drops the Procedure catUpdateRelatedTablesForWorkPackage if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[catUpdateWPKeyReferences]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE catUpdateWPKeyReferences
GO

CREATE PROCEDURE catUpdateWPKeyReferences	
	@IdProject	  INT,
	@IdPhase	  INT,
	@IdWorkPackageNew INT,
	@Id		  INT,
	@IdPhase_Original INT
	
AS

BEGIN
--INTERCO
		UPDATE PROJECTS_INTERCO
		SET IdWorkPackage 	= @IdWorkPackageNew,
		    IdPhase	  	= @IdPhase
		WHERE IdProject 	= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage 	= @Id

-- 		BUDGET INTIAL
-- 		INSERT NEW RECORD BECAUSE OF THE FOREIGN KEY MECHANISM
		INSERT INTO BUDGET_INITIAL_DETAIL
		SELECT 	IdProject, 
			@IdPhase, 
			@IdWorkPackageNew, 
			IdCostCenter, 
			IdAssociate, 
			YearMonth, 
			HoursQty, 
			HoursVal, 
			SalesVal, 
			IdCountry, 
			IdAccountHours,
			IdAccountSales
		FROM BUDGET_INITIAL_DETAIL
		WHERE IdProject 	= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage 	= @Id		

		UPDATE BUDGET_INITIAL_DETAIL_COSTS
		SET IdWorkPackage 	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id
-- 		AFTER UPDATES DELETE OLD RECORDS
		DELETE FROM BUDGET_INITIAL_DETAIL		
		WHERE IdProject 	= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage 	= @Id
	


-- 		BUDGET_REVISED
		INSERT INTO BUDGET_REVISED_DETAIL
		SELECT 	IdProject, 
			IdGeneration, 
			@IdPhase, 
			@IdWorkPackageNew, 
			IdCostCenter, 
			IdAssociate, 
			YearMonth, 
			HoursQty, 
			HoursVal, 
			SalesVal, 
			IdCountry, 
			IdAccountHours, 
			IdAccountSales 
		FROM BUDGET_REVISED_DETAIL
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id


		UPDATE BUDGET_REVISED_DETAIL_COSTS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

		DELETE FROM BUDGET_REVISED_DETAIL		
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id
		
-- 		BUDGET_TOCOMPLETION
		INSERT INTO BUDGET_TOCOMPLETION_PROGRESS
		SELECT 	IdProject, 
			IdGeneration, 
			@IdPhase, 
			@IdWorkPackageNew, 
			IdAssociate, 
			[Percent]
		FROM BUDGET_TOCOMPLETION_PROGRESS
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id


		INSERT INTO BUDGET_TOCOMPLETION_DETAIL
		SELECT 	IdProject, 
			IdGeneration, 
			@IdPhase, 
			@IdWorkPackageNew, 
			IdCostCenter, 
			IdAssociate, 
			YearMonth, 
			HoursQty, 
			HoursVal, 
			SalesVal, 
			IdCountry, 
			IdAccountHours, 
			IdAccountSales 
		FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

		
		UPDATE BUDGET_TOCOMPLETION_DETAIL_COSTS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id		


		DELETE FROM BUDGET_TOCOMPLETION_DETAIL		
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id
		
		DELETE FROM BUDGET_TOCOMPLETION_PROGRESS		
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

-- 		ACTUAL_DATA
		
		UPDATE ACTUAL_DATA_DETAILS_HOURS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id
		
		UPDATE ACTUAL_DATA_DETAILS_SALES
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

		UPDATE ACTUAL_DATA_DETAILS_COSTS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id


-- 		ANNUAL_DATA
		UPDATE ANNUAL_BUDGET_DATA_DETAILS_HOURS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

		UPDATE ANNUAL_BUDGET_DATA_DETAILS_SALES
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id

		UPDATE ANNUAL_BUDGET_DATA_DETAILS_COSTS
		SET IdWorkPackage	= @IdWorkPackageNew,
		    IdPhase		= @IdPhase
		WHERE IdProject		= @IdProject AND
		      IdPhase		= @IdPhase_Original AND
		      IdWorkPackage	= @Id
END


GO

--Drops the Procedure extExtractByFunctionActualData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractByFunctionActualData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractByFunctionActualData
GO

-- exec extExtractByFunctionActualData 2008,-1,-1,-1,-1,-1,'L'

CREATE PROCEDURE extExtractByFunctionActualData
(	
	@Year			INT,
	@IdRegion 		INT,
	@IdCountry 		INT,
	@IdInergyLocation 	INT,
	@IdFunction 		INT,
	@IdDepartment 		INT,
	@WPActiveStatus 	VARCHAR(1),
	@CostTypeCategory	VARCHAR(1),
	@IdCurrencyAssociate	INT
)
AS

-- create temporary table #INCOME_COST_TYPES_CATEGORY to categorize cost types
create table #INCOME_COST_TYPES_CATEGORY(IdCostType int, CostTypeCategory varchar(1))

insert into #INCOME_COST_TYPES_CATEGORY (IdCostType, CostTypeCategory)
select Id, 'O' from BUDGET_COST_TYPES

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetHoursCostTypeID(), 'H'

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetSalesCostTypeID(), 'S'


CREATE TABLE #tempActual
(
	IdProject 	INT NOT NULL,
	IdPhase 	INT NOT NULL,
	IdWorkPackage 	INT NOT NULL,
	IdCostCenter 	INT NOT NULL,
	IdAssociate 	INT NOT NULL,
	YearMonth 	INT NOT NULL,
	AccountNumber 	varchar(20) NOT NULL,
	Quantity 	decimal(12,2) NULL,
	Value 		decimal(18,2) NULL

	PRIMARY KEY (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, YearMonth, AccountNumber) 
)


--GET ALL HOURS RECORDS FROM ACTUAL DATA
INSERT INTO #tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate,
		YearMonth, AccountNumber, Quantity, Value)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter, AD.IdAssociate,
	AD.YearMonth, GLA.Account,  SUM(AD.HoursQty), SUM(AD.HoursVal)
FROM ACTUAL_DATA_DETAILS_HOURS AD
INNER JOIN ACTUAL_DATA A 
	ON A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC 
	ON AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP ON
	AD.Idproject = WP.IdProject AND
	AD.IdPhase = WP.IdPhase AND
	AD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	AD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END

GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter, AD.IdAssociate,
	AD.YearMonth, GLA.Account

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO #tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate,
		YearMonth, AccountNumber, Quantity, Value)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter, AD.IdAssociate,
	AD.YearMonth, GLA.Account, null, SUM(AD.SalesVal)
FROM ACTUAL_DATA_DETAILS_SALES AD
INNER JOIN ACTUAL_DATA A  
	ON A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC 
	ON AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON AD.IdCountry = GLA.IdCountry AND
	   AD.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS D 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP ON
	AD.Idproject = WP.IdProject AND
	AD.IdPhase = WP.IdPhase AND
	AD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	AD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter, AD.IdAssociate,
	AD.YearMonth, GLA.Account 

--GET ALL OTHER COSTS
INSERT INTO #tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate,
		YearMonth, AccountNumber, Quantity, Value)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter, ADDC.IdAssociate,
	ADDC.YearMonth, GLA.Account,  null, SUM(ADDC.CostVal)
FROM ACTUAL_DATA_DETAILS_COSTS ADDC
INNER JOIN ACTUAL_DATA A  
	ON A.IdProject = ADDC.IdProject
INNER JOIN COST_CENTERS CC 
	ON ADDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON ADDC.IdCountry = GLA.IdCountry AND
	   ADDC.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP ON
	ADDC.Idproject = WP.IdProject AND
	ADDC.IdPhase = WP.IdPhase AND
	ADDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE   ADDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END
GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter, ADDC.IdAssociate,
	ADDC.YearMonth, GLA.Account

SELECT 	P.Code as 				[Project Code],
	P.Name as 				[Project Name],
	PH.Code as 				[Phase Code],
	WP.Code as 				[WP Code],
	WP.Name as				[WP Name],
	WP.Rank as				[WP Rank],
	C.Name as 				[Country Name],
	IL.Name as 				[Inergy Location Name],
	CC.Code as 				[Cost Center Code],
	CC.Name as 				[Cost Center Name],
	D.Name as 				[Department Name],
	F.Name as 				[Function Name],
	A.Name as 				[Employee Name],
	A.EmployeeNumber as 			[Employee Number],
	CIT.Name as 				[Cost Type Name],
	t.AccountNumber as 			[GL Account Number],
	GL.Name as 				[GL Account Description],
	CAST('actual' AS VARCHAR(15)) as	[Extract Category],
	t.YearMonth/100 as 			[Year],
	t.YearMonth%100 as 			[Month],
	t.Quantity as 				[Quantity],
	t.Value as			 	[Value],
	CUR.Code as 				[Currency],
	--CAST(dbo.fnGetExchangeRate(dbo.fnGetEuroId(),CUR.Id,t.YearMonth)AS DECIMAL(18,2)) AS [Exchange Rate]
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate]

FROM #tempActual t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN ASSOCIATES A
	ON t.IdAssociate = A.Id
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth


GO



--Drops the Procedure extExtractByFunctionAnnualBudgetData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractByFunctionAnnualBudgetData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractByFunctionAnnualBudgetData
GO

-- exec extExtractByFunctionAnnualBudgetData 2005,-1,-1,-1,-1,-1,'L'

CREATE PROCEDURE extExtractByFunctionAnnualBudgetData
(
	@Year			INT,
	@IdRegion 		INT,
	@IdCountry 		INT,
	@IdInergyLocation 	INT,
	@IdFunction 		INT,
	@IdDepartment 		INT,
	@WPActiveStatus 	VARCHAR(1),
	@CostTypeCategory	VARCHAR(1),
	@IdCurrencyAssociate	INT
)

AS

-- create temporary table #INCOME_COST_TYPES_CATEGORY to categorize cost types
create table #INCOME_COST_TYPES_CATEGORY(IdCostType int, CostTypeCategory varchar(1))

insert into #INCOME_COST_TYPES_CATEGORY (IdCostType, CostTypeCategory)
select Id, 'O' from BUDGET_COST_TYPES

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetHoursCostTypeID(), 'H'

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetSalesCostTypeID(), 'S'

DECLARE @tempAnnual table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter 	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	Quantity 	decimal(12,2),
	Value 		decimal(18,2),
	DateImport	SMALLDATETIME

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber)
)


--GET ALL HOURS RECORDS FROM ANNUAL BUDGET DATA

INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, DateImport)

SELECT  ABD.IdProject, ABD.IdPhase, ABD.IdWorkPackage, ABD.IdCostCenter,
	ABD.YearMonth, GLA.Account, SUM(ABD.HoursQty), SUM(ABD.HoursVal), ABD.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_HOURS ABD
INNER JOIN ANNUAL_BUDGET AB
	ON AB.IdProject = ABD.IdProject
INNER JOIN COST_CENTERS CC 
	ON ABD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON ABD.IdCountry = GLA.IdCountry AND
	   ABD.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON ABD.Idproject = WP.IdProject AND
	   ABD.IdPhase = WP.IdPhase AND
	   ABD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	ABD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END
GROUP BY ABD.IdProject, ABD.IdPhase, ABD.IdWorkPackage, ABD.IdCostCenter,
	ABD.YearMonth, GLA.Account, ABD.DateImport

--GET ALL SALES RECORDS FROM ANNUAL BUDGET DATA

INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, DateImport)

SELECT  ABDS.IdProject, ABDS.IdPhase, ABDS.IdWorkPackage, ABDS.IdCostCenter,
	ABDS.YearMonth, GLA.Account, 0, SUM(ABDS.SalesVal), ABDS.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_SALES ABDS
INNER JOIN ANNUAL_BUDGET AB  
	ON AB.IdProject = ABDS.IdProject
INNER JOIN COST_CENTERS CC 
	ON ABDS.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON ABDS.IdCountry = GLA.IdCountry AND
	   ABDS.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN FUNCTIONS F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON ABDS.Idproject = WP.IdProject AND
	   ABDS.IdPhase = WP.IdPhase AND
	   ABDS.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	ABDS.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END
GROUP BY ABDS.IdProject, ABDS.IdPhase, ABDS.IdWorkPackage, ABDS.IdCostCenter,
	ABDS.YearMonth, GLA.Account, ABDS.DateImport

--GET ALL OTHER COSTS
INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, DateImport)
SELECT ABDC.IdProject, ABDC.IdPhase, ABDC.IdWorkPackage, ABDC.IdCostCenter,
	ABDC.YearMonth, GLA.Account, 0, SUM(ABDC.CostVal), ABDC.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_COSTS ABDC
INNER JOIN ANNUAL_BUDGET AB  
	ON AB.IdProject = ABDC.IdProject
INNER JOIN COST_CENTERS CC 
	ON ABDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON ABDC.IdCountry = GLA.IdCountry AND
	   ABDC.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN FUNCTIONS F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON ABDC.Idproject = WP.IdProject AND
	   ABDC.IdPhase = WP.IdPhase AND
	   ABDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE   ABDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END AND
	ictc.CostTypeCategory = CASE 
				  WHEN @CostTypeCategory = 'A' THEN ictc.CostTypeCategory 
				  ELSE @CostTypeCategory 
				END
GROUP BY ABDC.IdProject, ABDC.IdPhase, ABDC.IdWorkPackage, ABDC.IdCostCenter,
	ABDC.YearMonth, GLA.Account, ABDC.DateImport



SELECT 	P.Code as 				[Project Code],
	P.Name as 				[Project Name],
	PH.Code as 				[Phase Code],
	WP.Code as 				[WP Code],
	WP.Name as				[WP Name],
	WP.Rank as				[WP Rank],
	C.Name as 				[Country Name],
	IL.Name as 				[Inergy Location Name],
	CC.Code as 				[Cost Center Code],
	CC.Name as 				[Cost Center Name],
	D.Name as 				[Department Name],
	F.Name as 				[Function Name],
	CIT.Name as 				[Cost Type Name],
	t.AccountNumber as 			[GL Account Number],
	GL.Name as 				[GL Account Description],
	CAST('annual budget' AS VARCHAR(15)) as	[Extract Category],
	t.YearMonth/100 as 			[Year],
	t.YearMonth%100 as 			[Month],
	t.Quantity as 				[Quantity],
	t.Value as			 	[Value],
	CUR.Code as 				[Currency],
	CAST(dbo.fnGetAnnualExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.DateImport) as	[Import Date]
	
FROM @tempAnnual t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO


--Drops the Procedure extExtractByFunctionInitialData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractByFunctionInitialData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractByFunctionInitialData
GO

-- exec extExtractByFunctionInitialData 2008,-1,-1,-1,-1,-1,'L'

CREATE PROCEDURE extExtractByFunctionInitialData
(
	@Year			INT,
	@IdRegion 		INT,
	@IdCountry 		INT,
	@IdInergyLocation 	INT,
	@IdFunction 		INT,
	@IdDepartment 		INT,
	@WPActiveStatus 	VARCHAR(1),
	@CostTypeCategory	VARCHAR(1),
	@IdCurrencyAssociate	INT
)

AS

DECLARE @tempInitial table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter 	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	IdAssociate 	int,
	Quantity 	INT,
	Value 		bigint

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)



-- create temporary table #INCOME_COST_TYPES_CATEGORY to categorize cost types
create table #INCOME_COST_TYPES_CATEGORY(IdCostType int, CostTypeCategory varchar(1))

insert into #INCOME_COST_TYPES_CATEGORY (IdCostType, CostTypeCategory)
select Id, 'O' from BUDGET_COST_TYPES

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetHoursCostTypeID(), 'H'

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetSalesCostTypeID(), 'S'


--GET ALL HOURS RECORDS
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value)
SELECT  BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, ROUND(SUM(BID.HoursQty),0), ROUND(SUM(BID.HoursVal),0)
FROM BUDGET_INITIAL_DETAIL BID
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = BID.IdProject
INNER JOIN COST_CENTERS CC 
	ON BID.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BID.IdCountry = GLA.IdCountry AND
  	   BID.IdAccountHours = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BID.Idproject = WP.IdProject AND
	   BID.IdPhase = WP.IdPhase AND
	   BID.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	(BID.HoursQty IS NOT NULL OR BID.HoursVal IS NOT NULL) AND
	BID.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate


--GET ALL SALES RECORD
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate,Quantity, Value)

SELECT  BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, 0, ROUND(SUM(BID.SalesVal),0)
FROM 	BUDGET_INITIAL_DETAIL BID
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = BID.IdProject
INNER JOIN COST_CENTERS CC 
	ON BID.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BID.IdCountry = GLA.IdCountry AND
	   BID.IdAccountSales = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BID.Idproject = WP.IdProject AND
	   BID.IdPhase = WP.IdPhase AND
	   BID.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE	BID.SalesVal IS NOT NULL AND
	BID.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate


--GET ALL OTHER COSTS
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value)

SELECT 	BIDC.IdProject, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter,
	BIDC.YearMonth, GLA.Account, BIDC.IdAssociate,0, ROUND(SUM(BIDC.CostVal),0)

FROM 	BUDGET_INITIAL_DETAIL_COSTS BIDC
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = BIDC.IdProject
INNER JOIN COST_CENTERS CC 
	ON BIDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BIDC.IdCountry = GLA.IdCountry AND
	   BIDC.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BIDC.Idproject = WP.IdProject AND
	   BIDC.IdPhase = WP.IdPhase AND
	   BIDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE   BIDC.CostVal IS NOT NULL AND
	BIDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BIDC.IdProject, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter,
	BIDC.YearMonth, GLA.Account, BIDC.IdAssociate


SELECT 	P.Code as 					[Project Code],
	P.Name as					[Project Name],
	PH.Code as 					[Phase Code],
	WP.Code as 					[WP Code],
	WP.Name as					[WP Name],
	WP.Rank as					[WP Rank],
	C.Name as 					[Country Name],
	IL.Name as 					[Inergy Location Name],
	CC.Code as 					[Cost Center Code],
	CC.Name as 					[Cost Center Name],
	D.Name as 					[Department Name],
	F.Name as 					[Function Name],
	A.Name as 					[Employee Name],
	A.EmployeeNumber as 				[Employee Number],
	CIT.Name as 					[Cost Type Name],
	t.AccountNumber as 				[GL Account Number],
	GL.Name as 					[GL Account Description],
	CAST('initial' AS VARCHAR(15)) as		[Extract Category],
	t.YearMonth/100 as 				[Year],
	t.YearMonth%100 as 				[Month],
	t.Quantity as					[Quantity],
	t.Value as 					[Value],
	CUR.Code as 					[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth) AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(BI.ValidationDate) as		[Validation Date]
	
FROM @tempInitial t
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = T.IdProject
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN ASSOCIATES A
	ON t.IdAssociate = A.Id
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth


GO


--Drops the Procedure extExtractByFunctionReforcastData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractByFunctionReforcastData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractByFunctionReforcastData
GO
-- exec extExtractByFunctionReforcastData 2008,1,5,1,-1,-1,'L'

CREATE PROCEDURE extExtractByFunctionReforcastData
(
	@Year			INT,
	@IdRegion 		INT,
	@IdCountry 		INT,
	@IdInergyLocation 	INT,
	@IdFunction 		INT,
	@IdDepartment 		INT,
	@WPActiveStatus 	VARCHAR(1),
	@CostTypeCategory	VARCHAR(1),
	@IdCurrencyAssociate	INT
)

AS

DECLARE @tempReforcast table
(
	IdExtract 		INT  IDENTITY (1, 1) NOT NULL,
	IdProject 		INT,
	IdPhase 		INT,
	IdWorkPackage 		INT,
	IdCostCenter 		INT,
	YearMonth 		INT,
	AccountNumber 		varchar(20),
	IdAssociate 		INT,
	Quantity 		decimal(12,2),
	Value 			decimal(21,2),
	[Date] 			smalldatetime,
	[Percent]		decimal(18,2),
	ExtractCategoty		varchar(15)

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)

-- create temporary table #INCOME_COST_TYPES_CATEGORY to categorize cost types
create table #INCOME_COST_TYPES_CATEGORY(IdCostType int, CostTypeCategory varchar(1))

insert into #INCOME_COST_TYPES_CATEGORY (IdCostType, CostTypeCategory)
select Id, 'O' from BUDGET_COST_TYPES

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetHoursCostTypeID(), 'H'

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetSalesCostTypeID(), 'S'




----------Create YearMonth for the previous month taking into account the current month
	DECLARE @YearMonthOfPreviousMonth INT
	Set @YearMonthOfPreviousMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate())

--GET ALL HOURS RECORDS
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, SUM(ROUND(BCD.HoursQty,0)), SUM(ROUND(BCD.HoursVal,0)), BC.ValidationDate, BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL BCD
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP 
	ON BCD.Idproject = BP.IdProject AND
	   BCD.IdGeneration = BP.IdGeneration AND
	   BCD.IdPhase	= BP.IdPhase AND
	   BCD.IdWorkPackage = BP.IdWorkPackage and
	   BCD.IdAssociate = BP.IdAssociate
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON BC.IdProject = BCD.IdProject AND
	   BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BCD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BCD.IdCountry = GLA.IdCountry AND
	   BCD.IdAccountHours = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BCD.Idproject = WP.IdProject AND
	   BCD.IdPhase = WP.IdPhase AND
	   BCD.IdWorkPackage = WP.Id
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GLA.IdCostType
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND
	(BCD.HoursQty IS NOT NULL OR BCD.HoursVal IS NOT NULL) AND
	BCD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND
	BCD.YearMonth > CASE WHEN BC.IsValidated = 1 THEN ISNULL(BC.YearMonthActualData, 190001)
						 ELSE @YearMonthOfPreviousMonth END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account,BCD.IdAssociate, BC.ValidationDate, BP.[Percent]


--GET ALL SALES RECORD
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, 0, SUM(ROUND(BCD.SalesVal,0)), BC.ValidationDate, BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL BCD
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP 
	ON BCD.Idproject = BP.IdProject AND
	   BCD.IdGeneration = BP.IdGeneration AND
	   BCD.IdPhase	= BP.IdPhase AND
	   BCD.IdWorkPackage = BP.IdWorkPackage and
	   BCD.IdAssociate = BP.IdAssociate
INNER JOIN BUDGET_TOCOMPLETION BC  
	ON BC.IdProject = BCD.IdProject AND
	   BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BCD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BCD.IdCountry = GLA.IdCountry AND
	   BCD.IdAccountSales = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BCD.Idproject = WP.IdProject AND
	   BCD.IdPhase = WP.IdPhase AND
	   BCD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND	
	BCD.SalesVal IS NOT NULL AND
	BCD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND
	BCD.YearMonth > CASE WHEN BC.IsValidated = 1 THEN ISNULL(BC.YearMonthActualData, 190001)
						 ELSE @YearMonthOfPreviousMonth END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
		AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, BC.ValidationDate, BP.[Percent]


--GET ALL OTHER COSTS
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)
SELECT 	BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, BCDC.IdAssociate, 0, SUM(ROUND(BCDC.CostVal,0)), BC.ValidationDate, BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL_COSTS BCDC
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP 
	ON BCDC.Idproject = BP.IdProject AND
	   BCDC.IdGeneration = BP.IdGeneration AND
	   BCDC.IdPhase	= BP.IdPhase AND
	   BCDC.IdWorkPackage = BP.IdWorkPackage and
	   BCDC.IdAssociate = BP.IdAssociate
INNER JOIN  BUDGET_TOCOMPLETION BC 
	ON BC.IdProject = BCDC.IdProject AND
	   BC.IdGeneration = BCDC.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BCDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BCDC.IdCountry = GLA.IdCountry AND
	   BCDC.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BCDC.Idproject = WP.IdProject AND
	   BCDC.IdPhase = WP.IdPhase AND
	   BCDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BCDC.IdGeneration = dbo.fnGetToCompletionBudgetGeneration(BC.IdProject,'C') AND
	BCDC.CostVal IS NOT NULL AND
	BCDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND
	BCDC.YearMonth > CASE WHEN BC.IsValidated = 1 THEN ISNULL(BC.YearMonthActualData, 190001)
						  ELSE @YearMonthOfPreviousMonth END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, BCDC.IdAssociate, BC.ValidationDate, BP.[Percent]




DECLARE @actualTemp table
(
	IdExtract 		INT  IDENTITY (1, 1) NOT NULL,
	IdProject 		INT,
	IdPhase 		INT,
	IdWorkPackage 		INT,
	IdCostCenter 		INT,
	YearMonth 		INT,
	AccountNumber 		varchar(20),
	IdAssociate 		INT,
	Quantity 		decimal (12,2),
	Value 			decimal (21,2),
	[Date] 			smalldatetime,
	ExtractCategoty		varchar(15)

 	PRIMARY KEY (YearMonth, IdProject,IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)

--GET ALL HOURS RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, SUM(AD.HoursQty), SUM(AD.HoursVal), NULL, 'actual'
FROM ACTUAL_DATA A
INNER JOIN ACTUAL_DATA_DETAILS_HOURS AD 
	ON A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC 
	ON AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON AD.IdCountry = GLA.IdCountry AND
	   AD.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON A.IdProject = BC.IdProject AND
	   dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON AD.Idproject = WP.IdProject AND
	   AD.IdPhase = WP.IdPhase AND
	   AD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	AD.YearMonth <= case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
							 else @YearMonthOfPreviousMonth end	AND
	AD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, 0, SUM(AD.SalesVal), NULL, 'actual'
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_SALES AD 
	ON A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC 
	ON AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON AD.IdCountry = GLA.IdCountry AND
	   AD.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON A.IdProject = BC.IdProject AND
	   dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON AD.Idproject = WP.IdProject AND
	   AD.IdPhase = WP.IdPhase AND
	   AD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	AD.YearMonth <= CASE WHEN BC.IsValidated = 1 THEN ISNULL(BC.YearMonthActualData, 190001)
							 ELSE @YearMonthOfPreviousMonth END	AND
	AD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate

--GET ALL OTHER COSTS
INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate, 0, SUM(ADDC.CostVal), NULL, 'actual'
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_COSTS ADDC 
	ON A.IdProject = ADDC.IdProject
INNER JOIN COST_CENTERS CC 
	ON ADDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON ADDC.IdCountry = GLA.IdCountry AND
	   ADDC.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON A.IdProject = BC.IdProject AND
	   dbo.fnGetToCompletionBudgetGeneration(A.IdProject, 'C') = BC.IdGeneration
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON ADDC.Idproject = WP.IdProject AND
	   ADDC.IdPhase = WP.IdPhase AND
	   ADDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	ADDC.YearMonth <= CASE WHEN BC.IsValidated = 1 THEN ISNULL(BC.YearMonthActualData, 190001)
							 ELSE @YearMonthOfPreviousMonth END	AND
	ADDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate

--all the records before the yearmonth actual data are comming from actual
--to_completion records are deleted from the extract
DELETE t
FROM @tempReforcast t
INNER JOIN BUDGET_TOCOMPLETION BT ON
	t.IdProject = BT.IdProject AND
	dbo.fnGetToCompletionBudgetGeneration(t.IdProject,'C') = BT.IdGeneration
WHERE t.YearMonth <= BT.YearMonthActualData

--------------------------------------------------------------------------------------------------------------------------------------------
-- delete all multiple keys from reforcast if any and overwrite with data from actual

DELETE t
FROM @tempReforcast t 
INNER JOIN @actualTemp a ON
	t.YearMonth 	= a.YearMonth AND
	t.IdProject 	= a.IdProject AND
	t.IdPhase 	= a.IdPhase AND
	t.IdWorkPackage = a.IdWorkPackage AND
	t.IdCostCenter 	= a.IdCostCenter


INSERT INTO @tempReforcast (IdProject, IdPhase,IdWorkPackage,
		   IdCostCenter, YearMonth, AccountNumber, IdAssociate,
		   Quantity, Value, [Date], ExtractCategoty)

SELECT 		 IdProject, IdPhase,IdWorkPackage,
		   IdCostCenter, YearMonth, AccountNumber, IdAssociate,
		   Quantity, Value, [Date], ExtractCategoty
FROM @actualTemp


SELECT 	P.Code as 			[Project Code],
	P.Name as 			[Project Name],	
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name 	as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	A.Name as 			[Employee Name],
	A.EmployeeNumber as 		[Employee Number],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	ExtractCategoty	as		[Extract Category],
	t.YearMonth/100 as 		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as 			[Quantity],
	t.Value as			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[Date]) as	[Validation Date],
	t.[Percent] as [Percent]
	
FROM @tempReforcast t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN Associates A
	ON t.IdAssociate = A.[Id]
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY t.ExtractCategoty, P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth


GO

--Drops the Procedure extExtractByFunctionRevisedData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractByFunctionRevisedData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractByFunctionRevisedData
GO

--exec extExtractByFunctionRevisedData 2008,-1,-1,-1,-1,-1,'L'

CREATE PROCEDURE extExtractByFunctionRevisedData
(
	@Year			INT,
	@IdRegion 		INT,
	@IdCountry 		INT,
	@IdInergyLocation 	INT,
	@IdFunction 		INT,
	@IdDepartment 		INT,
	@WPActiveStatus 	VARCHAR(1),
	@CostTypeCategory 	VARCHAR(1),
	@IdCurrencyAssociate	INT
)

AS

DECLARE @tempRevised table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	IdAssociate 	INT,
	Quantity 	INT,
	Value 		bigint,
	ValidationDate	SMALLDATETIME

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)


-- create temporary table #INCOME_COST_TYPES_CATEGORY to categorize cost types
create table #INCOME_COST_TYPES_CATEGORY(IdCostType int, CostTypeCategory varchar(1))

insert into #INCOME_COST_TYPES_CATEGORY (IdCostType, CostTypeCategory)
select Id, 'O' from BUDGET_COST_TYPES

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetHoursCostTypeID(), 'H'

insert into #INCOME_COST_TYPES_CATEGORY(IdCostType, CostTypeCategory)
select dbo.fnGetSalesCostTypeID(), 'S'


--GET ALL HOURS RECORDS
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, ROUND(SUM(BRD.HoursQty),0), ROUND(SUM(BRD.HoursVal),0),
	BR.ValidationDate
FROM 	BUDGET_REVISED_DETAIL BRD
INNER JOIN BUDGET_REVISED BR 
	ON BR.IdProject = BRD.IdProject AND
	   BR.IdGeneration = BRD.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BRD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BRD.IdCountry = GLA.IdCountry AND
	   BRD.IdAccountHours = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BRD.Idproject = WP.IdProject AND
	   BRD.IdPhase = WP.IdPhase AND
	   BRD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BR.IdGeneration = dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND
	(BRD.HoursQty IS NOT NULL OR BRD.HoursVal IS NOT NULL) AND
	BRD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, BR.ValidationDate


--GET ALL SALES RECORD
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, 0, ROUND(SUM(BRD.SalesVal),0), BR.ValidationDate
FROM 	BUDGET_REVISED_DETAIL BRD
INNER JOIN BUDGET_REVISED BR 
	ON BR.IdProject = BRD.IdProject AND
	   BR.IdGeneration = BRD.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BRD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BRD.IdCountry = GLA.IdCountry AND
	   BRD.IdAccountSales = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BRD.Idproject = WP.IdProject AND
	   BRD.IdPhase = WP.IdPhase AND
	   BRD.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BR.IdGeneration = dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND	
	BRD.SalesVal IS NOT NULL AND
	BRD.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate,BR.ValidationDate


--GET ALL OTHER COSTS
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT 	BRDC.IdProject, BRDC.IdPhase, BRDC.IdWorkPackage, BRDC.IdCostCenter,
	BRDC.YearMonth, GLA.Account, BRDC.IdAssociate, 0, ROUND(SUM(BRDC.CostVal),0), BR.ValidationDate

FROM 	BUDGET_REVISED_DETAIL_COSTS BRDC
INNER JOIN BUDGET_REVISED BR 
	ON BR.IdProject = BRDC.IdProject AND
	   BR.IdGeneration = BRDC.IdGeneration
INNER JOIN COST_CENTERS CC 
	ON BRDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON BRDC.IdCountry = GLA.IdCountry AND
	   BRDC.IdAccount = GLA.Id
INNER JOIN INERGY_LOCATIONS IL 
	ON CC.IdInergyLocation = IL.Id
INNER JOIN COUNTRIES C 
	ON IL.IdCountry = C.Id
INNER JOIN REGIONS R 
	ON C.IdRegion = R.Id
INNER JOIN DEPARTMENTS d 
	ON CC.IdDepartment = D.Id
INNER JOIN [FUNCTIONS] F 
	ON D.IdFunction = F.Id
INNER JOIN WORK_PACKAGES WP 
	ON BRDC.Idproject = WP.IdProject AND
	   BRDC.IdPhase = WP.IdPhase AND
	   BRDC.IdWorkPackage = WP.Id
INNER JOIN #INCOME_COST_TYPES_CATEGORY ictc
	ON GLA.IdCostType = ictc.IdCostType
WHERE 	BRDC.IdGeneration = dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND
	BRDC.CostVal IS NOT NULL AND
	BRDC.YearMonth/100 = @Year AND
	R.Id = CASE WHEN @IdRegion = -1 THEN R.Id ELSE @IdRegion END AND
	C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END AND
	IL.Id = CASE WHEN @IdInergyLocation = -1 THEN IL.Id ELSE @IdInergyLocation END AND
	F.Id = CASE WHEN @IdFunction = -1 THEN F.Id ELSE @IdFunction END AND
	D.Id = CASE WHEN @IdDepartment = -1 THEN D.Id ELSE @IdDepartment END AND	
	WP.IsActive = CASE	
			WHEN @WPActiveStatus = 'A' THEN 1
			WHEN @WPActiveStatus = 'I' THEN 0
			WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
		      END 
	AND
	ictc.CostTypeCategory = case when @CostTypeCategory = 'A' then ictc.CostTypeCategory else @CostTypeCategory end

GROUP BY BRDC.IdProject, BRDC.IdPhase, BRDC.IdWorkPackage, BRDC.IdCostCenter,
	BRDC.YearMonth, GLA.Account, BRDC.IdAssociate, BR.ValidationDate



SELECT 	P.Code as 					[Project Code],
	P.Name as 					[Project Name],
	PH.Code as 					[Phase Code],
	WP.Code as 					[WP Code],
	WP.Name as					[WP Name],
	WP.Rank as					[WP Rank],
	C.Name as 					[Country Name],
	IL.Name as 					[Inergy Location Name],
	CC.Code as 					[Cost Center Code],
	CC.Name as 					[Cost Center Name],
	D.Name as 					[Department Name],
	F.Name as 					[Function Name],
	A.Name as 					[Employee Name],
	A.EmployeeNumber as 				[Employee Number],
	CIT.Name as 					[Cost Type Name],
	t.AccountNumber as 				[GL Account Number],
	GL.Name as 					[GL Account Description],
	CAST('revised' AS VARCHAR(15)) as		[Extract Category],
	t.YearMonth/100 as				[Year],
	t.YearMonth%100 as 				[Month],
	t.Quantity as					[Quantity],
	t.Value as 					[Value],
	CUR.Code as 					[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth) AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[ValidationDate]) as	[Date Validation]
	
FROM @tempRevised t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN Associates A
	ON t.IdAssociate = A.[Id]
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth


GO

--Drops the Procedure extExtractProgramActualData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProgramActualData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProgramActualData
GO

--exec extExtractProgramActualData 165

CREATE PROCEDURE extExtractProgramActualData
(
	@IdProgram int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate int
)

AS

CREATE TABLE #ActualTemp
(
	ProjectCode 		varchar(10),
	ProjectName 		varchar(50),	
	PhaseCode 		varchar(3),
	WorkPackageCode 	varchar(3),
	WorkPackageName varchar(30),
	WorkPackageRank int,
	CountryName 		varchar(30),
	InergyLocationName 	varchar(30),
	CostCenterCode 		varchar(15),
	CostCenterName 		varchar(30),
	DepartmentName 		varchar(30),
	FunctionName 		varchar(30),
	EmployeeName 		varchar(50),
	EmployeeNumber 		varchar(15),
	CostTypeName 		varchar(50),
	GLAccountNumber 	varchar(20),
	GLAccountDescription 	varchar(30),
	ExtractCategoty		varchar(10),
	[Year] 			int,
	[Month] 		int,
	SumQuantity 		decimal(12,2),
	SumValue 		decimal(18,2),
	CurrencyCode 		varchar(3),
	ExchangeRate 		decimal(18,4),
	ValidationDate	varchar(10)
)


DECLARE ProgramActualCursor CURSOR FAST_FORWARD FOR
--GET PROJECTS FROM @IDPROGRAM
	SELECT Id
	FROM PROJECTS
	WHERE IdProgram = @IdProgram		
OPEN ProgramActualCursor
DECLARE @IdProject INT	

	FETCH NEXT FROM ProgramActualCursor INTO @IdProject
	WHILE @@FETCH_STATUS = 0
	BEGIN
		INSERT INTO #ActualTemp
		exec extExtractProjectActualData @IdProject, @WPActiveStatus,@IdCurrencyAssociate
		
		FETCH NEXT FROM ProgramActualCursor INTO @IdProject
	END
CLOSE ProgramActualCursor
DEALLOCATE ProgramActualCursor

SELECT ProjectCode as 		[Project Code],
	ProjectName as 		[Project Name],	
	PhaseCode as		[Phase Code],
	WorkPackageCode as 	[WP Code],
	WorkPackageName as	[WP Name],
	WorkPackageRank as	[WP Rank],
	CountryName as 		[Country Name],
	InergyLocationName as 	[Inergy Location Name],
	CostCenterCode as 	[Cost Center Code],
	CostCenterName as 	[Cost Center Name],
	DepartmentName as 	[Department Name],
	FunctionName as 	[Function Name],
	EmployeeName as 	[Employee Name],
	EmployeeNumber as 	[Employee Number],
	CostTypeName as 	[Cost Type Name],
	GLAccountNumber as 	[GL Account Number],
	GLAccountDescription	[GL Account Description],
	ExtractCategoty	as [Extract Category], 
	[Year] as 		[Year],
	[Month] as 		[Month],
	SumQuantity as 		[Quantity],
	SumValue as 		[Value],
	CurrencyCode as		[Currency],
	ExchangeRate as 	[Exchange Rate],
	ValidationDate	as	[Validation Date]
FROM #ActualTemp

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].extExtractProgramAnnualData') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProgramAnnualData
GO
create PROCEDURE extExtractProgramAnnualData
(
	@IdProgram int,
	@Year int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate int
)

AS

CREATE TABLE #AnnualTemp
(
	ProjectCode 		varchar(10),
	ProjectName 		varchar(50),	
	PhaseCode 		varchar(3),
	WorkPackageCode 	varchar(3),
	WorkPackageName varchar(30),
	WorkPackageRank int,
	CountryName 		varchar(30),
	InergyLocationName 	varchar(30),
	CostCenterCode 		varchar(15),
	CostCenterName 		varchar(30),
	DepartmentName 		varchar(30),
	FunctionName 		varchar(30),
	--EmployeeName 		varchar(50),
	--EmployeeNumber 		varchar(15),
	CostTypeName 		varchar(50),
	GLAccountNumber 	varchar(20),
	GLAccountDescription 	varchar(30),
	ExtractCategoty	varchar(50),
	[Year] 			int,
	[Month] 		int,
	SumQuantity 		decimal(12,2),
	SumValue 		decimal(18,2),
	CurrencyCode 		varchar(3),
	ExchangeRate 		decimal(18,4),
	ValidationDate	varchar(10)
)


DECLARE ProgramAnnualCursor CURSOR FAST_FORWARD FOR
--GET PROJECTS FROM @IDPROGRAM
	SELECT Id
	FROM PROJECTS
	WHERE IdProgram = @IdProgram		
OPEN ProgramAnnualCursor
DECLARE @IdProject INT	

	FETCH NEXT FROM ProgramAnnualCursor INTO @IdProject
	WHILE @@FETCH_STATUS = 0
	BEGIN
		INSERT INTO #AnnualTemp
		exec extExtractProjectAnnualData @IdProject, @Year, @WPActiveStatus,@IdCurrencyAssociate
		
		FETCH NEXT FROM ProgramAnnualCursor INTO @IdProject
	END
CLOSE ProgramAnnualCursor
DEALLOCATE ProgramAnnualCursor

SELECT ProjectCode as 		[Project Code],
	ProjectName as 		[Project Name],	
	PhaseCode as		[Phase Code],
	WorkPackageCode as 	[WP Code],
	WorkPackageName as	[WP Name],
	WorkPackageRank as	[WP Rank],
	CountryName as 		[Country Name],
	InergyLocationName as 	[Inergy Location Name],
	CostCenterCode as 	[Cost Center Code],
	CostCenterName as 	[Cost Center Name],
	DepartmentName as 	[Department Name],
	FunctionName as 	[Function Name],
	--EmployeeName as 	[Employee Name],
	--EmployeeNumber as 	[Employee Number],
	CostTypeName as 	[Cost Type Name],
	GLAccountNumber as 	[GL Account Number],
	GLAccountDescription	[GL Account Description],
	ExtractCategoty	as [Extract Category],
	[Year] as 		[Year],
	[Month] as 		[Month],
	SumQuantity as 		[Quantity],
	SumValue as 		[Value],
	CurrencyCode as		[Currency],
	ExchangeRate as 	[Exchange Rate],
	ValidationDate	as	[Validation Date]
FROM #AnnualTemp

GO

--Drops the Procedure extExtractProgramInitialData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProgramInitialData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProgramInitialData
GO

--exec extExtractProgramInitialData 165

CREATE PROCEDURE extExtractProgramInitialData
(
	@IdProgram int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate	INT
)

AS

CREATE TABLE #InitialTemp
(
	ProjectCode 		varchar(10),
	ProjectName 		varchar(50),	
	PhaseCode 		varchar(3),
	WorkPackageCode 	varchar(3),
	WorkPackageName varchar(30),
	WorkPackageRank int,
	CountryName 		varchar(30),
	InergyLocationName 	varchar(30),
	CostCenterCode 		varchar(15),
	CostCenterName 		varchar(30),
	DepartmentName 		varchar(30),
	FunctionName 		varchar(30),
	EmployeeName 		varchar(50),
	EmployeeNumber 		varchar(15),
	CostTypeName 		varchar(50),
	GLAccountNumber 	varchar(20),
	GLAccountDescription 	varchar(30),
	ExtractCategoty	varchar(10),
	[Year] 			int,
	[Month] 		int,
	SumQuantity 		int,
	SumValue 		bigint,
	CurrencyCode 		varchar(3),
	ExchangeRate 		decimal(18,4),
	ValidationDate	varchar(10)
)


DECLARE ProgramInitialCursor CURSOR FAST_FORWARD FOR
--GET PROJECTS FROM @IDPROGRAM
	SELECT Id
	FROM PROJECTS
	WHERE IdProgram = @IdProgram		
OPEN ProgramInitialCursor
DECLARE @IdProject INT	

	FETCH NEXT FROM ProgramInitialCursor INTO @IdProject
	WHILE @@FETCH_STATUS = 0
	BEGIN
		INSERT INTO #InitialTemp
		exec extExtractProjectInitialData @IdProject, @WPActiveStatus,@IdCurrencyAssociate
		
		FETCH NEXT FROM ProgramInitialCursor INTO @IdProject
	END
CLOSE ProgramInitialCursor
DEALLOCATE ProgramInitialCursor

SELECT ProjectCode as 		[Project Code],
	ProjectName as 		[Project Name],	
	PhaseCode as		[Phase Code],
	WorkPackageCode as 	[WP Code],
	WorkPackageName as	[WP Name],
	WorkPackageRank as	[WP Rank],
	CountryName as 		[Country Name],
	InergyLocationName as 	[Inergy Location Name],
	CostCenterCode as 	[Cost Center Code],
	CostCenterName as 	[Cost Center Name],
	DepartmentName as 	[Department Name],
	FunctionName as 	[Function Name],
	EmployeeName as 	[Employee Name],
	EmployeeNumber as 	[Employee Number],
	CostTypeName as 	[Cost Type Name],
	GLAccountNumber as 	[GL Account Number],
	GLAccountDescription as	[GL Account Description],
	ExtractCategoty	as [Extract Category],
	[Year] as 		[Year],
	[Month] as 		[Month],
	SumQuantity as 		[Quantity],
	SumValue as 		[Value],
	CurrencyCode as		[Currency],
	ExchangeRate as 	[Exchange Rate],
	ValidationDate	as	[Validation Date]
FROM #InitialTemp

GO

--Drops the Procedure extExtractProgramReforcastData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProgramReforcastData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProgramReforcastData
GO

-- exec extExtractProgramReforcastData 165
-- 	exec extExtractProjectReforcastData 276
CREATE PROCEDURE extExtractProgramReforcastData
(
	@IdProgram int,
	@IdGeneration int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate	INT
)

AS

CREATE TABLE #ReforcastTemp
(
	ProjectCode 		varchar(10),
	ProjectName 		varchar(50),	
	PhaseCode 		varchar(3),
	WorkPackageCode 	varchar(3),
	WorkPackageName varchar(30),
	WorkPackageRank int,
	CountryName 		varchar(30),
	InergyLocationName 	varchar(30),
	CostCenterCode 		varchar(15),
	CostCenterName 		varchar(30),
	DepartmentName 		varchar(30),
	FunctionName 		varchar(30),
	EmployeeName 		varchar(50),
	EmployeeNumber 		varchar(15),
	CostTypeName 		varchar(50),
	GLAccountNumber 	varchar(20),
	GLAccountDescription 	varchar(30),
	ExtractCategoty		varchar(13),
	[Year] 			int,
	[Month] 		int,
	SumQuantity 		decimal (12,2),
	SumValue 		decimal (21,2),
	CurrencyCode 		varchar(3),
	ExchangeRate 		decimal(18,4),
	ValidationDate	varchar(10),
	[Percent] decimal(18,2)
)


DECLARE ProgramCursor CURSOR FAST_FORWARD FOR
--GET PROJECTS FROM @IDPROGRAM
	SELECT Id
	FROM PROJECTS
	WHERE IdProgram = @IdProgram		
OPEN ProgramCursor
DECLARE @IdProject INT	

	FETCH NEXT FROM ProgramCursor INTO @IdProject
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		set @IdGeneration = 
		(
			select MAX(IdGeneration) 
			FROM BUDGET_TOCOMPLETION TABLOCKX
			WHERE 	IdProject = @IdProject AND
			IsValidated = 1
		)
		INSERT INTO #ReforcastTemp
		exec extExtractProjectReforcastData @IdProject, @IdGeneration, @WPActiveStatus,@IdCurrencyAssociate
		
		FETCH NEXT FROM ProgramCursor INTO @IdProject
	END
CLOSE ProgramCursor
DEALLOCATE ProgramCursor

SELECT 	ProjectCode as 		[Project Code],
	ProjectName as 		[Project Name],	
	PhaseCode as		[Phase Code],
	WorkPackageCode as 	[WP Code],
	WorkPackageName as	[WP Name],
	WorkPackageRank as	[WP Rank],
	CountryName as 		[Country Name],
	InergyLocationName as 	[Inergy Location Name],
	CostCenterCode as 	[Cost Center Code],
	CostCenterName as 	[Cost Center Name],
	DepartmentName as 	[Department Name],
	FunctionName as 	[Function Name],
	EmployeeName as 	[Employee Name],
	EmployeeNumber as 	[Employee Number],
	CostTypeName as 	[Cost Type Name],
	GLAccountNumber as 	[GL Account Number],
	GLAccountDescription as	[GL Account Description],
	ExtractCategoty	as [Extract Category],
	[Year] as 		[Year],
	[Month] as 		[Month],
	SumQuantity as 		[Quantity],
	SumValue as 		[Value],
	CurrencyCode as		[Currency],
	ExchangeRate as 	[Exchange Rate],
	ValidationDate	as	[Validation Date],
	[Percent]  as [Percent]
FROM #ReforcastTemp

GO

--Drops the Procedure extExtractProgramRevisedData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProgramRevisedData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProgramRevisedData
GO

--exec extExtractProgramRevisedData 165

CREATE PROCEDURE extExtractProgramRevisedData
(
	@IdProgram int,
	@IdGeneration int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate	INT
)

AS

CREATE TABLE #RevisedTemp
(
	ProjectCode 		varchar(10),
	ProjectName 		varchar(50),	
	PhaseCode 		varchar(3),
	WorkPackageCode 	varchar(3),
	WorkPackageName varchar(30),
	WorkPackageRank int,
	CountryName 		varchar(30),
	InergyLocationName 	varchar(30),
	CostCenterCode 		varchar(15),
	CostCenterName 		varchar(30),
	DepartmentName 		varchar(30),
	FunctionName 		varchar(30),
	EmployeeName 		varchar(50),
	EmployeeNumber 		varchar(15),
	CostTypeName 		varchar(50),
	GLAccountNumber 	varchar(20),
	GLAccountDescription 	varchar(30),
	ExtractCategoty		varchar(10),
	[Year] 			int,
	[Month] 		int,
	SumQuantity 		int,
	SumValue 		bigint,
	CurrencyCode 		varchar(3),
	ExchangeRate 		decimal(18,4),
	ValidationDate	varchar(10)
)


DECLARE ProgramRevisedCursor CURSOR FAST_FORWARD FOR
--GET PROJECTS FROM @IDPROGRAM
	SELECT Id
	FROM PROJECTS
	WHERE IdProgram = @IdProgram		
OPEN ProgramRevisedCursor
DECLARE @IdProject INT	

	FETCH NEXT FROM ProgramRevisedCursor INTO @IdProject
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @IdGeneration = 
		(
		select MAX(IdGeneration) 
		FROM BUDGET_REVISED TABLOCKX
		WHERE 	IdProject = @IdProject AND
			IsValidated = 1
		)
		INSERT INTO #RevisedTemp
		exec extExtractProjectRevisedData @IdProject, @IdGeneration, @WPActiveStatus,@IdCurrencyAssociate
		
		FETCH NEXT FROM ProgramRevisedCursor INTO @IdProject
	END
CLOSE ProgramRevisedCursor
DEALLOCATE ProgramRevisedCursor

SELECT ProjectCode as 		[Project Code],
	ProjectName as 		[Project Name],	
	PhaseCode as		[Phase Code],
	WorkPackageCode as 	[WP Code],
	WorkPackageName as	[WP Name],
	WorkPackageRank as	[WP Rank],
	CountryName as 		[Country Name],
	InergyLocationName as 	[Inergy Location Name],
	CostCenterCode as 	[Cost Center Code],
	CostCenterName as 	[Cost Center Name],
	DepartmentName as 	[Department Name],
	FunctionName as 	[Function Name],
	EmployeeName as 	[Employee Name],
	EmployeeNumber as 	[Employee Number],
	CostTypeName as 	[Cost Type Name],
	GLAccountNumber as 	[GL Account Number],
	GLAccountDescription as	[GL Account Description],
	ExtractCategoty		as [Extract Category],
	[Year] as 		[Year],
	[Month] as 		[Month],
	SumQuantity as 		[Quantity],
	SumValue as 		[Value],
	CurrencyCode as		[Currency],
	ExchangeRate as 	[Exchange Rate],
	ValidationDate	as	[Validation Date]
FROM #RevisedTemp

GO

--Drops the Procedure extExtractProjectActualData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProjectActualData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProjectActualData
GO


CREATE PROCEDURE extExtractProjectActualData
(
	@IdProject int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate int
)

AS

DECLARE @tempActual table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter 	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	IdAssociate 	int,
	Quantity 	decimal(12,2),
	Value 		decimal(18,2),
	ValidationDate smalldatetime

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)


--GET ALL HOURS RECORDS FROM ACTUAL DATA

INSERT INTO @tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, SUM(AD.HoursQty), SUM(AD.HoursVal), MAX(IMP.ImportDate)
FROM ACTUAL_DATA_DETAILS_HOURS AD
INNER JOIN IMPORTS IMP
	ON AD.IdImport = IMP.IdImport
INNER JOIN  ACTUAL_DATA A 
	ON	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC 
	ON	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON	AD.IdCountry = GLA.IdCountry AND
		AD.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP 
	ON	AD.Idproject = WP.IdProject AND
		AD.IdPhase = WP.IdPhase AND
		AD.IdWorkPackage = WP.Id
WHERE 	AD.IdProject = @IdProject and	
		WP.IsActive = CASE	WHEN @WPActiveStatus = 'A' THEN 1
							WHEN @WPActiveStatus = 'I' THEN 0
							WHEN @WPActiveStatus = 'L' THEN WP.IsActive END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, AD.DateImport

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO @tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, 0, SUM(AD.SalesVal), MAX(IMP.ImportDate)
FROM ACTUAL_DATA_DETAILS_SALES AD
INNER JOIN IMPORTS IMP
	ON AD.IdImport = IMP.IdImport
INNER JOIN ACTUAL_DATA A  ON
	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC ON
	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	AD.Idproject = WP.IdProject AND
	AD.IdPhase = WP.IdPhase AND
	AD.IdWorkPackage = WP.Id
WHERE 	AD.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, AD.DateImport

--GET ALL OTHER COSTS
INSERT INTO @tempActual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate,  Quantity, Value, ValidationDate)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate, 0, SUM(ADDC.CostVal), MAX(IMP.ImportDate)
FROM ACTUAL_DATA_DETAILS_COSTS ADDC
INNER JOIN IMPORTS IMP
	ON ADDC.IdImport = IMP.IdImport
INNER JOIN ACTUAL_DATA A  ON
	A.IdProject = ADDC.IdProject
INNER JOIN COST_CENTERS CC ON
	ADDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	ADDC.IdCountry = GLA.IdCountry AND
	ADDC.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	ADDC.Idproject = WP.IdProject AND
	ADDC.IdPhase = WP.IdPhase AND
	ADDC.IdWorkPackage = WP.Id
WHERE   ADDC.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate, ADDC.DateImport


SELECT 	P.Code as 			[Project Code],
	P.Name as 			[Project Name],
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as 			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	A.Name as 			[Employee Name],
	A.EmployeeNumber as 		[Employee Number],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	CAST('actual' AS VARCHAR(15)) as [Extract Category],
	t.YearMonth/100 as 		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as 			[Quantity],
	t.Value as			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[ValidationDate]) as [Validation Date]

	
FROM @tempActual t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN ASSOCIATES A
	ON t.IdAssociate = A.Id
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO


--Drops the Procedure extExtractProjectAnnualData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProjectAnnualData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProjectAnnualData
GO


CREATE PROCEDURE extExtractProjectAnnualData
(
	@IdProject int,
	@Year int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate int
)

AS

DECLARE @tempAnnual table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter 	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	Quantity 	decimal(12,2),
	Value 		decimal(18,2),
	ValidationDate smalldatetime

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber)
)


--GET ALL HOURS RECORDS FROM ACTUAL DATA

INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, ValidationDate)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, SUM(AD.HoursQty), SUM(AD.HoursVal), AD.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_HOURS AD
INNER JOIN  ANNUAL_BUDGET A ON
	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC ON
	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	AD.Idproject = WP.IdProject AND
	AD.IdPhase = WP.IdPhase AND
	AD.IdWorkPackage = WP.Id
WHERE 	AD.IdProject = @IdProject
		and AD.YearMonth/100 = @Year and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.DateImport

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, Quantity, Value, ValidationDate)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, 0, SUM(AD.SalesVal), AD.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_SALES AD
INNER JOIN ANNUAL_BUDGET A  ON
	A.IdProject = AD.IdProject
INNER JOIN COST_CENTERS CC ON
	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	AD.IdCountry = GLA.IdCountry AND
	AD.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	AD.Idproject = WP.IdProject AND
	AD.IdPhase = WP.IdPhase AND
	AD.IdWorkPackage = WP.Id
WHERE 	AD.IdProject = @IdProject
		and AD.YearMonth/100 = @Year and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.DateImport

--GET ALL OTHER COSTS
INSERT INTO @tempAnnual (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber,  Quantity, Value, ValidationDate)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, 0, SUM(ADDC.CostVal), ADDC.DateImport
FROM ANNUAL_BUDGET_DATA_DETAILS_COSTS ADDC
INNER JOIN ANNUAL_BUDGET A  ON
	A.IdProject = ADDC.IdProject
INNER JOIN COST_CENTERS CC ON
	ADDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	ADDC.IdCountry = GLA.IdCountry AND
	ADDC.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	ADDC.Idproject = WP.IdProject AND
	ADDC.IdPhase = WP.IdPhase AND
	ADDC.IdWorkPackage = WP.Id
WHERE   ADDC.IdProject = @IdProject
		and ADDC.YearMonth/100 = @Year and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.DateImport



SELECT 	P.Code as 			[Project Code],
	P.Name as 			[Project Name],
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as 			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	CAST('annual budget' AS VARCHAR(15)) as  [Extract Category],
	t.YearMonth/100 as 		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as 			[Quantity],
	t.Value as			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetAnnualExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[ValidationDate]) as [Validation Date]

	
FROM @tempAnnual t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO
--Drops the Procedure extExtractProjectInitialData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProjectInitialData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProjectInitialData
GO


CREATE PROCEDURE extExtractProjectInitialData
(
	@IdProject int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate	INT
)

AS

DECLARE @tempInitial table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter 	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	IdAssociate 	int,
	Quantity 	INT,
	Value 		BIGINT,
	ValidationDate	SMALLDATETIME

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)


--GET ALL HOURS RECORDS
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)
SELECT  BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, ROUND(SUM(BID.HoursQty),0), ROUND(SUM(BID.HoursVal),0), BI.ValidationDate
FROM BUDGET_INITIAL_DETAIL BID
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = BID.IdProject
INNER JOIN COST_CENTERS CC ON
	BID.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BID.IdCountry = GLA.IdCountry AND
	BID.IdAccountHours = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BID.IdProject = WP.IdProject AND
	BID.IdPhase = WP.IdPhase and
	BID.IdWorkPackage = WP.Id
WHERE (BID.HoursQty IS NOT NULL OR BID.HoursVal IS NOT NULL) AND
	BI.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, BI.ValidationDate


--GET ALL SALES RECORD
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate,Quantity, Value, ValidationDate)

SELECT  BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, 0, ROUND(SUM(BID.SalesVal),0), BI.ValidationDate
FROM 	BUDGET_INITIAL_DETAIL BID
INNER JOIN BUDGET_INITIAL BI ON
	BI.IdProject = BID.IdProject
INNER JOIN COST_CENTERS CC ON
	BID.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BID.IdCountry = GLA.IdCountry AND
	BID.IdAccountSales = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BID.IdProject = WP.IdProject AND
	BID.IdPhase = WP.IdPhase and
	BID.IdWorkPackage = WP.Id
WHERE	BID.SalesVal IS NOT NULL AND
	BI.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BID.IdProject, BID.IdPhase, BID.IdWorkPackage, BID.IdCostCenter,
	BID.YearMonth, GLA.Account, BID.IdAssociate, BI.ValidationDate


--GET ALL OTHER COSTS
INSERT INTO @tempInitial (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT 	BIDC.IdProject, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter,
	BIDC.YearMonth, GLA.Account, BIDC.IdAssociate,0, ROUND(SUM(BIDC.CostVal),0), BI.ValidationDate

FROM 	BUDGET_INITIAL_DETAIL_COSTS BIDC
INNER JOIN BUDGET_INITIAL BI ON
	BI.IdProject = BIDC.IdProject
INNER JOIN COST_CENTERS CC ON
	BIDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BIDC.IdCountry = GLA.IdCountry AND
	BIDC.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BIDC.IdProject = WP.IdProject AND
	BIDC.IdPhase = WP.IdPhase and
	BIDC.IdWorkPackage = WP.Id
WHERE   BIDC.CostVal IS NOT NULL AND
	BI.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BIDC.IdProject, BIDC.IdPhase, BIDC.IdWorkPackage, BIDC.IdCostCenter,
	BIDC.YearMonth, GLA.Account, BIDC.IdAssociate, BI.ValidationDate


SELECT 	P.Code as 			[Project Code],
	P.Name as			[Project Name],
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as 			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	A.Name as 			[Employee Name],
	A.EmployeeNumber as 		[Employee Number],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	CAST('initial' AS VARCHAR(15)) as [Extract Category],
	t.YearMonth/100 as 		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as			[Quantity],
	t.Value as 			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth) AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[ValidationDate]) as [Validation Date]
	
FROM @tempInitial t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN ASSOCIATES A
	ON t.IdAssociate = A.Id
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO


--Drops the Procedure extExtractProjectReforcastData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProjectReforcastData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProjectReforcastData
GO
-- exec extExtractProjectReforcastData 587
CREATE PROCEDURE extExtractProjectReforcastData
(
	@IdProject int,
	@IdGeneration int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate	INT

)

AS

DECLARE @tempReforcast table
(
	IdExtract 		INT  IDENTITY (1, 1) NOT NULL,
	IdProject 		INT,
	IdPhase 		INT,
	IdWorkPackage 		INT,
	IdCostCenter 		INT,
	YearMonth 		INT,
	AccountNumber 		varchar(20),
	IdAssociate 		INT,
	Quantity 		decimal(12,2),
	Value 			decimal(21,2),
	[Date] 			smalldatetime,
	[Percent]		decimal(18,2),
	ExtractCategoty		varchar(15)

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)

	----------Create YearMonth for the previous month taking into account the current month
	DECLARE @YearMonthOfPreviousMonth INT
	Set @YearMonthOfPreviousMonth = dbo.fnGetYearMonthOfPreviousMonth(getdate())


--GET ALL HOURS RECORDS
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, 
	SUM(ROUND(BCD.HoursQty,0)), 
	case when MAX(cast(BC.IsValidated as int))=1 then SUM(ROUND(BCD.HoursVal,0))
		 else SUM(dbo.fnGetValuedHours(BCD.IdCostCenter, ROUND(BCD.HoursQty,0), BCD.YearMonth)) end, 
	BC.ValidationDate , BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL BCD
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP ON
	BCD.Idproject = BP.IdProject AND
	BCD.IdGeneration = BP.IdGeneration AND
	BCD.IdPhase	= BP.IdPhase AND
	BCD.IdWorkPackage = BP.IdWorkPackage and
	BCD.IdAssociate = BP.IdAssociate
INNER JOIN BUDGET_TOCOMPLETION BC ON
	BC.IdProject = BCD.IdProject AND
	BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BCD.IdCountry = GLA.IdCountry AND
	BCD.IdAccountHours = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BCD.IdProject = WP.IdProject AND
	BCD.IdPhase = WP.IdPhase AND
	BCD.IdWorkPackage = WP.Id
	
WHERE 	BC.IdGeneration = @IdGeneration and
	(BCD.HoursQty IS NOT NULL OR BCD.HoursVal IS NOT NULL) AND
	BC.IdProject = @IdProject and	
	WP.IsActive = CASE WHEN @WPActiveStatus = 'A' THEN 1
					   WHEN @WPActiveStatus = 'I' THEN 0
					   WHEN @WPActiveStatus = 'L' THEN WP.IsActive END AND
	BCD.YearMonth > case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
						 else @YearMonthOfPreviousMonth end
GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account,BCD.IdAssociate, BC.ValidationDate, BP.[Percent]


--GET ALL SALES RECORD
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)

SELECT  BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, 0, SUM(ROUND(BCD.SalesVal,0)), BC.ValidationDate, BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL BCD
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP ON
	BCD.Idproject = BP.IdProject AND
	BCD.IdGeneration = BP.IdGeneration AND
	BCD.IdPhase	= BP.IdPhase AND
	BCD.IdWorkPackage = BP.IdWorkPackage and
	BCD.IdAssociate = BP.IdAssociate
INNER JOIN BUDGET_TOCOMPLETION BC  ON
	BC.IdProject = BCD.IdProject AND
	BC.IdGeneration = BCD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BCD.IdCountry = GLA.IdCountry AND
	BCD.IdAccountSales = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BCD.IdProject = WP.IdProject AND
	BCD.IdPhase = WP.IdPhase AND
	BCD.IdWorkPackage = WP.Id
WHERE 	BC.IdGeneration = @IdGeneration and 
	BCD.SalesVal IS NOT NULL AND
	BC.IdProject = @IdProject and	
	WP.IsActive = CASE WHEN @WPActiveStatus = 'A' THEN 1
					   WHEN @WPActiveStatus = 'I' THEN 0
					   WHEN @WPActiveStatus = 'L' THEN WP.IsActive END AND
	BCD.YearMonth > case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
						 else @YearMonthOfPreviousMonth end
GROUP BY BCD.IdProject, BCD.IdPhase, BCD.IdWorkPackage, BCD.IdCostCenter,
	BCD.YearMonth, GLA.Account, BCD.IdAssociate, BC.ValidationDate, BP.[Percent]


--GET ALL OTHER COSTS
INSERT INTO @tempReforcast (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], [Percent], ExtractCategoty)
SELECT 	BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, BCDC.IdAssociate, 0, SUM(ROUND(BCDC.CostVal,0)), BC.ValidationDate, BP.[Percent], 'to completion'
FROM 	BUDGET_TOCOMPLETION_DETAIL_COSTS BCDC
LEFT JOIN BUDGET_TOCOMPLETION_PROGRESS BP ON
	BCDC.Idproject = BP.IdProject AND
	BCDC.IdGeneration = BP.IdGeneration AND
	BCDC.IdPhase	= BP.IdPhase AND
	BCDC.IdWorkPackage = BP.IdWorkPackage and
	BCDC.IdAssociate = BP.IdAssociate
INNER JOIN  BUDGET_TOCOMPLETION BC ON
	BC.IdProject = BCDC.IdProject AND
	BC.IdGeneration = BCDC.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BCDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BCDC.IdCountry = GLA.IdCountry AND
	BCDC.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BCDC.IdProject = WP.IdProject AND
	BCDC.IdPhase = WP.IdPhase AND
	BCDC.IdWorkPackage = WP.Id
WHERE 	BCDC.IdGeneration = @IdGeneration and 
	BCDC.CostVal IS NOT NULL AND
	BC.IdProject = @IdProject and	
	WP.IsActive = CASE WHEN @WPActiveStatus = 'A' THEN 1
					   WHEN @WPActiveStatus = 'I' THEN 0
					   WHEN @WPActiveStatus = 'L' THEN WP.IsActive END AND
	BCDC.YearMonth > case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
						  else @YearMonthOfPreviousMonth end

GROUP BY BCDC.IdProject, BCDC.IdPhase, BCDC.IdWorkPackage, BCDC.IdCostCenter,
	BCDC.YearMonth, GLA.Account, BCDC.IdAssociate, BC.ValidationDate, BP.[Percent]


DECLARE @actualTemp table
(
	IdExtract 		INT  IDENTITY (1, 1) NOT NULL,
	IdProject 		INT,
	IdPhase 		INT,
	IdWorkPackage 		INT,
	IdCostCenter 		INT,
	YearMonth 		INT,
	AccountNumber 		varchar(20),
	IdAssociate 		INT,
	Quantity 		decimal (12,2),
	Value 			decimal (21,2),
	[Date] 			smalldatetime,
	ExtractCategoty		varchar(15)
 	PRIMARY KEY (YearMonth, IdProject,IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate, ExtractCategoty)
)

--GET ALL HOURS RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, SUM(AD.HoursQty), SUM(AD.HoursVal), MAX(IMP.ImportDate), 'actual'
FROM ACTUAL_DATA A
INNER JOIN ACTUAL_DATA_DETAILS_HOURS AD 
	ON	A.IdProject = AD.IdProject
INNER JOIN IMPORTS IMP
	ON  AD.IdImport = IMP.IdImport
INNER JOIN COST_CENTERS CC 
	ON	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON	AD.IdCountry = GLA.IdCountry AND
		AD.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON	A.IdProject = BC.IdProject AND
		@IdGeneration = BC.IdGeneration
INNER JOIN WORK_PACKAGES WP 
	ON	AD.IdProject = WP.IdProject AND
		AD.IdPhase = WP.IdPhase AND
		AD.IdWorkPackage = WP.id
WHERE 	AD.YearMonth <= case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
							 else @YearMonthOfPreviousMonth end	AND
	BC.IdProject = @IdProject and	
	WP.IsActive = CASE	WHEN @WPActiveStatus = 'A' THEN 1
					    WHEN @WPActiveStatus = 'I' THEN 0
					    WHEN @WPActiveStatus = 'L' THEN WP.IsActive END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, Ad.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, A.[Date] 

--GET ALL SALES RECORDS FROM ACTUAL DATA

INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)

SELECT  AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, 0, SUM(AD.SalesVal), MAX(IMP.ImportDate) , 'actual'
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_SALES AD 
	ON	A.IdProject = AD.IdProject
INNER JOIN IMPORTS IMP
	ON  AD.IdImport = IMP.IdImport
INNER JOIN COST_CENTERS CC 
	ON	AD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON	AD.IdCountry = GLA.IdCountry AND
		AD.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON	A.IdProject = BC.IdProject AND
		@IdGeneration = BC.IdGeneration
INNER JOIN WORK_PACKAGES WP 
	ON	AD.IdProject = WP.IdProject AND
		AD.IdPhase = WP.IdPhase AND
		AD.IdWorkPackage = WP.Id
WHERE 	AD.YearMonth <= case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
							 else @YearMonthOfPreviousMonth end	AND
	BC.IdProject = @IdProject and	
	WP.IsActive = CASE WHEN @WPActiveStatus = 'A' THEN 1
						WHEN @WPActiveStatus = 'I' THEN 0
						WHEN @WPActiveStatus = 'L' THEN WP.IsActive END 
GROUP BY AD.IdProject, AD.IdPhase, AD.IdWorkPackage, AD.IdCostCenter,
	AD.YearMonth, GLA.Account, AD.IdAssociate, A.[Date]

--GET ALL OTHER COSTS
INSERT INTO @actualTemp (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, [Date], ExtractCategoty)
SELECT ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate, 0, SUM(ADDC.CostVal), MAX(IMP.ImportDate), 'actual'
FROM ACTUAL_DATA A 
INNER JOIN ACTUAL_DATA_DETAILS_COSTS ADDC ON
	A.IdProject = ADDC.IdProject
INNER JOIN IMPORTS IMP
	ON  ADDC.IdImport = IMP.IdImport
INNER JOIN COST_CENTERS CC 
	ON  ADDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA 
	ON	ADDC.IdCountry = GLA.IdCountry AND
		ADDC.IdAccount = GLA.Id
INNER JOIN BUDGET_TOCOMPLETION BC 
	ON	A.IdProject = BC.IdProject AND
		@IdGeneration = BC.IdGeneration
INNER JOIN WORK_PACKAGES WP 
	ON	ADDC.IdProject = WP.IdProject AND
		ADDC.IdPhase = WP.IdPhase AND
		ADDC.IdWorkPackage = WP.Id
WHERE 	ADDC.YearMonth <= case when BC.IsValidated = 1 then ISNULL(BC.YearMonthActualData, 190001)
							 else @YearMonthOfPreviousMonth end	AND
	BC.IdProject = @IdProject	and	
	WP.IsActive = CASE	WHEN @WPActiveStatus = 'A' THEN 1
						WHEN @WPActiveStatus = 'I' THEN 0
						WHEN @WPActiveStatus = 'L' THEN WP.IsActive END 

GROUP BY ADDC.IdProject, ADDC.IdPhase, ADDC.IdWorkPackage, ADDC.IdCostCenter,
	ADDC.YearMonth, GLA.Account, ADDC.IdAssociate, A.[Date]

--all the records before the yearmonth actual data are comming from actual
--to_completion records are deleted from the extract
DELETE t
FROM @tempReforcast t
INNER JOIN BUDGET_TOCOMPLETION BT ON
	t.IdProject = BT.IdProject AND
	@IdGeneration = BT.IdGeneration
WHERE t.YearMonth <= BT.YearMonthActualData

--------------------------------------------------------------------------------------------------------------------------------------------
-- delete all multiple keys from reforcast if any and overwrite with data from actual

DELETE t
FROM @tempReforcast t 
INNER JOIN @actualTemp a 
ON	t.YearMonth 	= a.YearMonth AND
	t.IdProject 	= a.IdProject AND
	t.IdPhase 		= a.IdPhase AND
	t.IdWorkPackage = a.IdWorkPackage AND
	t.IdCostCenter 	= a.IdCostCenter



INSERT INTO @tempReforcast (IdProject, IdPhase,IdWorkPackage,
		   IdCostCenter, YearMonth, AccountNumber, IdAssociate,
		   Quantity, Value, [Date], ExtractCategoty)

SELECT 	IdProject, IdPhase,IdWorkPackage,
		IdCostCenter, YearMonth, AccountNumber, IdAssociate,
		Quantity, Value, [Date], ExtractCategoty
FROM @actualTemp



SELECT 	P.Code as 			[Project Code],
	P.Name as 			[Project Name],	
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name 	as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	A.Name as 			[Employee Name],
	A.EmployeeNumber as 		[Employee Number],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	ExtractCategoty	as		[Extract Category],
	t.YearMonth/100 as 		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as 			[Quantity],
	t.Value as			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth)AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[Date]) as	[Validation Date],
	t.[Percent] as [Percent]
FROM @tempReforcast t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN Associates A
	ON t.IdAssociate = A.[Id]
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY t.ExtractCategoty, P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO

--Drops the Procedure extExtractProjectRevisedData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractProjectRevisedData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractProjectRevisedData
GO

--exec extExtractProjectRevisedData 276

CREATE PROCEDURE extExtractProjectRevisedData
(
	@IdProject int,
	@IdGeneration int,
	@WPActiveStatus varchar(1),
	@IdCurrencyAssociate int
)

AS

DECLARE @tempRevised table
(
	IdExtract 	INT  IDENTITY (1, 1) NOT NULL,
	IdProject 	INT,
	IdPhase 	INT,
	IdWorkPackage 	INT,
	IdCostCenter	INT,
	YearMonth 	INT,
	AccountNumber 	varchar(20),
	IdAssociate 	INT,
	Quantity 	INT,
	Value 		BIGINT,
	ValidationDate	SMALLDATETIME

	PRIMARY KEY (YearMonth, IdProject, IdPhase, IdWorkPackage, IdCostCenter, AccountNumber, IdAssociate)
)


--GET ALL HOURS RECORDS
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, 
	ROUND(SUM(BRD.HoursQty),0),
	case when MAX(cast(BR.IsValidated as int))=1 then ROUND(SUM(BRD.HoursVal),0)
		 else ROUND(SUM(dbo.fnGetValuedHours(BRD.IdCostCenter, BRD.HoursQty, BRD.YearMonth)),0) end, 
	BR.ValidationDate
FROM 	BUDGET_REVISED_DETAIL BRD
INNER JOIN BUDGET_REVISED BR ON
	BR.IdProject = BRD.IdProject AND
	BR.IdGeneration = BRD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BRD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BRD.IdCountry = GLA.IdCountry AND
	BRD.IdAccountHours = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BRD.IdProject = WP.IdProject AND
	BRD.IdPhase = WP.IdPhase AND
	BRD.IdWorkPackage = WP.Id
WHERE 	BR.IdGeneration = @IdGeneration and --dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND
	(BRD.HoursQty IS NOT NULL OR BRD.HoursVal IS NOT NULL) AND
	BR.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, BR.ValidationDate


--GET ALL SALES RECORD
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT  BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, 0, ROUND(SUM(BRD.SalesVal),0), BR.ValidationDate
FROM 	BUDGET_REVISED_DETAIL BRD
INNER JOIN BUDGET_REVISED BR ON
	BR.IdProject = BRD.IdProject AND
	BR.IdGeneration = BRD.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BRD.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BRD.IdCountry = GLA.IdCountry AND
	BRD.IdAccountSales = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BRD.IdProject = WP.IdProject AND
	BRD.IdPhase = WP.IdPhase AND
	BRD.IdWorkPackage = WP.Id

WHERE 	BR.IdGeneration = @IdGeneration and--dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND	
	BRD.SalesVal IS NOT NULL AND
	BR.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BRD.IdProject, BRD.IdPhase, BRD.IdWorkPackage, BRD.IdCostCenter,
	BRD.YearMonth, GLA.Account, BRD.IdAssociate, BR.ValidationDate


--GET ALL OTHER COSTS
INSERT INTO @tempRevised (IdProject, IdPhase, IdWorkPackage, IdCostCenter,
		YearMonth, AccountNumber, IdAssociate, Quantity, Value, ValidationDate)

SELECT 	BRDC.IdProject, BRDC.IdPhase, BRDC.IdWorkPackage, BRDC.IdCostCenter,
	BRDC.YearMonth, GLA.Account, BRDC.IdAssociate, 0, ROUND(SUM(BRDC.CostVal),0), BR.ValidationDate

FROM 	BUDGET_REVISED_DETAIL_COSTS BRDC
INNER JOIN BUDGET_REVISED BR ON
	BR.IdProject = BRDC.IdProject AND
	BR.IdGeneration = BRDC.IdGeneration
INNER JOIN COST_CENTERS CC ON
	BRDC.IdCostCenter = CC.Id
INNER JOIN GL_ACCOUNTS GLA ON
	BRDC.IdCountry = GLA.IdCountry AND
	BRDC.IdAccount = GLA.Id
INNER JOIN WORK_PACKAGES WP ON
	BRDC.IdProject = WP.IdProject AND
	BRDC.IdPhase = WP.IdPhase AND
	BRDC.IdWorkPackage = WP.Id
WHERE 	BRDC.IdGeneration = @IdGeneration and--dbo.fnGetRevisedBudgetGeneration(BR.IdProject,'C') AND
	BRDC.CostVal IS NOT NULL AND
	BR.IdProject = @IdProject and	
	WP.IsActive = CASE	
					WHEN @WPActiveStatus = 'A' THEN 1
					WHEN @WPActiveStatus = 'I' THEN 0
					WHEN @WPActiveStatus = 'L' THEN WP.IsActive 
					END 
GROUP BY BRDC.IdProject, BRDC.IdPhase, BRDC.IdWorkPackage, BRDC.IdCostCenter,
	BRDC.YearMonth, GLA.Account, BRDC.IdAssociate, BR.ValidationDate



SELECT 	P.Code as 			[Project Code],
	P.Name as 			[Project Name],
	PH.Code as 			[Phase Code],
	WP.Code as 			[WP Code],
	WP.Name as			[WP Name],
	WP.Rank as			[WP Rank],
	C.Name as 			[Country Name],
	IL.Name as 			[Inergy Location Name],
	CC.Code as 			[Cost Center Code],
	CC.Name as 			[Cost Center Name],
	D.Name as 			[Department Name],
	F.Name as 			[Function Name],
	A.Name as 			[Employee Name],
	A.EmployeeNumber as 		[Employee Number],
	CIT.Name as 			[Cost Type Name],
	t.AccountNumber as 		[GL Account Number],
	GL.Name as 			[GL Account Description],
	CAST('revised' AS VARCHAR(15)) as [Extract Category],
	t.YearMonth/100 as		[Year],
	t.YearMonth%100 as 		[Month],
	t.Quantity as			[Quantity],
	t.Value as 			[Value],
	CUR.Code as 			[Currency],
	CAST(dbo.fnGetExchangeRate(@IdCurrencyAssociate,CUR.Id,t.YearMonth) AS DECIMAL(18,4)) AS [Exchange Rate],
	dbo.fnDate2String(t.[ValidationDate]) as	[Date Validation]
	
FROM @tempRevised t
INNER JOIN PROJECTS P
	ON P.Id = t.IdProject
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = t.IdProject AND
	   WP.IdPhase = t.IdPhase AND
	   WP.Id = t.IdWorkPackage
INNER JOIN PROJECT_PHASES PH
	ON PH.Id = t.IdPhase
INNER JOIN COST_CENTERS CC
	ON CC.Id = t.IdCostCenter
INNER JOIN INERGY_LOCATIONS IL
	ON IL.Id = CC.IdInergyLocation
INNER JOIN COUNTRIES C
	ON C.Id = IL.IdCountry
INNER JOIN DEPARTMENTS D
	ON D.Id = CC.IdDepartment
INNER JOIN FUNCTIONS F
	ON F.Id = D.IdFunction
INNER JOIN GL_ACCOUNTS GL
	ON GL.IdCountry = IL.IdCountry AND
	   GL.Account = AccountNumber
INNER JOIN COST_INCOME_TYPES CIT
	ON CIT.Id = GL.IdCostType
INNER JOIN CURRENCIES CUR
	ON CUR.Id = C.IdCurrency
INNER JOIN Associates A
	ON t.IdAssociate = A.[Id]
WHERE COALESCE(NULLIF(t.Quantity,0),NULLIF(t.Value,0)) IS NOT NULL
ORDER BY P.Code,  PH.Code, WP.Rank, CC.Code, CIT.Rank, t.YearMonth

GO

--Drops the Procedure extExtractTrackingData if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extExtractTrackingData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extExtractTrackingData
GO


create  PROCEDURE [dbo].extExtractTrackingData
@Year int,
@IdProgram int,
@IdProject int,
@IdRole int

as
if @IdProgram <= 0
  set @IdProgram = null

if @IdProject <= 0
   set @IdProject = null

select b. EmployeeNumber, b.Name, isnull(s.Name,'') as Role, isnull(c.Name,'') as ImpersonatedName, isnull(d.Name,'') as FunctionImpersonated,  isnull(p.Code,'') as ProjectCode, isnull(p.Name,'') as ProjectName,
k.ActionName as Action, isnull(cast(a.IdGeneration as varchar),'') as Version, a.LogDate as Date
from
TRACKING_ACTIVITY_LOG a
join Associates b on a.IdAssociate = b.ID
left join ROLES s on s.Id = a.IdRole
join TRACKING_ACTIONS k on a.IdAction = k.IdAction
left join Associates c on a.IdMemberImpersonated = c.Id
left join PROJECT_FUNCTIONS d on a.IdFunctionImpersonated = d.Id
left join PROJECTS p on a.IdProject = p.Id
where 
year(a.LogDate) = @Year
and p.IdProgram = case when @IdProgram is null then p.IdProgram else @IdProgram end
and p.Id = case when @IdProject is null then p.Id else @IdProject end
and isnull(a.IdRole,0) = case when @IdRole <= 0 then a.IdRole else @IdRole end
order by Logdate


go

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterCountries
GO

CREATE PROCEDURE extSelectExtractByFunctionFilterCountries
		@IdCountry INT
AS
		SELECT  C.Id			AS 'Id',
			C.Name			AS 'Name',
			C.IdRegion		AS 'IdRegion'
		FROM COUNTRIES AS C
		WHERE 	C.IdRegion IS NOT NULL AND -- select only INERGY countries 
			C.Id = CASE WHEN @IdCountry = -1 THEN C.Id ELSE @IdCountry END
		ORDER BY C.Rank

		

GO
--Drops the Procedure extSelectExtractByFunctionFilterCountriesForRegion if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterCountriesForRegion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterCountriesForRegion
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterCountriesForRegion
	@IdRegion AS INT --The Id of the desired region
AS
	IF @IdRegion = -1
		SELECT 	C.[Id]		AS 'Id',		
			C.[Name]	AS 'Name',
			C.IdRegion	AS 'IdRegion'		
		FROM COUNTRIES AS C(nolock)
		WHERE C.IdRegion is not null -- select only INERGY countries
		ORDER BY C.Rank
	ELSE
		SELECT 	C.[Id]		AS 'Id',		
			C.[Name]	AS 'Name',
			C.IdRegion	AS 'IdRegion'		
		FROM COUNTRIES AS C(nolock)	
		WHERE IdRegion = @IdRegion
		ORDER BY C.Rank
GO
--Drops the Procedure extSelectExtractByFunctionFilterDepartmentsForFunction if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterDepartmentsForFunction]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterDepartmentsForFunction
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterDepartmentsForFunction
	@IdFunction AS INT --The Id of the selected function
AS
	IF @IdFunction = -1
		SELECT 	D.[Id]		AS 'Id',		
			D.[Name]	AS 'Name',
			D.IdFunction	AS 'IdFunction'		
		FROM DEPARTMENTS AS D(nolock)
		ORDER BY D.[Rank]
	ELSE
		SELECT 	D.[Id]		AS 'Id',		
			D.[Name]	AS 'Name',
			D.IdFunction	AS 'IdFunction'					
		FROM DEPARTMENTS AS D(nolock)	
		WHERE IdFunction = @IdFunction
		ORDER BY D.[Rank]

GO
--Drops the Procedure extSelectExtractByFunctionFilterFunctionForDepartment if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterFunctionForDepartment]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterFunctionForDepartment
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterFunctionForDepartment
	@IdDepartment AS INT --The Id of the selected department
AS
	--If @Id has the value -1, it will return all FUNCTIONS
	IF @IdDepartment = -1
		SELECT 	F.[Id]		AS 'Id',		
			F.[Name]	AS 'Name'		
		FROM [FUNCTIONS] AS F(nolock)	
		LEFT JOIN DEPARTMENTS D
			ON F.[Id] = D.IdFunction
		GROUP BY F.[Id], F.[Name], F.Rank
		ORDER BY F.[Rank]
	ELSE
		SELECT 	F.[Id]		AS 'Id',		
			F.[Name]	AS 'Name'		
		FROM [FUNCTIONS] AS F(nolock)	
		LEFT JOIN DEPARTMENTS D
			ON F.ID = D.IdFunction 
		WHERE ISNULL(D.[Id],0) =@IdDepartment
		GROUP BY F.[Id], F.[Name], F.Rank
		ORDER BY F.[Rank]
GO
--Drops the Procedure extSelectExtractByFunctionFilterFunctions if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterFunctions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterFunctions
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterFunctions
	@Id AS INT 	--The Id of the  selected region
AS
	--If @Id has the value -1, it will return all Regions
	SELECT 	F.Id		AS 'Id',		
		F.Name		AS 'Name'		
	FROM [FUNCTIONS] AS F(nolock)	
	WHERE F.[Id] =CASE @Id
				WHEN -1 THEN F.[Id]
				ELSE @Id
				END	
	ORDER BY F.Rank
GO
--Drops the Procedure bgtInergyLocationFilterForCostCenter if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterInergyLocations]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterInergyLocations
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterInergyLocations
	@IdCountry		INT
AS
		SELECT  IL.Id			AS 'Id',
			IL.Name			AS 'Name',
			C.Id			AS 'IdCountry'
		FROM INERGY_LOCATIONS AS IL
		INNER JOIN COUNTRIES  C
			ON IL.IdCountry = C.[Id]
		WHERE 	IL.IdCountry = CASE WHEN @IdCountry = -1 THEN IL.IdCountry ELSE @IdCountry END
		ORDER BY IL.Rank

		
GO

--Drops the Procedure extSelectExtractByFunctionFilterRegions if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[extSelectExtractByFunctionFilterRegions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE extSelectExtractByFunctionFilterRegions
GO
CREATE PROCEDURE extSelectExtractByFunctionFilterRegions
	@Id AS INT 	--The Id of the  selected region
AS
	--If @Id has the value -1, it will return all Regions
	SELECT 	R.Id		AS 'Id',		
		R.Name		AS 'Name'		
	FROM REGIONS AS R(nolock)	
	WHERE R.Id =CASE @Id
				WHEN -1 THEN R.Id
				ELSE @Id
				END	
	ORDER BY R.Rank
GO
--Drops the Procedure fltCostCenterFilterCostCenters if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltCostCenterFilterCostCenters]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltCostCenterFilterCostCenters
GO
CREATE PROCEDURE fltCostCenterFilterCostCenters
	@IdCountry		INT,
	@IdInergyLocation	INT,
	@IdFunction		INT
AS
	SELECT DISTINCT CC.[Id]					AS 'Id',
			CC.[Name]				AS 'Name',
			CC.Code	+ ' - ' + CC.[Name]		AS 'Code',
			F.[Id]					AS 'IdFunction',
			F.Name					AS 'FunctionName',
			IL.[Id]					AS 'IdInergyLocation',
			IL.Name					AS 'InergyLocationName',
			C.[Id]					AS 'IdCountry'			
	FROM COST_CENTERS CC
	INNER JOIN DEPARTMENTS D
		ON CC.IdDepartment = D.[Id]
	INNER JOIN [FUNCTIONS] F
		ON D.IdFunction = F.[Id]
	INNER JOIN INERGY_LOCATIONS IL
		ON CC.IdInergyLocation = IL.[Id]
	INNER JOIN COUNTRIES C
		ON IL.IdCountry = C.[Id]
	WHERE 	IL.IdCountry = CASE WHEN @IdCountry = -1 THEN IL.IdCountry ELSE @IdCountry END AND
		CC.IdInergyLocation = CASE WHEN @IdInergyLocation = -1 THEN CC.IdInergyLocation ELSE @IdInergyLocation END AND
		D.IdFunction = CASE WHEN @IdFunction = -1 THEN D.IdFunction ELSE @IdFunction END AND
		CC.IsActive = 1
	ORDER BY Code

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltCostCenterFilterCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltCostCenterFilterCountries
GO

CREATE PROCEDURE fltCostCenterFilterCountries
		@IdCountry INT
AS
		SELECT  C.Id			AS 'Id',
			C.Name			AS 'Name'
		FROM COUNTRIES AS C
		WHERE 	C.IdRegion is not null AND -- select only INERGY countries 
			C.Id = case when @IdCountry = -1 then C.Id else @IdCountry end
		ORDER BY C.Rank

		

GO
--Drops the Procedure fltCostCenterFilterFunctions if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltCostCenterFilterFunctions]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltCostCenterFilterFunctions
GO
CREATE PROCEDURE fltCostCenterFilterFunctions	
AS
		SELECT  F.[Id]			AS 'Id',
			F.[Name]		AS 'Name',
			F.Rank			AS 'Rank'
		FROM [FUNCTIONS] F
		ORDER BY F.Rank
		
GO


--Drops the Procedure fltCostCenterFilterInergyLocations if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltCostCenterFilterInergyLocations]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltCostCenterFilterInergyLocations
GO
CREATE PROCEDURE fltCostCenterFilterInergyLocations
	@IdCountry		INT
AS
		SELECT  IL.Id			AS 'Id',
			IL.Name			AS 'Name',
			C.Id			AS 'IdCountry'
		FROM INERGY_LOCATIONS AS IL
		INNER JOIN COUNTRIES  C
			ON IL.IdCountry = C.[Id]
		WHERE 	IL.IdCountry = CASE WHEN @IdCountry = -1 THEN IL.IdCountry ELSE @IdCountry END
		ORDER BY IL.Rank

		
GO

--Drops the Procedure fltProjectSelectorOwners if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorOwners]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorOwners
GO

-- EXEC fltProjectSelectorOwners 78,-1,'A'

CREATE PROCEDURE fltProjectSelectorOwners
	@IdAssociate		AS INT,		--The Id of the Associate
	@IdOwner		AS INT,		--The Id of the Owner
	@ShowOnly		AS CHAR(1) 	--The option to filter projects after their state
AS
BEGIN

	DECLARE @IsBAOrTA BIT,
		@IsFM BIT,
		@IsKeyUser bit			
	
	--the Role of BA or TA has special access rights - they may see all the projects
	SET @IsBAOrTA = dbo.fnIsBAOrTA(@IdAssociate)
	SET @IsFM = dbo.fnIsFunctionalManager(@IdAssociate)
	set @IsKeyUser = dbo.fnIsKeyUser(@IdAssociate)
	
	IF @IsBAOrTA = 1 OR @IsFM = 1 or @IsKeyUser = 1
	BEGIN
		SELECT O.Id as OwnerId, O.Name as [Name], O.Rank
		FROM OWNERS O
		WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END)
		ORDER BY O.Rank

		RETURN
	END
	ELSE
	BEGIN
		CREATE TABLE #TempProjects
		(
			ProjectId		INT,
			ProjectName		VARCHAR(80),
			ProgramName 		VARCHAR(80),
			ProjectFunction 	VARCHAR(50),
			ProgramId 		INT,
			ProjectFunctionId 	INT,
			ProjectFunctionWPCodeSuffix VARCHAR(29),
			OwnerId 		INT,
			ProgramCode		VARCHAR(10),
			ProjectCode		VARCHAR(10),
			ActiveMembers		INT,
			TimingIntercoPercent	INT,
			IsInitialBudgetValidated BIT			
		)
		
		INSERT INTO #TempProjects
		EXEC dbo.fltProjectSelectorProjects @IdOwner, @IdAssociate, -1, @ShowOnly, 'C'
		
		SELECT DISTINCT O.Id as OwnerId, O.Name as [Name], O.Rank
		FROM #TempProjects t
		INNER JOIN OWNERS O (NOLOCK) ON
			t.OwnerID = O.Id
		WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END)
		ORDER BY O.Rank
	END

END

GO
--Drops the Procedure fltProjectSelectorPrograms if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorPrograms]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorPrograms
GO

-- EXEC fltProjectSelectorPrograms 78,-1,-1,'A'

CREATE PROCEDURE fltProjectSelectorPrograms
	@IdAssociate		AS INT,		--The Id of the Associate
	@IdOwner		AS INT,		--The Id of the Owner
	@IdProgram		AS INT,		--The Id of the Program
	@ShowOnly		AS CHAR(1) 	--The option to filter projects after their state
AS
BEGIN

	DECLARE @IsBAOrTA BIT,
		@IsFM BIT,
		@IsKeyUser bit	
	
	--the Role of BA or TA has special access rights - they may see all the projects
	SET @IsBAOrTA = dbo.fnIsBAOrTA(@IdAssociate)
	SET @IsFM = dbo.fnIsFunctionalManager(@IdAssociate)
	set @IsKeyUser = dbo.fnIsKeyUser(@IdAssociate)
	
	IF @IsBAOrTA = 1 OR @IsFM = 1 or @IsKeyUser = 1
	BEGIN
		SELECT 	[Id] AS ProgramId,
			[Name] + ' [' + Code + ']'AS [Name],
			IdOwner as OwnerId, PRG.Rank, -1 as ProjectId
		FROM	PROGRAMS PRG(nolock)
		WHERE	PRG.IdOwner = CASE WHEN @IdOwner = -1 THEN PRG.IdOwner ELSE @IdOwner END AND
			PRG.Id = CASE WHEN @IdProgram = -1 THEN PRG.Id ELSE @IdProgram END
		ORDER BY PRG.Rank

		RETURN
	END
	ELSE
	BEGIN
		CREATE TABLE #TempProjects
		(
			IdProject		INT,
			ProjectName		VARCHAR(80),
			ProgramName 		VARCHAR(80),
			ProjectFunction 	VARCHAR(50),
			ProgramId 		INT,
			ProjectFunctionId 	INT,
			ProjectFunctionWPCodeSuffix VARCHAR(29),
			OwnerId 		INT,
			ProgramCode		VARCHAR(10),
			ProjectCode		VARCHAR(10),
			ActiveMembers		INT,
			TimingIntercoPercent	INT,
			IsInitialBudgetValidated BIT
		)
		
		INSERT INTO #TempProjects
		EXEC fltProjectSelectorProjects @IdOwner, @IdAssociate, -1, @ShowOnly, 'C'
		
		SELECT DISTINCT PRG.Id AS ProgramId, PRG.Name + ' [' + Code + ']' as [Name], PRG.IdOwner as OwnerId, PRG.Rank, -1 as ProjectId 
		FROM #TempProjects t
		INNER JOIN PROGRAMS PRG (NOLOCK) ON
			t.ProgramID = PRG.Id
		WHERE (PRG.Id = CASE WHEN @IdProgram = -1 THEN PRG.Id ELSE @IdProgram END)
		ORDER BY PRG.Rank
	END

END
GO--Drops the Procedure fltProjectSelectorProjects if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorProjects]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorProjects
GO

-- exec fltProjectSelectorProjects -1,78,-1,'A','C'

CREATE PROCEDURE fltProjectSelectorProjects
	@IdOwner		AS INT,		--The Id of the Owner
	@IdAssociate		AS INT,		--The Id of the Associate
	@IdProgram		AS INT,		--The Id of the Program
	@ShowOnly		AS CHAR(1),	--The option to filter projects after their state
	@OrderBy 		AS CHAR(1)  --Order By option: 'C' - Project Code, 'N' - Project Name
AS
BEGIN

--If @IdOwner has the value -1, it will return all Projects
DECLARE @IsBAOrTA BIT,
	@IsFinancial BIT,
	@IsFM BIT,
	@IsKeyUser bit	

--the Role of BA or TA has special access rights - they may see all the projects
SET @IsBAOrTA = dbo.fnIsBAOrTA(@IdAssociate)
SET @IsFinancial = dbo.fnIsFinancial(@IdAssociate)
SET @IsFM = dbo.fnIsFunctionalManager(@IdAssociate)
set @IsKeyUser = dbo.fnIsKeyUser(@IdAssociate)

CREATE TABLE #TempProjects
(
	ProjectId			INT,
	ProjectName			VARCHAR(80),
	ProgramName 			VARCHAR(80),
	ProjectFunction 		VARCHAR(50),
	ProgramId 			INT,
	ProjectFunctionId 		INT,
	ProjectFunctionWPCodeSuffix	VARCHAR(29),
	OwnerId 			INT,
	ProgramCode			VARCHAR(10),
	ProjectCode			VARCHAR(10),
	ActiveMembers			INT DEFAULT 0,
	TimingIntercoPercent		INT DEFAULT 0,
	IsInitialBudgetValidated	BIT DEFAULT 0
)

	
IF (@IsBAOrTA = 1 OR @IsFM = 1  or @IsKeyUser = 1)
BEGIN
	INSERT INTO #TempProjects 
		([ProjectId], [ProjectName], ProgramName, ProjectFunction, ProgramId, 
		ProjectFunctionId, ProjectFunctionWPCodeSuffix, OwnerId, ProgramCode, ProjectCode)
	SELECT 	P.Id			AS 'ProjectId',
		(CASE WHEN @OrderBy = 'C' THEN P.Code + ' [' + P.Name + ']'
		else P.Name + ' [' + P.Code + ']' END) AS 'ProjectName',
		PR.Name			AS 'ProgramName',
		ISNULL(PF.Name, 'None') AS 'ProjectFunction',
		PR.Id			AS 'ProgramId',
		ISNULL(PF.Id, -1)	AS 'ProjectFunctionId',
		ISNULL(PF.WPCodeSuffixes, '')	AS 'ProjectFunctionWPCodeSuffix',
		O.Id			AS 'OwnerId',
		PR.Code			AS 'ProgramCode',
		P.Code			AS 'ProjectCode'
	FROM PROJECTS P(nolock)
	INNER JOIN PROGRAMS PR(nolock)
		ON P.IdProgram = PR.Id
	INNER JOIN OWNERS O(nolock)
		ON PR.IdOwner = O.Id
	LEFT JOIN PROJECT_CORE_TEAMS PCT (nolock)
		ON PCT.IdProject = P.Id AND
		   PCT.IdAssociate = @IdAssociate
	LEFT JOIN PROJECT_FUNCTIONS PF(nolock)
		ON PCT.IdFunction = PF.[Id]	
	WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END) and
	      (P.IdProgram = CASE WHEN @IdProgram =-1 THEN P.IdProgram ELSE @IdProgram END) and
	      (P.IsActive = CASE WHEN @ShowOnly = 'A' THEN 1
				WHEN @ShowOnly = 'I' THEN 0
				WHEN @ShowOnly = 'T' THEN P.IsActive END) 
END

IF (@IsFinancial = 1)
BEGIN
	DECLARE @IdCountryAssociate INT

	SELECT @IdCountryAssociate = IdCountry 
	FROM ASSOCIATES (nolock)
	WHERE Id = @IdAssociate

	INSERT INTO #TempProjects 
		([ProjectId], [ProjectName], ProgramName, ProjectFunction, ProgramId, 
		ProjectFunctionId, ProjectFunctionWPCodeSuffix, OwnerId, ProgramCode, ProjectCode)
	SELECT 	P.Id			AS 'ProjectId',
		(CASE WHEN @OrderBy = 'C' THEN P.Code + ' [' + P.Name + ']'
		else P.Name + ' [' + P.Code + ']' END) AS 'ProjectName',
		PR.Name			AS 'ProgramName',
		ISNULL(PF.Name, 'None') AS 'ProjectFunction',
		PR.Id			AS 'ProgramId',
		PF.Id			AS 'ProjectFunctionId',
		PF.WPCodeSuffixes	AS 'ProjectFunctionWPCodeSuffix',
		O.Id			AS 'OwnerId',
		PR.Code			AS 'ProgramCode',
		P.Code			AS 'ProjectCode'
	FROM PROJECTS AS P(nolock)
	INNER JOIN PROGRAMS PR(nolock)
		ON P.IdProgram = PR.Id
	INNER JOIN OWNERS O(nolock)
		ON PR.IdOwner = O.Id
	INNER JOIN PROJECT_CORE_TEAMS PCT(nolock)
		ON PCT.IdProject = P.Id AND
		   PCT.IdAssociate = @IdAssociate
	INNER JOIN PROJECT_FUNCTIONS PF(nolock)
		ON PCT.IdFunction = PF.[Id]
	WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END) and
	      (P.IdProgram = CASE WHEN @IdProgram =-1 THEN P.IdProgram ELSE @IdProgram END) and
	      (P.IsActive = CASE WHEN @ShowOnly = 'A' THEN 1
				WHEN @ShowOnly = 'I' THEN 0
				WHEN @ShowOnly = 'T' THEN P.IsActive END) AND
	PCT.IsActive = 1 --only when core team member is active

	UNION		

	SELECT DISTINCT
		P.Id			AS 'ProjectId',
		(CASE WHEN @OrderBy = 'C' THEN P.Code + ' [' + P.Name + ']'
		else P.Name + ' [' + P.Code + ']' END) AS 'ProjectName',
		PR.Name			AS 'ProgramName',
		'None'			AS 'ProjectFunction',
		PR.Id			AS 'ProgramId',
		-1			AS 'ProjectFunctionId',
		''			AS 'ProjectFunctionWPCodeSuffix',
		O.Id			AS 'OwnerId',
		PR.Code			AS 'ProgramCode',
		P.Code			AS 'ProjectCode'
	FROM PROJECTS AS P(nolock)
	INNER JOIN PROGRAMS PR(nolock)
		ON P.IdProgram = PR.Id
	INNER JOIN OWNERS O(nolock)
		ON PR.IdOwner = O.Id
	INNER JOIN PROJECTS_INTERCO_LAYOUT PIL 
		ON PIL.IdProject = P.[Id] AND 
		   PIL.IdCountry = @IdCountryAssociate
	WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END) and
	      (P.IdProgram = CASE WHEN @IdProgram =-1 THEN P.IdProgram ELSE @IdProgram END) and
	      (P.IsActive = CASE WHEN @ShowOnly = 'A' THEN 1
				WHEN @ShowOnly = 'I' THEN 0
				WHEN @ShowOnly = 'T' THEN P.IsActive END)
	
	--delete duplicates due to coincidence of project manager function in project and financial role
	DELETE FROM #TempProjects 
	WHERE ProjectId IN 
	(
		SELECT [ProjectId] FROM #TempProjects
		GROUP BY [ProjectId]
		HAVING COUNT(ProjectId) > 1
	) AND ProjectFunctionId = -1 
END

IF NOT ( (@IsBAOrTA = 1 OR @IsFM = 1) OR (@IsFinancial = 1) or (@IsKeyUser = 1) )
BEGIN
	-- the only difference in this case is that we use a INNER JOIN with PROJECT_CORE_TEAMS 
	-- to supress the projects in which the associate has no role at all
	INSERT INTO #TempProjects 
		([ProjectId], [ProjectName], ProgramName, ProjectFunction, ProgramId, 
		ProjectFunctionId, ProjectFunctionWPCodeSuffix, OwnerId, ProgramCode, ProjectCode)
	SELECT 	P.Id			AS 'ProjectId',
		(CASE WHEN @OrderBy = 'C' THEN P.Code + ' [' + P.Name + ']'
		else P.Name + ' [' + P.Code + ']' END) AS 'ProjectName',
		PR.Name			AS 'ProgramName',
		ISNULL(PF.Name, 'None') AS 'ProjectFunction',
		PR.Id			AS 'ProgramId',
		ISNULL(PF.Id, -1)	AS 'ProjectFunctionId',
		ISNULL(PF.WPCodeSuffixes, '')	AS 'ProjectFunctionWPCodeSuffix',
		O.Id			AS 'OwnerId',
		PR.Code			AS 'ProgramCode',
		P.Code			AS 'ProjectCode'
	FROM PROJECTS AS P(nolock)
	INNER JOIN PROGRAMS PR(nolock)
		ON P.IdProgram = PR.Id
	INNER JOIN OWNERS O(nolock)
		ON PR.IdOwner = O.Id
	INNER JOIN PROJECT_CORE_TEAMS PCT(nolock)
		ON P.Id = PCT.IdProject AND
		   PCT.IdAssociate = @IdAssociate
	INNER JOIN PROJECT_FUNCTIONS PF(nolock)
		ON PCT.IdFunction = PF.[Id]
	WHERE (O.Id = CASE WHEN @IdOwner = -1 THEN O.Id ELSE @IdOwner END) and
	      (P.IdProgram = CASE WHEN @IdProgram =-1 THEN P.IdProgram ELSE @IdProgram END) and
	      (P.IsActive = CASE WHEN @ShowOnly = 'A' THEN 1
				WHEN @ShowOnly = 'I' THEN 0
				WHEN @ShowOnly = 'T' THEN P.IsActive END) AND
	PCT.IsActive = 1  --only when core team member is active
	ORDER BY P.Code
END


UPDATE T
SET ActiveMembers = (SELECT COUNT(IdAssociate)
                     FROM PROJECT_CORE_TEAMS PCT
                     WHERE PCT.IdProject = T.ProjectId AND
 		           PCT.IsActive = 1)
FROM #TempProjects T


UPDATE T
SET TimingIntercoPercent = dbo.fnGetPercentageWpWithTimingAndInterco(T.ProjectId)
FROM #TempProjects T


UPDATE T
SET IsInitialBudgetValidated = BI.IsValidated
FROM #TempProjects T
INNER JOIN BUDGET_INITIAL BI
	ON BI.IdProject = T.ProjectId

	
	SELECT 
		[ProjectId]		AS 'ProjectId',
		[ProjectName]		AS 'ProjectName',
		ProgramName		AS 'ProgramName',
		ProjectFunction		AS 'ProjectFunction',
		ProgramId		AS 'ProgramId',
		ProjectFunctionId	AS 'ProjectFunctionId',
		ProjectFunctionWPCodeSuffix AS 'ProjectFunctionWPCodeSuffix',
		OwnerId			AS 'OwnerId',
		ProgramCode		AS 'ProgramCode',
		ProjectCode		AS 'ProjectCode',
		ActiveMembers		AS 'ActiveMembers',
		TimingIntercoPercent	AS 'TimingIntercoPercent',
		IsInitialBudgetValidated AS 'IsInitialBudgetValidated'	 
	FROM #TempProjects
	ORDER BY
		CASE WHEN @OrderBy = 'C' THEN ProjectCode END,
		CASE WHEN @OrderBy = 'N' THEN ProjectName END

END

GO


--Drops the Procedure fltProjectSelectorSelectProgram if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorSelectProgram]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorSelectProgram
GO

-- exec fltProjectSelectorSelectProgram 1

CREATE PROCEDURE fltProjectSelectorSelectProgram
	@IdProgram AS INT 	--The Id of the selected Project
AS

	--return IdOwner related to the project

	SELECT PRG.Id as IdProgram, PRG.IdOwner 
	FROM PROGRAMS PRG (nolock)
	WHERE PRG.Id = @IdProgram


GO

--Drops the Procedure fltProjectSelectorSelectProject if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorSelectProject]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorSelectProject
GO

CREATE PROCEDURE fltProjectSelectorSelectProject
	@IdProject AS INT 	--The Id of the selected Project
AS

	--return IdProgram and IdOwner related to the project

	SELECT PRJ.Id AS IdProject,
            PRJ.Name + ' [' + PRJ.Code + ']' AS ProjectName,
            PRJ.IdProgram, 
            PRG.IdOwner 
	FROM PROJECTS PRJ (nolock)
	INNER JOIN PROGRAMS PRG (nolock) 
		ON PRG.Id = PRJ.IdProgram
	WHERE PRJ.Id = @IdProject


GO
--Drops the Procedure fltProjectSelectorSelectProjectWithWPCodeSuffix if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fltProjectSelectorSelectProjectWithWPCodeSuffix]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE fltProjectSelectorSelectProjectWithWPCodeSuffix
GO

CREATE PROCEDURE fltProjectSelectorSelectProjectWithWPCodeSuffix
	@IdProject AS INT, 	--The Id of the selected Project
	@IdAssociate AS INT
AS

	--return IdProgram and IdOwner related to the project

	SELECT 
		PRJ.Id AS IdProject,
		PRJ.Name + ' [' + PRJ.Code + ']' AS ProjectName,
		PRJ.IdProgram, 
		PRG.IdOwner,
		ISNULL(PF.WPCodeSuffixes, '') AS 'ProjectFunctionWPCodeSuffix' 
	FROM PROJECTS PRJ (nolock)
	INNER JOIN PROGRAMS PRG (nolock) 
		ON PRG.Id = PRJ.IdProgram
	LEFT JOIN PROJECT_CORE_TEAMS PCT (nolock)
		ON PCT.IdProject = PRJ.Id AND
		   PCT.IdAssociate = @IdAssociate
	LEFT JOIN PROJECT_FUNCTIONS PF(nolock)
		ON PCT.IdFunction = PF.[Id]
	WHERE PRJ.Id = @IdProject

GO
--Drops the Function fnCheckAssociateIsBaOrTa if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnCheckAssociateIsBaOrTa]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnCheckAssociateIsBaOrTa]
GO
CREATE   FUNCTION fnCheckAssociateIsBaOrTa
	(@IdAssociate	INT)
RETURNS BIT
AS
BEGIN

	DECLARE @IsBAOrTA BIT,
		@IdRole INT

	SELECT @IdRole = IdRole
	FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @IdAssociate

	--the Role of BA or TA has special access rights - they may see all the projects
	SET @IsBAOrTA = CASE WHEN (@IdRole = 1 OR @IdRole = 2) THEN 1 ELSE 0 END

RETURN @IsBAOrTA
END

GO

--Drops the Function fnCheckAssociateIsPM if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnCheckAssociateIsPM]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnCheckAssociateIsPM]
GO
CREATE   FUNCTION fnCheckAssociateIsPM
(
	@IdAssociate	INT,
	@IdProject	INT
)
RETURNS BIT
AS
BEGIN

	DECLARE @IsPMProject BIT
	DECLARE @IsActive BIT
	
	SELECT @IsActive = PCT.IsActive
	FROM PROJECT_CORE_TEAMS PCT
	INNER JOIN PROJECT_FUNCTIONS PF
		ON PCT.IdFunction = PF.Id
	INNER JOIN PROJECTS P
		ON PCT.IdProject = P.Id
	WHERE PCT.IdProject = @IdProject AND
	      PCT.IdAssociate = @IdAssociate AND
	      PCT.IsActive = 1 AND
	      PF.Id = 1 AND
	      P.IsActive = 1

	SET @IsPMProject = CASE WHEN @IsActive IS NULL THEN 0 ELSE 1 END
	
	RETURN @IsPMProject

END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnCheckCostCenterExistenceInAllCategories]'))
	DROP FUNCTION fnCheckCostCenterExistenceInAllCategories
GO
CREATE FUNCTION fnCheckCostCenterExistenceInAllCategories
(
	@IdCostCenter INT
)
RETURNS INT
AS
BEGIN
	IF @IdCostCenter IS NULL
		RETURN 0

	IF EXISTS(
			SELECT TOP 1 BID.IdProject
			FROM BUDGET_INITIAL_DETAIL BID
			WHERE BID.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 BRD.IdProject
			FROM BUDGET_REVISED_DETAIL BRD
			WHERE BRD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1


	IF EXISTS(
			SELECT TOP 1 BCD.IdProject
			FROM BUDGET_TOCOMPLETION_DETAIL BCD
			WHERE BCD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1
	
	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_HOURS AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_SALES AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_COSTS AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_HOURS AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_SALES AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_COSTS AD
			WHERE AD.IdCostCenter = @IdCostCenter
		  )
		RETURN 1

	RETURN 0
	
END
GO

--Drops the Function fnCheckCountryDefaultAccounts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnCheckCountryDefaultAccounts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnCheckCountryDefaultAccounts]
GO
CREATE   FUNCTION fnCheckCountryDefaultAccounts
	(@IdCountry	INT)
RETURNS BIT
AS
BEGIN
	--Returns 1 if for the given country, all default accounts exist, 0 otherwise
	DECLARE @NoAccounts INT
	SET @NoAccounts = 0
	
	DECLARE CostIncomeCursor CURSOR FAST_FORWARD FOR
	SELECT 	DefaultAccount
	FROM	COST_INCOME_TYPES

	OPEN CostIncomeCursor
	DECLARE @DefaultAccountCostIncome VARCHAR(20)

	FETCH NEXT FROM CostIncomeCursor INTO @DefaultAccountCostIncome		
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF EXISTS
		(
			SELECT 	*
			FROM 	GL_ACCOUNTS
			WHERE	IdCountry = @IdCountry AND
				Account = @DefaultAccountCostIncome
		)
		BEGIN
			SET @NoAccounts = @NoAccounts + 1
		END
		FETCH NEXT FROM CostIncomeCursor INTO @DefaultAccountCostIncome
	END
	
	CLOSE CostIncomeCursor
	DEALLOCATE CostIncomeCursor

	IF (@NoAccounts = 7)
		RETURN 1
	RETURN 0
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnCheckInergyLocationExistenceInAllCategories]'))
	DROP FUNCTION fnCheckInergyLocationExistenceInAllCategories
GO
CREATE FUNCTION fnCheckInergyLocationExistenceInAllCategories
(
	@IdInergyLocation INT
)
RETURNS INT
AS
BEGIN
	IF @IdInergyLocation IS NULL
		RETURN 0

	IF EXISTS(
			SELECT TOP 1 BID.IdProject
			FROM BUDGET_INITIAL_DETAIL BID
			INNER JOIN COST_CENTERS CC
				ON BID.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 BRD.IdProject
			FROM BUDGET_REVISED_DETAIL BRD
			INNER JOIN COST_CENTERS CC
				ON BRD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1


	IF EXISTS(
			SELECT TOP 1 BCD.IdProject
			FROM BUDGET_TOCOMPLETION_DETAIL BCD
			INNER JOIN COST_CENTERS CC
				ON BCD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1
	
	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_HOURS AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_SALES AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ACTUAL_DATA_DETAILS_COSTS AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_HOURS AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_SALES AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

	IF EXISTS(
			SELECT TOP 1 AD.IdProject
			FROM ANNUAL_BUDGET_DATA_DETAILS_COSTS AD
			INNER JOIN COST_CENTERS CC
				ON AD.IdCostCenter = CC.Id
			WHERE CC.IdInergyLocation = @IdInergyLocation
		  )
		RETURN 1

RETURN 0
	
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnCheckUploadedActualDataForCC]'))
	DROP FUNCTION fnCheckUploadedActualDataForCC
GO

CREATE FUNCTION fnCheckUploadedActualDataForCC
	(@IdCostCenter	INT,
	@YearMonth	INT)
RETURNS BIT
AS

BEGIN

	DECLARE @IsUploadedActualDataForCC BIT
	SET @IsUploadedActualDataForCC = 0
	
	IF EXISTS
	(
		SELECT IL.IdImport
		FROM IMPORT_LOGS IL
		INNER JOIN IMPORT_SOURCES_COUNTRIES ISC
			ON IL.IdSource = ISC.IdImportSource 
		INNER JOIN INERGY_LOCATIONS ILC
			ON ISC.IdCountry = ILC.IdCountry 
		INNER JOIN COST_CENTERS CC
			ON ILC.Id = CC.IdInergyLocation 
		WHERE 	IL.Validation = 'G' AND
			IL.YearMonth = @YearMonth AND  
			CC.Id = @IdCostCenter 
	)
	BEGIN
		SET @IsUploadedActualDataForCC = 1
	END
	
	RETURN @IsUploadedActualDataForCC
END

GO

--Drops the Function fnCheckWPHasBudgetData if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnCheckWPHasBudgetData]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnCheckWPHasBudgetData]
GO
CREATE   FUNCTION fnCheckWPHasBudgetData
(	
	@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT
)
RETURNS  @ValidationTable table
(ValidationResult int, --has the value 0 if ok, negative value if not ok
 ErrorMessage     varchar(255) -- contains the string representing the error
) 
AS
BEGIN
	
	DECLARE @WPCode varchar(100),
	@errMessage varchar(255)
	
	
	IF EXISTS
	(
		SELECT TOP 1 IdWorkPackage 
		FROM BUDGET_INITIAL_DETAIL
		WHERE  	IdProject =@IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SELECT @WPCode = CODE + ' - '+ Name
		FROM WORK_PACKAGES
		WHERE IdProject = @IDProject AND
		IdPhase = @IdPhase AND
		Id = @IdWP

		set @errMessage = REPLACE('WP Code: ''%d'' cannot be removed because has budget information. Please refresh your information.', '%d', @WPCode)
		INSERT INTO @ValidationTable
		VALUES (-1, @errMessage)
		RETURN
	END
	
	IF EXISTS
	(
		SELECT TOP 1 IdWorkPackage 
		FROM BUDGET_REVISED_DETAIL
		WHERE  IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SELECT @WPCode = CODE + ' - '+ Name
		FROM WORK_PACKAGES
		WHERE IdProject = @IDProject AND
		IdPhase = @IdPhase AND
		Id = @IdWP

		set @errMessage = REPLACE('WP Code: ''%d'' cannot be removed because has budget information. Please refresh your information.', '%d', @WPCode)
		INSERT INTO @ValidationTable
		VALUES (-1, @errMessage)
		RETURN
	END
	
	IF EXISTS
	(
		SELECT TOP 1 IdWorkPackage 
		FROM BUDGET_TOCOMPLETION_DETAIL
		WHERE  IdProject = @IdProject AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP
	)
	BEGIN
		SELECT @WPCode = CODE + ' - '+ Name
		FROM WORK_PACKAGES
		WHERE IdProject = @IDProject AND
		IdPhase = @IdPhase AND
		Id = @IdWP

		set @errMessage = REPLACE('WP Code: ''%d'' cannot be removed because has budget information. Please refresh your information.', '%d', @WPCode)
		INSERT INTO @ValidationTable
		VALUES (-1, @errMessage)
		RETURN
	END
	
	RETURN

END

GO

--Drops the Function fnDate2String if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnDate2String]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnDate2String]
GO
CREATE   FUNCTION fnDate2String
	(@Date	SMALLDATETIME)
RETURNS VARCHAR(8)
AS
BEGIN

	DECLARE @StringDate VARCHAR(8)

	SET @StringDate = CAST(YEAR(@Date) AS VARCHAR(4)) +
	RIGHT('0'+CAST(MONTH(@Date) AS VARCHAR(2)),2)+
	RIGHT('0'+CAST(DAY(@Date) AS VARCHAR(2)),2)

RETURN @StringDate
END

GO

--Drops the Function fnGetAccountNumberAnnualBudget if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetAccountNumberAnnualBudget]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetAccountNumberAnnualBudget]
GO

-- Hours : 10000000 Hours
-- T&E : 10000001 T&E
-- Proto parts : 10000002 Proto parts
-- Proto Tooling : 10000003 Proto Tooling
-- Trials : 10000004 Trials
-- Other Expenses : 10000005 Other Expenses
-- Sales : 10000006 Sales

CREATE   FUNCTION fnGetAccountNumberAnnualBudget
	(@IdCostType INT)
RETURNS VARCHAR(20)
AS
BEGIN
	DECLARE @Account_Number	VARCHAR(20)
	DECLARE @BudgetCostName VARCHAR(50)



	SELECT @BudgetCostName = NAME 
	FROM BUDGET_COST_TYPES 
	WHERE ID = @IdCostType

	SELECT @Account_Number = DefaultAccount
	FROM COST_INCOME_TYPES
	WHERE Name = @BudgetCostName

    	RETURN @Account_Number
END

GO

--Drops the Function fnGetActualDetailIdAccount if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualDetailIdAccount]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualDetailIdAccount]
GO


CREATE   FUNCTION fnGetActualDetailIdAccount
(
	@IdCountry INT,
	@AccountNumber VARCHAR(20)	
)	
RETURNS INT
AS
BEGIN
    DECLARE @IDAccount	INT
	SELECT @IDAccount = [Id] 
	FROM [GL_ACCOUNTS] 
	WHERE 	IdCountry = @IdCountry AND
	        [Account]=@AccountNumber

    RETURN @IDAccount
END

GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualHoursQty]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualHoursQty]
GO

CREATE   FUNCTION fnGetActualHoursQty
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@YearMonth	INT)
RETURNS DECIMAL(18, 2)
AS
BEGIN
    DECLARE @HoursQty 	DECIMAL(18, 2)

	SELECT @HoursQty = SUM(ROUND(HoursQty,0)) 
	FROM ACTUAL_DATA_DETAILS_HOURS
	WHERE 	IdProject = @IdProject AND
		 	IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
		 	IdCostCenter = @IdCostCenter AND
			YearMonth = @YearMonth

    RETURN @HoursQty
END

GO


IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualHoursVal]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualHoursVal]
GO

CREATE   FUNCTION fnGetActualHoursVal
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@YearMonth	INT)
RETURNS DECIMAL(18, 2)
AS
BEGIN
    DECLARE @HoursVal 	DECIMAL(18, 2)

	SELECT @HoursVal = SUM(ROUND(HoursVal,0)) 
	FROM ACTUAL_DATA_DETAILS_HOURS
	WHERE 	IdProject = @IdProject AND
		 	IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
		 	IdCostCenter = @IdCostCenter AND
			YearMonth = @YearMonth

    RETURN @HoursVal
END

GO
--Drops the Function fnGetActualIdAndDefaultGLAccount if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualIdAndDefaultGLAccount]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualIdAndDefaultGLAccount]
GO


CREATE   FUNCTION fnGetActualIdAndDefaultGLAccount
(
	@AccountNumber VARCHAR(20),
	@IdImport INT
)	
RETURNS @tablevalues TABLE (IdAccount int, DefaultAccount varchar(20))

AS
BEGIN
	DECLARE @DefaultAccount varchar(20),
		@IdAccount INT,
		@CountryCode varchar(3),
		@IdCountry	INT

	SELECT @DefaultAccount = DefaultAccount
	FROM COST_INCOME_TYPES
	WHERE Name = @AccountNumber


	SELECT @CountryCode=  SUBSTRING(FileName,4,3)
	FROM IMPORTS 
	WHERE IdImport = @IdImport 
	
	SELECT @IdCountry = Id
	FROM COUNTRIES
	WHERE Code = @CountryCode
	
	SELECT @IdAccount = dbo.fnGetActualDetailCostsIdAccount(@IdCountry,@DefaultAccount)

	INSERT INTO @tablevalues (IdAccount, DefaultAccount) VALUES (@IdAccount, @DefaultAccount)
RETURN
END

GO

--Drops the Function fnGetActualOtherCosts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualOtherCosts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualOtherCosts]
GO

CREATE   FUNCTION fnGetActualOtherCosts
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@YearMonth	INT,
	@IdCostType	INT)
RETURNS DECIMAL(18, 2)
AS
BEGIN
    DECLARE @OtherCosts 	DECIMAL(18, 2)
	SET @OtherCosts = (SELECT SUM(ROUND(CostVal,0)) 
                        FROM ACTUAL_DATA_DETAILS_COSTS
                        WHERE 	IdProject = @IdProject
			AND 	IdPhase = @IdPhase
			AND 	IdWorkPackage = @IdWP
			AND 	IdCostCenter = @IdCostCenter
			AND	YearMonth = @YearMonth
			AND 	IdCostType = CASE WHEN @IdCostType = -1 THEN IdCostType ELSE @IdCostType END)
    RETURN @OtherCosts
END

GO


IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetActualSalesVal]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetActualSalesVal]
GO

CREATE   FUNCTION fnGetActualSalesVal
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@YearMonth	INT)
RETURNS DECIMAL(18,2)
AS
BEGIN
    DECLARE @SalesVal 	DECIMAL(18, 2)

	SELECT @SalesVal = SUM(ROUND(SalesVal,0)) 
	FROM ACTUAL_DATA_DETAILS_SALES
	WHERE 	IdProject = @IdProject AND
		 	IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
		 	IdCostCenter = @IdCostCenter AND
			YearMonth = @YearMonth

    RETURN @SalesVal
END

GO
--Drops the Function fnGetAnnualDefaultGLAccount if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetAnnualDefaultGLAccount]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetAnnualDefaultGLAccount]
GO


CREATE   FUNCTION fnGetAnnualDefaultGLAccount
(
	@AccountNumber VARCHAR(20)
)	
RETURNS INT

AS
BEGIN
	DECLARE @DefaultAccount varchar(20)
		
	SELECT @DefaultAccount = DefaultAccount
	FROM COST_INCOME_TYPES
	WHERE Name = @AccountNumber	


RETURN @DefaultAccount
END

GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetAnnualExchangeRate]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetAnnualExchangeRate]
GO

CREATE FUNCTION [dbo].[fnGetAnnualExchangeRate]
	(@CurrencyFrom	AS INT,	--The CurrencyFrom of the selected Exchange Rate
	@CurrencyTo	AS INT, --The CurrencyTo of the selected Exchange Rate
	@YearMonth	AS INT)	--The YearMonthTo of the selected Exchange Rate
RETURNS DECIMAL(18,6)
AS
BEGIN



DECLARE @IdCategoryFrom	 	AS INT,
	@IdCategoryTo	 	AS INT,
	@ExchangeRateFrom 	AS DECIMAL(18,6),
	@ExchangeRateTo	 	AS DECIMAL(18,6),
	@ConversionRate  	AS DECIMAL(18,6),
	@YearMonthFrom		AS INT,
	@YearMonthTo		AS INT,
	@Message			as varchar(200)
	
	
	--Category is 2, for Annual Budget, and month is January (by default)
	set @IdCategoryFrom = 2
	set @IdCategoryTo = 2
	set @YearMonthFrom = @YearMonth 
	set @YearMonthTo = @YearMonth 
	
	
	--This procedure returns the exchange rate for the selected Currency and YearMonth as follows: 
	--If @YearMonth is a positive integer then it will return for it, if it is -1 then the last exchange rate filled in the application for 
	--the selected Currency will be used
	--If 'Business Plan' is <> 0, then this is used
	--If all above are 0, then an exception is thrown
	
	if (@CurrencyFrom is NULL OR @CurrencyTo is NULL OR @YearMonth is NULL)
		return NULL
	
	IF (@CurrencyFrom = @CurrencyTo)
		RETURN 1
	
	IF (@CurrencyFrom <> dbo.fnGetEuroId())
	BEGIN

		SELECT 	@ExchangeRateFrom = ER.ConversionRate
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCategory = @IdCategoryFrom AND
			ER.IdCurrencyTo = @CurrencyFrom AND
			ER.YearMonth = @YearMonthFrom 
		
	END
	ELSE
	BEGIN
		SET @ExchangeRateFrom = 1
	END

	IF (@CurrencyTo <> dbo.fnGetEuroId())
	BEGIN

		SELECT 	@ExchangeRateTo = ER.ConversionRate
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCategory = @IdCategoryTo AND
			ER.IdCurrencyTo = @CurrencyTo AND
			ER.YearMonth = @YearMonthTo

	END
	ELSE
	BEGIN
		SET @ExchangeRateTo = 1
	END

	
	SET @ConversionRate = @ExchangeRateTo / @ExchangeRateFrom

	IF @ConversionRate IS NULL
		SET	@ConversionRate = (SELECT dbo.fnGetExchangeRate(@CurrencyFrom,@CurrencyTo,@YearMonth))
	
	RETURN @ConversionRate
END

GO

--Drops the Function fnGetAnnualIdGLAccount if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetAnnualIdGLAccount]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetAnnualIdGLAccount]
GO


CREATE   FUNCTION fnGetAnnualIdGLAccount
(
	@AccountNumber VARCHAR(20),
	@CountryCode VARCHAR(3)
)	
RETURNS INT

AS
BEGIN
	DECLARE @IdAccount INT,		
		@IdCountry	INT


	
	SELECT @IdCountry = Id
	FROM COUNTRIES
	WHERE Code = @CountryCode
	
	SELECT @IdAccount = ID
	FROM GL_ACCOUNTS
	WHERE IdCountry = @IdCountry AND
	Account = @AccountNumber


RETURN @IdAccount
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetBudgetCostType]'))
	DROP FUNCTION fnGetBudgetCostType
GO

CREATE FUNCTION fnGetBudgetCostType
(
	@IdCountry int,
	@AccountNumber nvarchar(10)
)
RETURNS INT
AS
BEGIN
	DECLARE @Return INT,
		@CostTypeID INT

	SELECT @CostTypeID = GL.IdCostType 
	FROM GL_ACCOUNTS GL 
	WHERE IdCountry = @IdCountry AND
	      GL.Account = @AccountNumber

	return @CostTypeID
	--PRINT @return
	
END
GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetBudgetOtherCostType]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetBudgetOtherCostType]
GO

CREATE  FUNCTION fnGetBudgetOtherCostType
(
	@CostType varchar(15)
)
RETURNS INT
AS
BEGIN
	DECLARE @CostTypeID INT		
	SELECT @CostTypeID = ID FROM BUDGET_COST_TYPES WHERE Name = @CostType

	return @CostTypeID
END
GO


--Drops the Function fnGetCountryCodeFromCostCenter if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetCountryCodeFromCostCenter]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetCountryCodeFromCostCenter]
GO

--select dbo.fnGetCountryCodeFromCostCenter(3)
CREATE   FUNCTION fnGetCountryCodeFromCostCenter
(
	@CCId int
)	
RETURNS varchar(3)
AS
BEGIN
	DECLARE @CountryCode varchar(3)
	
	SELECT @CountryCode = C.Code 
	FROM COST_CENTERS CC 
	INNER JOIN INERGY_LOCATIONS IL 
	        ON CC.IdInergyLocation = IL.ID 
	INNER JOIN COUNTRIES C 
		ON IL.IdCountry = C.Id     
	WHERE CC.Id = @CCId

	RETURN @CountryCode
END
GO
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetCurrencyFromCC]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetCurrencyFromCC]
GO

CREATE   FUNCTION fnGetCurrencyFromCC
(@IdCostCenter INT)
RETURNS
INT
AS
BEGIN

	DECLARE @IdCurrency INT
	SELECT @IdCurrency = C.IdCurrency
	FROM COST_CENTERS CC	
	INNER JOIN INERGY_LOCATIONS IL
		ON CC.IdInergyLocation = IL.Id
	INNER JOIN COUNTRIES C
		ON IL.IdCountry = C.Id
	where CC.Id = @IdCostCenter
	
	RETURN @IdCurrency

END

GO


--Drops the Function fnGetEndDevelopmentPhase if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetEndDevelopmentPhase]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetEndDevelopmentPhase]
GO

CREATE   FUNCTION fnGetEndDevelopmentPhase
	( 	
	@IdProject int 
	)
RETURNS INT
AS
BEGIN
	declare @MaxYearMonthExistingPhase int
	declare @MaxIdPhase int

	--select @MaxIdPhase = max(IdPhase) 
	--from WORK_PACKAGES 
	--where IdProject = @IdProject and 
	--      IdPhase between 3 and 7

	select @MaxYearMonthExistingPhase = MAX(EndYearMonth)
	from WORK_PACKAGES  
	where IdProject = @IdProject and 
              IdPhase between 3 and 7 

	RETURN @MaxYearMonthExistingPhase 
END
GO
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetEuroId]'))
	DROP FUNCTION fnGetEuroId
GO

CREATE FUNCTION fnGetEuroId()
RETURNS INT
AS
BEGIN
	DECLARE @Id INT

	SELECT @Id=Id FROM Currencies 
	WHERE Code = 'EUR'

	RETURN @Id
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetExchangeRate]'))
	DROP FUNCTION fnGetExchangeRate
GO

CREATE FUNCTION fnGetExchangeRate
	(@CurrencyFrom	AS INT,	--The CurrencyFrom of the selected Exchange Rate
	@CurrencyTo	AS INT, --The CurrencyTo of the selected Exchange Rate
	@YearMonth	AS INT)	--The Year and Month of the selected Exchange Rate
RETURNS DECIMAL(18,6)
AS
BEGIN



DECLARE @IdCategoryFrom	 	AS INT,
	@IdCategoryTo	 	AS INT,
	@ExchangeRateFrom 	AS DECIMAL(18,6),
	@ExchangeRateTo	 	AS DECIMAL(18,6),
	@ConversionRate  	AS DECIMAL(18,6),
	@YearMonthFrom		AS INT,
	@YearMonthTo		AS INT
	--This procedure returns the exchange rate for the selected Currency and YearMonth as follows: 
	--If @YearMonth is a positive integer then it will return for it, if it is -1 then the last exchange rate filled in the application for 
	--the selected Currency will be used
	--If Exchange Rate Category 'Actual' is <> 0, then this is used
	--If Exchange Rate Category 'Budget' is <> 0, then this is used
	--If 'Business Plan' is <> 0, then this is used
	--If all above are 0, then an exception is thrown
	
	if (@CurrencyFrom is NULL OR @CurrencyTo is NULL OR @YearMonth is NULL)
		return NULL
	
	IF (@CurrencyFrom = @CurrencyTo)
		RETURN 1
	
	IF (@CurrencyFrom <> dbo.fnGetEuroId())
	BEGIN
		SELECT 	@YearMonthFrom = MAX(ER.YearMonth)
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCurrencyTo = @CurrencyFrom AND
			ER.YearMonth <= @YearMonth

		IF (@YearMonthFrom IS NULL)
			RETURN NULL
		
		SELECT 	@IdCategoryFrom = MIN(ER.IdCategory)
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCurrencyTo = @CurrencyFrom AND
			ER.YearMonth = @YearMonthFrom

		SELECT 	@ExchangeRateFrom = ER.ConversionRate
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCategory = @IdCategoryFrom AND
			ER.IdCurrencyTo = @CurrencyFrom AND
			ER.YearMonth = @YearMonthFrom 
			
		if isnull(@ExchangeRateFrom,0) = 0
			return null

	END
	ELSE
	BEGIN
		SET @ExchangeRateFrom = 1
	END

	IF (@CurrencyTo <> dbo.fnGetEuroId())
	BEGIN
		SELECT 	@YearMonthTo = MAX(ER.YearMonth)
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCurrencyTo = @CurrencyTo AND
			ER.YearMonth <= @YearMonth

		IF (@YearMonthTo IS NULL)
			RETURN NULL
		
		SELECT 	@IdCategoryTo = MIN(ER.IdCategory)
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCurrencyTo = @CurrencyTo AND
			ER.YearMonth = @YearMonthTo

		SELECT 	@ExchangeRateTo = ER.ConversionRate
		FROM 	EXCHANGE_RATES ER(nolock)
		WHERE 	ER.IdCategory = @IdCategoryTo AND
			ER.IdCurrencyTo = @CurrencyTo AND
			ER.YearMonth = @YearMonthTo
			
		if @ExchangeRateTo is null
			return null

	END
	ELSE
	BEGIN
		SET @ExchangeRateTo = 1
	END

		
	SET @ConversionRate = @ExchangeRateTo / @ExchangeRateFrom
	RETURN @ConversionRate
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetFileNameFromPath]'))
	DROP FUNCTION fnGetFileNameFromPath
GO

--select dbo.fnGetFileNameFromPath('D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\XLSROM012007_123_2006_12_23.csv')
CREATE FUNCTION fnGetFileNameFromPath
(
	@FileName NVARCHAR(400)
)
RETURNS NVARCHAR(100)
AS
BEGIN
	DECLARE @RealFileName NVARCHAR(100)
	DECLARE @UNDERSCOREPOS INT

	--get only the name of the file from path
	DECLARE @FileNameNoPath NVARCHAR(100)
	DECLARE @FILEEXTENSION NVARCHAR(4)
		
/*
 * There is a new security feature in IE 8 that hides the real path of the selected file from JavaScript call (it returns c:\fakepath\).
 * This seems to only be activated for internet servers, not local intranet servers.
 * In this case the input parameter comes without the fakepath, so @FileNameNoPath = @FileName 
*/
	IF (CHARINDEX('\', @fileName) = 0)
	BEGIN
		SET @FileNameNoPath = @FileName
	END
	ELSE
	BEGIN
		SET @FileNameNoPath = RIGHT(@fileName,CHARINDEX('\',REVERSE(@FileName))-1)
	END

	SET @FILEEXTENSION = RIGHT(@FileNameNoPath,4)
	SET @RealFileName = LEFT(@FileNameNoPath,LEN(@FileNameNoPath) - CHARINDEX('_',REVERSE(@FileNameNoPath)))
	SET @UNDERSCOREPOS = CHARINDEX('_',@FileNameNoPath)
	
	IF (@UNDERSCOREPOS>0)
	BEGIN
		SET @RealFileName = SUBSTRING(@FileNameNoPath,0,@UNDERSCOREPOS) + @FILEEXTENSION
	END
	
	RETURN @RealFileName

END
GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetHourlyRate]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetHourlyRate]
GO

CREATE   FUNCTION fnGetHourlyRate
	( 	
	@IdCostCenter 	INT,
	@YearMonth	INT
	)
RETURNS DECIMAL(12,2)
AS
BEGIN
	DECLARE @HourlyRate		DECIMAL(12,2),
		@YMOfHourlyRate		INT

	SET 	@HourlyRate = NULL
	SET 	@YMOfHourlyRate = NULL

	SELECT 	@YMOfHourlyRate = MAX(YearMonth)
	FROM 	HOURLY_RATES AS HR
	INNER JOIN COST_CENTERS AS CC 
		ON HR.IdCostCenter = CC.[Id]
	INNER JOIN INERGY_LOCATIONS AS IL
		ON CC.IdInergyLocation = IL.[Id]
	INNER JOIN COUNTRIES AS C
		ON IL.IdCountry = C.[Id]
	WHERE 	HR.IdCostCenter = @IdCostCenter AND
		HR.YearMonth <= @YearMonth 

	--in case no hourly rate is found NULL is returned from this function
	IF (@YMOfHourlyRate IS NULL)
		RETURN NULL

	SELECT 	@HourlyRate = HourlyRate 
	FROM 	HOURLY_RATES AS HR
	INNER JOIN COST_CENTERS AS CC 
		ON HR.IdCostCenter = CC.[Id]
	INNER JOIN INERGY_LOCATIONS AS IL
		ON CC.IdInergyLocation = IL.[Id]
	INNER JOIN COUNTRIES AS C
		ON IL.IdCountry = C.[Id]
	WHERE 	HR.IdCostCenter = @IdCostCenter AND 
		HR.YearMonth = @YMOfHourlyRate

	RETURN @HourlyRate
END
GO

--Drops the Function fnGetHoursCostTypeID if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetHoursCostTypeID]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetHoursCostTypeID]
GO


CREATE   FUNCTION fnGetHoursCostTypeID
()	
RETURNS INT
AS
BEGIN 
    RETURN 6
END

GO


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetIdSourceFromFileName]'))
	DROP FUNCTION fnGetIdSourceFromFileName
GO

CREATE FUNCTION fnGetIdSourceFromFileName
(
@filename nvarchar(400)
)
RETURNS INT
AS
BEGIN
-- 	DECLARE @filename nvarchar(400)
-- 	SET  @filename= 'D\\WORK_1\OTHROM082009_10_2007_12_12.csv'
	DECLARE @IdSource INT
	DECLARE @UNDERSCOREPOS INT
	DECLARE @POINTPOS INT
	DECLARE @SLASHPOS INT
	DECLARE @FILENOPATH nvarchar(400)
	
	set @IDSOURCE = -1

	--take only the file name...no path
	SET @SLASHPOS = CHARINDEX('\',REVERSE(@filename))
	SET @FILENOPATH = SUBSTRING(@filename,LEN(@filename)-@SLASHPOS+2,@SLASHPOS-1)	
	IF (LEN(@FILENOPATH)>0)
	BEGIN
		SET @UNDERSCOREPOS = CHARINDEX('_',@FILENOPATH)
		SET @POINTPOS = CHARINDEX('_',@FILENOPATH,@UNDERSCOREPOS+1)
	
	
		--if no more _ then search for point from extension
		IF(@POINTPOS<=0)
		BEGIN
			SET @POINTPOS = CHARINDEX('.',@FILENOPATH)
-- 			PRINT @POINTPOS
		END
	
		IF (@UNDERSCOREPOS>0 AND @POINTPOS>0)
		BEGIN
			SET @IDSOURCE = SUBSTRING(@FILENOPATH,@UNDERSCOREPOS+1,@POINTPOS-@UNDERSCOREPOS-1)
		END
		
	END
	--ELSE
-- 	PRINT @IDSOURCE
	RETURN @IDSOURCE

END
GO


--Drops the Function fnGetInitialOtherCosts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetInitialOtherCosts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetInitialOtherCosts]
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO

CREATE   FUNCTION fnGetInitialOtherCosts
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@IdAssociate	INT,
	@YearMonth	INT)
RETURNS DECIMAL(19, 4)
AS
BEGIN
    DECLARE @OtherCosts 	DECIMAL(19, 4)
	SET @OtherCosts = (SELECT SUM(CostVal) 
                        FROM BUDGET_INITIAL_DETAIL_COSTS
                        WHERE IdProject = @IdProject
				AND IdPhase = @IdPhase
				AND IdWorkPackage = @IdWP
				AND IdCostCenter = @IdCostCenter
				AND IdAssociate = @IdAssociate
				AND YearMonth = @YearMonth)
    RETURN @OtherCosts
END

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--Drops the Function fnGetMonthIndex if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetMonthIndex]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetMonthIndex]
GO
CREATE   FUNCTION fnGetMonthIndex
	(@CurrentYM	INT, --the ym whose index is calculated
	@StartYM	INT, --the start ym
	@EndYM		INT) --the end ym
RETURNS INT
AS
BEGIN
	IF (@CurrentYM < @StartYM OR @CurrentYM > @EndYM)
	BEGIN
		RETURN -1
	END

	DECLARE 
	@EndYear		SMALLINT,	
	@EndMonth		SMALLINT,
	@StartMonth		SMALLINT,
	@StartYear		SMALLINT,
	@CurrentDate		INT,
	@Index			INT

	SET @Index = 1
	SET @StartYear = @StartYM / 100
	SET @StartMonth = @StartYM % 100
	SET @EndYear = @EndYM / 100
	SET @EndMonth = @EndYM% 100
	
	WHILE ((@StartYear < @EndYear) OR (@StartYear = @EndYear AND @StartMonth <= @EndMonth))
	BEGIN
		SET @CurrentDate = @StartYear * 100 + @StartMonth

		IF (@CurrentDate = @CurrentYM)
		BEGIN
			RETURN @Index
		END

		IF(@StartMonth = 12)
		BEGIN
			SET @StartYear = @StartYear + 1
			SET @StartMonth = 1
		END
		ELSE
		BEGIN
			SET @StartMonth = @StartMonth + 1
		END
		SET @Index = @Index + 1
	END

	RETURN -1
END
GO

--Drops the Function fnGetNormalizedDevelopmentPhase if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetNormalizedDevelopmentPhase]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetNormalizedDevelopmentPhase]
GO

CREATE   FUNCTION fnGetNormalizedDevelopmentPhase
	( 	
	@IdProject int,
	@IdPhase int,
	@YearImport int,
	@StartYearMonth int,
	@EndYearMonth int,
	@Type char --'S' for StartDevelopmentPhase, 'E' for EndDevelopmentPhase
	)
RETURNS INT
AS
BEGIN
	declare @StartDevelopmentPhaseYM int,
		@EndDevelopmentPhaseYM int,
		@Result int


	if (@IdPhase = 2)
	begin
		if (@StartYearMonth is null) and (@EndYearMonth is null)
			begin 
				set @StartDevelopmentPhaseYM  = @YearImport*100 + 1 /*start of phase 1 is january of the import year*/
				set @EndDevelopmentPhaseYM    = ISNULL(dbo.fnGetStartDevelopmentPhase(@IdProject), @YearImport*100 + 12) /*end of phase 1 is start of phase 2 or end of import year*/
				if (@EndDevelopmentPhaseYM > @YearImport*100 + 12) or (@EndDevelopmentPhaseYM < @YearImport*100 + 1)
				begin
					set @EndDevelopmentPhaseYM = @YearImport*100 + 12  /* if end of development phase is before or after the current year that means the phase 1 will be between january and december current year */
				end
				else
					/* end of development phase is in the current year */
					if (@EndDevelopmentPhaseYM % 100 <= 12) and (@EndDevelopmentPhaseYM % 100 <> 1) and (dbo.fnGetStartDevelopmentPhase(@IdProject) is not null) 
					begin
						set @EndDevelopmentPhaseYM = @EndDevelopmentPhaseYM - 1 
					end
			end
		else 
			begin 
				set @StartDevelopmentPhaseYM  = isnull(@StartYearMonth,@YearImport*100+1)
				set @EndDevelopmentPhaseYM    = isnull(@EndYearMonth,@YearImport*100+12)
			end
	end

else

	if (@IdPhase = 8)
	begin
		if (@StartYearMonth is null) and (@EndYearMonth is null)
		begin 
			set @StartDevelopmentPhaseYM  = ISNULL(dbo.fnGetEndDevelopmentPhase(@IdProject), @YearImport*100 + 1) /*start of phase 7 is the end of phase 6 or ianuary of the import year*/
			set @EndDevelopmentPhaseYM    = @YearImport*100+12 /*end of phase 7 is the end of import year*/
			if (@StartDevelopmentPhaseYM > @EndDevelopmentPhaseYM) 
				set @StartDevelopmentPhaseYM = @YearImport*100 + 1 /*if end of development phase is after the curent year that means the phase 7 will be between january and december current year */
			else
				if (@StartDevelopmentPhaseYM % 100 < 12 and dbo.fnGetEndDevelopmentPhase(@IdProject) is not null)
					set @StartDevelopmentPhaseYM = @StartDevelopmentPhaseYM + 1 	
		end
		else 
		begin 
			set @StartDevelopmentPhaseYM  = isnull(@StartYearMonth,@YearImport*100+1)
			set @EndDevelopmentPhaseYM    = isnull(@EndYearMonth,@YearImport*100+12)
		end
	end
	
else

	begin
		select @StartDevelopmentPhaseYM = ISNULL(dbo.fnGetStartDevelopmentPhase(@IdProject), @YearImport*100 + 1)
		select @EndDevelopmentPhaseYM = ISNULL(dbo.fnGetEndDevelopmentPhase(@IdProject), @YearImport*100 + 12)
	end


	set @Result = 
		CASE
			when @Type = N'S' then @StartDevelopmentPhaseYM
			when @Type = N'E' then @EndDevelopmentPhaseYM
			else null
		END	
	
	return @Result 
END
GO

--Drops the Function fnGetNullAssociateId if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetNullAssociateId]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetNullAssociateId]
GO
CREATE   FUNCTION fnGetNullAssociateId
	(@CountryCode	VARCHAR(3))

RETURNS INT
AS
BEGIN
	DECLARE @NullAssociateId int

	SELECT @NullAssociateId = A.Id
	FROM ASSOCIATES A
	INNER JOIN COUNTRIES C
		ON A.IdCountry = C.Id
	WHERE C.Code = @CountryCode
	AND UPPER(A.InergyLogin) = UPPER(@CountryCode) + '\NULL'
	
	RETURN @NullAssociateId
END
GO
 IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetPercentageWpWithTimingAndInterco]'))
	DROP FUNCTION fnGetPercentageWpWithTimingAndInterco
GO

CREATE FUNCTION fnGetPercentageWpWithTimingAndInterco
	( @IdProject INT )

RETURNS INT
AS

BEGIN

DECLARE @ActiveWPs 			INT,
	@ActiveWPsWithTimingInterco 	INT,
	@TimingIntercoPercent 		INT --Percentage of the active WPs that have the Timing & Interco completed
	
	
	SELECT @ActiveWPs = COUNT(*)
	FROM WORK_PACKAGES 
	WHERE IdProject = @IdProject AND 
	      IsActive = 1

	IF (@ActiveWPs = 0)
	RETURN 0

	SELECT @ActiveWPsWithTimingInterco = COUNT(*) 
	FROM WORK_PACKAGES WP
	INNER JOIN 
		(
			SELECT DISTINCT IdProject, IdPhase, IdWorkPackage
			FROM PROJECTS_INTERCO 
			WHERE IdProject = @IdProject
		) P_I
		ON WP.Id = P_I.IdWorkPackage 
		AND WP.IdProject = P_I.IdProject 
		AND WP.IdPhase = P_I.IdPhase
	WHERE WP.IdProject = @IdProject
	AND WP.IsActive = 1
	AND (WP.StartYearMonth IS NOT NULL AND WP.EndYearMonth IS NOT NULL)

	SET @TimingIntercoPercent = round((cast(@ActiveWPsWithTimingInterco as decimal(18,2))/@ActiveWPs)*100 ,0)

	RETURN @TimingIntercoPercent

END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetRevisedBudgetGeneration]'))
	DROP FUNCTION fnGetRevisedBudgetGeneration
GO

CREATE FUNCTION fnGetRevisedBudgetGeneration
	(@IdProject	INT,
	@Type		CHAR(1))	--The YearMonth to validate
RETURNS INT
AS
BEGIN
	DECLARE @IdGeneration	INT
	--InProgress version of budget
	If (@Type = 'N')
	BEGIN
		SELECT @IdGeneration = MAX(IdGeneration)
		FROM BUDGET_REVISED
		WHERE 	IdProject = @IdProject
		AND 	IsValidated=0
	END
	--Released or previous budget
	IF (@Type = 'C' OR @Type = 'P')
	BEGIN
		--Get Released budget generation
		SELECT @IdGeneration = MAX(IdGeneration)
		FROM BUDGET_REVISED
		WHERE 	IdProject = @IdProject
		AND 	IsValidated = 1
		--If previous budget is needed and if the current generation exists
		IF (@Type = 'P' AND @IdGeneration IS NOT NULL)
		BEGIN
			--If Released generation is strictly positive, previous generation is the Released one minus one
			IF (@IdGeneration > 1)
			BEGIN
				SET @IdGeneration = @IdGeneration - 1
			END
			--Else, no previous generation exists
			ELSE
			BEGIN
				SET @IdGeneration = NULL
			END
		END
	END
	RETURN @IdGeneration
END
GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetRevisedBudgetHoursQty]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetRevisedBudgetHoursQty]
GO

CREATE   FUNCTION fnGetRevisedBudgetHoursQty
	(@IdProject	INT,
	@IdGeneration	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@IdAssociate	INT)
RETURNS INT
AS
BEGIN
    DECLARE @HoursQty 	INT

	SELECT @HoursQty = SUM(HoursQty)
	FROM BUDGET_REVISED_DETAIL
	WHERE 	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
		 	IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
		 	IdCostCenter = @IdCostCenter AND
			IdAssociate = case when @IdAssociate = -1 then IdAssociate else @IdAssociate end

    RETURN @HoursQty
END

GO


IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetRevisedBudgetHoursVal]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetRevisedBudgetHoursVal]
GO

CREATE   FUNCTION fnGetRevisedBudgetHoursVal
	(@IdProject				INT,
	@IdGeneration			INT,
	@IdPhase				INT,
	@IdWP					INT,
	@IdCostCenter			INT,
	@IdAssociate			INT,
	@UseHourlyRates			BIT,
	@IsAssociateCurrency	BIT,
	@AssociateCurrency		INT)
RETURNS DECIMAL(18,4)
AS
BEGIN
    DECLARE @HoursVal 	DECIMAL(18,4)

	if (@UseHourlyRates = 0)
	BEGIN
		SELECT @HoursVal = 	SUM(CASE WHEN @IsAssociateCurrency = 1 THEN	dbo.fnGetExchangeRate(dbo.fnGetCurrencyFromCC(IdCostCenter), @AssociateCurrency, YearMonth) ELSE 1 END 
								* HoursVal)
		FROM BUDGET_REVISED_DETAIL BRD
		WHERE 	IdProject = @IdProject AND
				IdGeneration = @IdGeneration AND
			 	IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
			 	IdCostCenter = @IdCostCenter AND
				IdAssociate = case when @IdAssociate = -1 then IdAssociate else @IdAssociate end
	END
	ELSE
	BEGIN
		SELECT @HoursVal = SUM(CASE WHEN @IsAssociateCurrency = 1 THEN dbo.fnGetExchangeRate(dbo.fnGetCurrencyFromCC(IdCostCenter), @AssociateCurrency, YearMonth) ELSE 1 END *
								dbo.fnGetValuedHours(IdCostCenter, HoursQty, YearMonth))
		FROM BUDGET_REVISED_DETAIL
		WHERE 	IdProject = @IdProject AND
				IdGeneration = @IdGeneration AND
			 	IdPhase = @IdPhase AND
				IdWorkPackage = @IdWP AND
			 	IdCostCenter = @IdCostCenter AND
				IdAssociate = case when @IdAssociate = -1 then IdAssociate else @IdAssociate end	
	END

    RETURN @HoursVal
END

GO


--Drops the Function fnGetRevisedBudgetOtherCosts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetRevisedBudgetOtherCosts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetRevisedBudgetOtherCosts]
GO

CREATE   FUNCTION fnGetRevisedBudgetOtherCosts
	(@IdProject				INT,
	 @IdGeneration			INT,
	 @IdPhase				INT,
	 @IdWP					INT,
	 @IdCostCenter			INT,
	 @IdAssociate			INT,
	 @IsAssociateCurrency   BIT,
	 @AssociateCurrency	    INT)
RETURNS DECIMAL(19, 4)
AS
BEGIN
    DECLARE @OtherCosts DECIMAL(19, 4)

	SELECT @OtherCosts = SUM(CASE WHEN @IsAssociateCurrency = 1 THEN dbo.fnGetExchangeRate(dbo.fnGetCurrencyFromCC(IdCostCenter), @AssociateCurrency, YearMonth) ELSE 1 END *
							CostVal) 
    FROM BUDGET_REVISED_DETAIL_COSTS
    WHERE 	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = CASE WHEN @IdAssociate=-1 THEN IdAssociate ELSE @IdAssociate END

    RETURN @OtherCosts
END
GO



--Drops the Function fnGetRevisedBudgetSales if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetRevisedBudgetSales]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetRevisedBudgetSales]
GO

CREATE   FUNCTION fnGetRevisedBudgetSales
	(@IdProject				INT,
	 @IdGeneration			INT,
	 @IdPhase				INT,
	 @IdWP					INT,
	 @IdCostCenter			INT,
	 @IdAssociate			INT,
	 @IsAssociateCurrency   BIT,
	 @AssociateCurrency	    INT)
RETURNS DECIMAL(18, 4)
AS
BEGIN
    DECLARE @SalesVal DECIMAL(18, 4)

	SELECT @SalesVal = SUM(CASE WHEN @IsAssociateCurrency = 1 THEN	dbo.fnGetExchangeRate(dbo.fnGetCurrencyFromCC(IdCostCenter), @AssociateCurrency, YearMonth) ELSE 1 END *
							SalesVal) 
    FROM BUDGET_REVISED_DETAIL
    WHERE 	IdProject = @IdProject AND
			IdGeneration = @IdGeneration AND
			IdPhase = @IdPhase AND
			IdWorkPackage = @IdWP AND
			IdCostCenter = @IdCostCenter AND
			IdAssociate = CASE 	WHEN @IdAssociate = -1 THEN IdAssociate ELSE @IdAssociate END

    RETURN @SalesVal
END
GO



--Drops the Function fnGetSalesCostTypeID if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetSalesCostTypeID]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetSalesCostTypeID]
GO


CREATE   FUNCTION fnGetSalesCostTypeID
()	
RETURNS INT
AS
BEGIN 
    RETURN 7
END

GO


--Drops the Function fnGetSplittedValue if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetSplittedValue]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetSplittedValue]
GO
CREATE  FUNCTION fnGetSplittedValue
	(@TotalValue	BIGINT,
	@Date		INT,
	@StartYearMonth	INT,
	@EndYearMonth	INT)
RETURNS BIGINT
AS
BEGIN
	--Return null if total value is null
	IF ((@TotalValue IS NULL) OR (@TotalValue = 0))
	BEGIN
		RETURN @TotalValue
	END

	DECLARE @StartYear INT
	DECLARE @StartMonth INT
	DECLARE @EndYear INT
	DECLARE @EndMonth INT
	DECLARE @NoMonths INT
	DECLARE @CurrentMonthIndex INT 	--the index if the ym given by date between startyearmonth and endyearmonth
					-- (e.g. if start = 200006, end = 200010, then 200006 has index = 1, 200010 has
					-- index = 5, 200008 has index = 3 etc.)

	SET @CurrentMonthIndex = dbo.fnGetMonthIndex(@Date, @StartYearMonth, @EndYearMonth)

	IF (@CurrentMonthIndex = -1)
	BEGIN
		RETURN NULL
	END

	--Calculate the start year, start month, end year, end month
	SET @StartYear = @StartYearMonth / 100
	SET @StartMonth = @StartYearMonth % 100
	SET @EndYear = @EndYearMonth / 100
	SET @EndMonth = @EndYearMonth % 100

	DECLARE @StartDate DATETIME
	DECLARE @EndDate DATETIME
	
	--Convert the given yearmonths to dates
	SET @StartDate = CAST(CAST(@StartYear AS CHAR(4)) + '-' + CAST(@StartMonth AS VARCHAR(2)) + '-1' AS DATETIME)
	SET @EndDate = CAST(CAST(@EndYear AS CHAR(4)) + '-' + CAST(@EndMonth AS VARCHAR(2)) + '-1' AS DATETIME)

	--Get the number of months in the period
	SET @NoMonths = DATEDIFF(m, @StartDate, @EndDate) + 1

	DECLARE @SplittedValue BIGINT
	DECLARE @TotalValueDecimal DECIMAL(18, 4)
	SET @TotalValueDecimal = @TotalValue
	--Rounded value calculation
	SET @SplittedValue = ROUND(@TotalValueDecimal / @NoMonths, 0)

	IF (@SplittedValue = 0)
	BEGIN
		IF (@CurrentMonthIndex < @NoMonths)
		BEGIN
			RETURN 0
		END
		ELSE
		BEGIN
			RETURN @TotalValue
		END
	END	
	ELSE
	BEGIN
		--The number of full months for which, if we add in each month @SplittedValue, we do not get an amount
		--greater than the total (@TotalValue / @SplittedValue)
		DECLARE @NoMonthsTotalReached BIGINT
		SET @NoMonthsTotalReached = @TotalValue / @SplittedValue
	
		IF (@CurrentMonthIndex = @NoMonthsTotalReached + 1)
		BEGIN
			RETURN @TotalValue % @SplittedValue
		END
		IF (@CurrentMonthIndex > @NoMonthsTotalReached + 1)
		BEGIN
			RETURN 0
		END 
	
		IF (@CurrentMonthIndex < @NoMonths)  
		BEGIN
			IF (@CurrentMonthIndex <= @NoMonthsTotalReached)
			BEGIN
				RETURN @SplittedValue
			END
		END
		ELSE
		BEGIN
-- 			IF (@CurrentMonthIndex = @NoMonthsTotalReached)
-- 			BEGIN
				RETURN @TotalValue - @SplittedValue * (@NoMonths - 1) 
-- 			END
		END
	END

	--Normally, the function should have returned by this point
	RETURN 0
	
END

GO


--Drops the Function fnGetStartDevelopmentPhase if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetStartDevelopmentPhase]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetStartDevelopmentPhase]
GO

CREATE   FUNCTION fnGetStartDevelopmentPhase
	( 	
	@IdProject int 
	)
RETURNS INT
AS
BEGIN
	declare @MinYearMonthExistingPhase int
	declare @MinIdPhase int

	--select @MinIdPhase = min(IdPhase) 
	--from WORK_PACKAGES 
	--where IdProject = @IdProject and 
	--      IdPhase between 3 and 7

	select @MinYearMonthExistingPhase = min(StartYearMonth)
	from WORK_PACKAGES  
	where IdProject = @IdProject and
	      IdPhase between 3 and 7

	RETURN @MinYearMonthExistingPhase 
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetToCompletionBudgetGeneration]'))
	DROP FUNCTION fnGetToCompletionBudgetGeneration
GO

CREATE FUNCTION fnGetToCompletionBudgetGeneration
	(@IdProject	INT,
	@Type		CHAR(1))	--The YearMonth to validate
RETURNS INT
AS
BEGIN
	DECLARE @IdGeneration	INT
	--InProgress version of budget
	If (@Type = 'N')
	BEGIN
		SELECT @IdGeneration = MAX(IdGeneration)
		FROM BUDGET_TOCOMPLETION
		WHERE 	IdProject = @IdProject
		AND 	IsValidated=0
	END
	--Released or previous budget
	IF (@Type = 'C' OR @Type = 'P')
	BEGIN
		--Get Released budget generation
		SELECT @IdGeneration = MAX(IdGeneration)
		FROM BUDGET_TOCOMPLETION
		WHERE 	IdProject = @IdProject
		AND 	IsValidated = 1
		--If previous budget is needed and if the Released generation exists
		IF (@Type = 'P' AND @IdGeneration IS NOT NULL)
		BEGIN
			--If Released generation is strictly positive, previous generation is the Released one minus one
			IF (@IdGeneration > 1)
			BEGIN
				SET @IdGeneration = @IdGeneration - 1
			END
			--Else, no previous generation exists
			ELSE
			BEGIN
				SET @IdGeneration = NULL
			END
		END
	END
	RETURN @IdGeneration
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetToCompletionGenerationFromVersion]'))
	DROP FUNCTION fnGetToCompletionGenerationFromVersion
GO

CREATE  FUNCTION fnGetToCompletionGenerationFromVersion
(	
	@IdProject		INT,
	@Version		CHAR(1), -- Version of budget
	@IdAssociate		INT
)
RETURNS @GenerationTable TABLE
(	
	ToCompletionPreviousGenerationNo INT NULL,
	ToCompletionCurrentGenerationNo INT NULL,
	ToCompletionNewGenerationNo INT NOT NULL,
	ErrorState			INT NOT NULL,
	ErrorMessage			varchar(255)
) 
AS
BEGIN
-- VERSION MUST BE ONE OF THE FOLLOWING: N, C, P
	IF(ISNULL(CHARINDEX(@Version,'NCP'),0)=0)
	BEGIN
		INSERT INTO @GenerationTable(ToCompletionPreviousGenerationNo,	ToCompletionCurrentGenerationNo,
						ToCompletionNewGenerationNo, ErrorState,ErrorMessage )
		VALUES (-1, -1, -1, -1,'Parameter @Version must be: N, C or P ') 		
		RETURN
	END

	DECLARE @ToCompletionPreviousGenerationNo INT
	DECLARE @ToCompletionCurrentGenerationNo INT
	DECLARE @ToCompletionNewGenerationNo INT

	IF (@Version = 'N')
	BEGIN
		SET @ToCompletionNewGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, @Version)
		SET @ToCompletionCurrentGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, 'C')
		SET @ToCompletionPreviousGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, 'P')
	
		IF (@ToCompletionCurrentGenerationNo IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			INSERT INTO @GenerationTable(ToCompletionPreviousGenerationNo,	ToCompletionCurrentGenerationNo,
						ToCompletionNewGenerationNo, ErrorState,ErrorMessage )
			VALUES (-1, -1, -1, -1,'Could not find any instance of To Completion Budget') 		
			RETURN
			
		END
	
		IF (@ToCompletionNewGenerationNo IS NULL)
		BEGIN
			SET @ToCompletionNewGenerationNo = @ToCompletionCurrentGenerationNo
		END
	
		DECLARE @MaxGeneration INT
		SELECT 	@MaxGeneration = MAX(IdGeneration)
		FROM	BUDGET_TOCOMPLETION_DETAIL BTD
		WHERE 	BTD.IdProject = @IdProject AND
			BTD.IdAssociate = @IdAssociate
		
		IF (@ToCompletionNewGenerationNo <> @MaxGeneration)
		BEGIN
			SET @ToCompletionNewGenerationNo = @ToCompletionCurrentGenerationNo
		END
	END
	
	IF (@Version = 'C')
	BEGIN
		SET @ToCompletionNewGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, @Version)
	
		IF (@ToCompletionNewGenerationNo IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			INSERT INTO @GenerationTable(ToCompletionPreviousGenerationNo,	ToCompletionCurrentGenerationNo,
						ToCompletionNewGenerationNo, ErrorState,ErrorMessage )
			VALUES (-1, -1, -1, -1,'Could not find Released version of To Completion Budget')
			RETURN
		END
		
		SET @ToCompletionCurrentGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, 'P')
		SET @ToCompletionPreviousGenerationNo = CASE WHEN ISNULL(@ToCompletionCurrentGenerationNo, 0) > 1 THEN @ToCompletionCurrentGenerationNo - 1 ELSE NULL END
	END
	
	IF (@Version = 'P')
	BEGIN
		SET @ToCompletionNewGenerationNo = dbo.fnGetToCompletionBudgetGeneration(@IdProject, @Version)
	
		IF (@ToCompletionNewGenerationNo IS NULL AND @IdProject IS NOT NULL)
		BEGIN
			INSERT INTO @GenerationTable(ToCompletionPreviousGenerationNo,	ToCompletionCurrentGenerationNo,
						ToCompletionNewGenerationNo, ErrorState,ErrorMessage )
			VALUES (-1, -1, -1, -1,'Could not find previous version of To Completion Budget')			
			RETURN
		END
		
		SET @ToCompletionCurrentGenerationNo = CASE WHEN ISNULL(@ToCompletionNewGenerationNo, 0) > 1 THEN @ToCompletionNewGenerationNo - 1 ELSE NULL END
		SET @ToCompletionPreviousGenerationNo = CASE WHEN ISNULL(@ToCompletionCurrentGenerationNo, 0) > 1 THEN @ToCompletionCurrentGenerationNo - 1 ELSE NULL END
	END

	INSERT INTO @GenerationTable   (
					ToCompletionPreviousGenerationNo,	
					ToCompletionCurrentGenerationNo,
					ToCompletionNewGenerationNo,
					ErrorState
					)
	VALUES                          (
					 @ToCompletionPreviousGenerationNo,
					 @ToCompletionCurrentGenerationNo,
					 @ToCompletionNewGenerationNo,
					 1
					)

	RETURN

END

GO


--Drops the Function fnGetToCompletionOtherCosts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetToCompletionOtherCosts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetToCompletionOtherCosts]
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO

CREATE   FUNCTION fnGetToCompletionOtherCosts
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@IdAssociate	INT,
	@IdGeneration	INT,
	@YearMonth	INT,
	@IdCostType	INT)
RETURNS DECIMAL(19, 4)
AS
BEGIN
    DECLARE @OtherCosts 	DECIMAL(19, 4)
	SET @OtherCosts = (SELECT SUM(CostVal) 
                        FROM BUDGET_TOCOMPLETION_DETAIL_COSTS
                        WHERE 	IdProject = @IdProject
			AND 	IdPhase = @IdPhase
			AND 	IdWorkPackage = @IdWP
			AND 	IdCostCenter = @IdCostCenter
			AND 	IdAssociate = CASE WHEN @IdAssociate = -1 THEN IdAssociate ELSE @IdAssociate END
			AND 	IdGeneration = @IdGeneration
			AND	YearMonth = @YearMonth
			AND 	IdCostType = CASE WHEN @IdCostType = -1 THEN IdCostType ELSE @IdCostType END)
    RETURN @OtherCosts
END

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--Drops the Function fnGetToCompletionRevisedOtherCosts if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetToCompletionRevisedOtherCosts]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetToCompletionRevisedOtherCosts]
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO

CREATE   FUNCTION fnGetToCompletionRevisedOtherCosts
	(@IdProject	INT,
	@IdPhase	INT,
	@IdWP		INT,
	@IdCostCenter	INT,
	@IdAssociate	INT,
	@IdGeneration	INT,
	@YearMonth	INT,
	@IdCostType	INT)
RETURNS DECIMAL(19, 4)
AS
BEGIN
    DECLARE @OtherCosts 	DECIMAL(19, 4)
	SET @OtherCosts = (SELECT SUM(CostVal) 
                        FROM BUDGET_REVISED_DETAIL_COSTS
                        WHERE 	IdProject = @IdProject
			AND 	IdPhase = @IdPhase
			AND 	IdWorkPackage = @IdWP
			AND 	IdCostCenter = @IdCostCenter
			AND 	IdAssociate = CASE WHEN @IdAssociate = -1 THEN IdAssociate ELSE @IdAssociate END
			AND 	IdGeneration = @IdGeneration
			AND	YearMonth = @YearMonth
			AND 	IdCostType = CASE WHEN @IdCostType = -1 THEN IdCostType ELSE @IdCostType END)
    RETURN @OtherCosts
END

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--Drops the Function fnGetValuedHours if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetValuedHours]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetValuedHours]
GO

CREATE   FUNCTION fnGetValuedHours
	( 	
	@IdCostCenter 	INT,
    	@TotalHours 	DECIMAL(18,2),
	@YearMonth	INT 
	)
RETURNS DECIMAL(18,2)
AS
BEGIN
	DECLARE @HourlyRate		DECIMAL(12,2)
	DECLARE @ValuedHours 		DECIMAL(18,2)

	Set @HourlyRate = dbo.fnGetHourlyRate(@IdCostCenter, @YearMonth)

	--if the hourly rate is null we return 0 in order to avoid some tricky situations above
	IF (@HourlyRate IS NULL)
		RETURN 0

	SET @ValuedHours = @TotalHours * @HourlyRate

	RETURN @ValuedHours
END
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetWeightedAveragePercent]'))
	DROP FUNCTION fnGetWeightedAveragePercent
GO

CREATE FUNCTION fnGetWeightedAveragePercent
	 (@IdProject 		int, 
	 @IdGeneration 		int, 
	 @IdPhase			int, 
	 @IdWorkPackage		int, 
	 @IdAssociate		int)
RETURNS decimal (18,2)
AS
BEGIN
	declare @PercentWeighted	decimal(18,2)

	declare @ProgressTemp table
	( 	
		IdProject			int not null, 
		IdGeneration		int not null, 
		IdPhase				int not null, 
		IdWorkPackage		int not null, 
		IdAssociate			int not null,
		HoursQty			decimal(18,2) null,
		[Percent]			decimal(18,2) null,
		Product				decimal(18,2) null, -- HoursQty * Percent --because of a technical limitation in functions
		PRIMARY KEY (IdProject, IdGeneration, IdPhase, IdWorkPackage, IdAssociate)
	)
	
	INSERT INTO @ProgressTemp
	SELECT IdProject, IdGeneration, IdPhase, IdWorkPackage, IdAssociate, SUM(HoursQty), NULL, NULL
	FROM BUDGET_TOCOMPLETION_DETAIL BTD
	WHERE BTD.IdProject = @IdProject and
		  BTD.IdGeneration = @IdGeneration and
		  BTD.IDPhase = @IdPhase and
		  BTD.IdWorkPackage = @IdWorkPackage and
		  BTD.IdAssociate = CASE WHEN @IdAssociate = -1 THEN BTD.IdAssociate ELSE @IdAssociate END
	GROUP BY IdProject, IdGeneration, IdPhase, IdWorkPackage, IdAssociate

	UPDATE pt 
	SET [Percent] = BTP.[Percent],
		Product = BTP.[Percent] * pt.HoursQty
	FROM @ProgressTemp pt
	INNER JOIN BUDGET_TOCOMPLETION_PROGRESS BTP
		on pt.IdProject = BTP.IdProject and
		   pt.IdGeneration = BTP.IdGeneration and
		   pt.IDPhase = BTP.IdPhase and
		   pt.IdWorkPackage = BTP.IdWorkPackage and
		   pt.IdAssociate = BTP.IdAssociate

	SELECT @PercentWeighted = CASE when SUM(PT.HoursQty) is null then null
								   when isnull(SUM(PT.HoursQty),0) = 0 then 0
								   else SUM(PT.[Product]) / SUM(PT.HoursQty) end
	FROM @ProgressTemp pt

	RETURN @PercentWeighted
END
GO

--Drops the Function fnGetWorkPackageMaxRank if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetWorkPackageMaxRank]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetWorkPackageMaxRank]
GO
CREATE   FUNCTION fnGetWorkPackageMaxRank
()
RETURNS INT
AS
BEGIN

	DECLARE @Rank INT

	SELECT @Rank = ISNULL(MAX(WP.Rank),0)+1
	FROM WORK_PACKAGES WP

RETURN @Rank
END

GO		

--Drops the Function fnGetWorkPackageTemplateMaxRank if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetWorkPackageTemplateMaxRank]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetWorkPackageTemplateMaxRank]
GO
CREATE   FUNCTION fnGetWorkPackageTemplateMaxRank
()
RETURNS INT
AS
BEGIN

	DECLARE @Rank INT

	SELECT @Rank = ISNULL(MAX(WP.Rank),0)+1
	FROM WORK_PACKAGES_TEMPLATE WP

RETURN @Rank
END

GO		

--select * from fnGetWPMonths(194535)
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnGetWPMonths]'))
	DROP FUNCTION fnGetWPMonths
GO

CREATE FUNCTION fnGetWPMonths
(
	@IdProject	AS INT,
	@IdPhase	AS INT,
	@IdWP		AS INT
	
)	
RETURNS @WPMonths TABLE
(	
	IdProject INT,
	IdPhase INT,
	IdWP INT,
	YearMonth INT
) 
AS
BEGIN
	DECLARE @StartYearMonth	INT
	DECLARE @EndYearMonth 	INT
	DECLARE @CurrentYear 	INT
	DECLARE @CurrentMonth 	INT
	DECLARE @CurrentYearMonth INT

	SELECT 
		@StartYearMonth = WP.StartYearMonth,
		@EndYearMonth = WP.EndYearMonth
	FROM WORK_PACKAGES AS WP
	WHERE 
		WP.IdProject = @IdProject AND
		WP.IdPhase = @IdPhase AND
		WP.[Id] = @IdWP

	SET @CurrentYearMonth = @StartYearMonth
	--First insert the months of the wp (between startyearmonth and endyearmonth)
	WHILE (@CurrentYearMonth <= @EndYearMonth)
	BEGIN
		INSERT INTO @WPMonths VALUES(@IdProject, @IdPhase, @IdWP, @CurrentYearMonth)
		SET @CurrentYear = @CurrentYearMonth / 100
		SET @CurrentMonth = @CurrentYearMonth % 100
		IF (@CurrentMonth = 12)
		BEGIN
			SET @CurrentYear = @CurrentYear + 1
			SET @CurrentMonth = 1
		END
		ELSE
		BEGIN
			SET @CurrentMonth = @CurrentMonth + 1
		END

		SET @CurrentYearMonth = @CurrentYear * 100 + @CurrentMonth
	END
	RETURN
END
GO

--Drops the Function fnGetYearMonthOfPreviousMonth if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetYearMonthOfPreviousMonth]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetYearMonthOfPreviousMonth]
GO
CREATE   FUNCTION fnGetYearMonthOfPreviousMonth
	(@CurrentDate	DATETIME)
RETURNS INT
AS
BEGIN
	DECLARE @YearMonthOfPreviousMonth INT
	Set @YearMonthOfPreviousMonth = (case when datepart (mm, @CurrentDate)=1 then datepart (yy, @CurrentDate)-1 else datepart (yy, @CurrentDate) end) * 100 + 
       						   	    (case when datepart (mm, @CurrentDate)=1 then 12 else datepart (mm, @CurrentDate)-1 end)

	RETURN @YearMonthOfPreviousMonth
END
GO

--Drops the Function fnGetValuedHours if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnGetYMStringRepresentation]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnGetYMStringRepresentation]
GO

CREATE   FUNCTION fnGetYMStringRepresentation
	( 	
	@YearMonth	INT 
	)
RETURNS CHAR(7)
AS
BEGIN
	DECLARE @Year INT
	DECLARE @Month INT
	SET @Year = @YearMonth / 100
	SET @Month = @YearMonth % 100
	IF (@Month < 10)
		RETURN CAST (@Year AS CHAR(4)) + '/0' + CAST (@Month AS CHAR(1))
	RETURN CAST (@Year AS CHAR(4)) + '/' + CAST (@Month AS CHAR(2))
END
GO


--select dbo.fnIsAssociatePMOnProject(690, 479)
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnIsAssociatePMOnProject]'))
	DROP FUNCTION fnIsAssociatePMOnProject
GO

CREATE FUNCTION fnIsAssociatePMOnProject
(
	@IdProject	AS INT,
	@IdAssociate	AS INT
	
)	
RETURNS BIT
AS
BEGIN
	DECLARE @IdFunction	INT,
		@IsAssociatePM	BIT

	SET @IsAssociatePM = 0

	SELECT  @IdFunction = IdFunction
	FROM	PROJECT_CORE_TEAMS AS PCT
	WHERE	PCT.IdProject = @IdProject AND
		PCT.IdAssociate = @IdAssociate AND
		PCT.IsActive = 1

	IF @IdFunction IN (1, 7) --PM, Program assistant
		SET @IsAssociatePM = 1

	RETURN @IsAssociatePM
END
GO

IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnIsAssociateProjectReader]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnIsAssociateProjectReader]
GO

CREATE FUNCTION fnIsAssociateProjectReader
(
	@IdProject	AS INT,
	@IdAssociate	AS INT
	
)	
RETURNS BIT
AS
BEGIN
	DECLARE @IdFunction	INT,
		@IsAssociatePR	BIT

	SET @IsAssociatePR = 0

	SELECT  @IdFunction = IdFunction
	FROM	PROJECT_CORE_TEAMS AS PCT
	WHERE	PCT.IdProject = @IdProject AND
		PCT.IdAssociate = @IdAssociate AND
		PCT.IsActive = 1

	IF @IdFunction = 8 --Project Reader
		SET @IsAssociatePR = 1

	RETURN @IsAssociatePR
END

GO

--Drops the Function fnIsBAOrTA if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnIsBAOrTA]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnIsBAOrTA]
GO
CREATE   FUNCTION fnIsBAOrTA
	(@IdAssociate	INT)
RETURNS BIT
AS
BEGIN

	DECLARE @IdRole INT
	
	SELECT @IdRole = IdRole
	FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @IdAssociate
	
	RETURN CASE WHEN (@IdRole = 1 OR @IdRole = 2) THEN 1 ELSE 0 END


END

GO

--Drops the Function fnIsFinancial if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnIsFinancial]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnIsFinancial]
GO
CREATE   FUNCTION fnIsFinancial
	(@IdAssociate	INT)
RETURNS BIT
AS
BEGIN

	DECLARE @IdRole INT
	
	SELECT @IdRole = IdRole
	FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @IdAssociate
	
	RETURN CASE WHEN (@IdRole = 3) THEN 1 ELSE 0 END


END

GO

--Drops the Function fnIsFunctionalManager if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnIsFunctionalManager]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnIsFunctionalManager]
GO
CREATE   FUNCTION fnIsFunctionalManager
	(@IdAssociate	INT)
RETURNS BIT
AS
BEGIN

	DECLARE @IdRole INT
	
	SELECT @IdRole = IdRole
	FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @IdAssociate
	
	RETURN CASE WHEN (@IdRole = 6) THEN 1 ELSE 0 END


END

GO

--Drops the Function fnIsKeyUser if it exists
IF EXISTS(SELECT * FROM dbo.sysobjects WHERE ID= object_id(N'[dbo].[fnIsKeyUser]') and xtype in (N'FN', N'IF', N'TF'))
DROP FUNCTION [dbo].[fnIsKeyUser]
GO
create   FUNCTION [dbo].[fnIsKeyUser]
	(@IdAssociate	INT)
RETURNS BIT
AS
BEGIN

	DECLARE @IdRole INT
	
	SELECT @IdRole = IdRole
	FROM ASSOCIATE_ROLES
	WHERE IdAssociate = @IdAssociate
	
	RETURN CASE WHEN (@IdRole = (select ID from ROLES where Name='Key User')) THEN 1 ELSE 0 END


END


GO
--select * from fnValidateYearMonth(194535)
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnValidateYearMonth]'))
	DROP FUNCTION fnValidateYearMonth
GO

CREATE FUNCTION fnValidateYearMonth
	(@YearMonth	INT)	--The YearMonth to validate
returns @ValidationTable table
(ValidationResult int, --has the value 0 if ok, negative value if not ok
 ErrorMessage     varchar(255) -- contains the string representing the error
) 
AS
BEGIN

declare @month int,
	@errMessage varchar(255)

--check the length to be 6
if (@YearMonth<100000 or @YearMonth>999999)
begin
	set @errMessage = REPLACE('Invalid YearMonth database value: ''%d''. YearMonth must be in the form YYYYMM with length 6.', '%d', @YearMonth)
	insert into @ValidationTable values(-1, @errMessage)
	return
end


--check the boundaries against smalldatetime boundaries
if (@YearMonth<190000 or @YearMonth>207905)
begin
	set @errMessage = REPLACE('Invalid YearMonth database value: ''%d''. YearMonth must contain values between 1900/01 and 2079/06.', '%d', @YearMonth)
	insert into @ValidationTable values(-2, @errMessage)
	return
end


--check the month value
SET @Month = @YearMonth % 100
if (@Month=0 or @Month>12)
begin
	SET @errMessage = REPLACE('Invalid Month in YearMonth database value: ''%d''. Valid values are between 1 and 12.', '%d', @YearMonth)
	insert into @ValidationTable values(-3, @errMessage)
	return
end

insert into @ValidationTable values (0, '')
return

end
go
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[fnWPHasInterco]'))
	DROP FUNCTION fnWPHasInterco
GO

CREATE FUNCTION fnWPHasInterco
	(@IdProject	AS INT,	--The CurrencyFrom of the selected Exchange Rate
	@IdPhase	AS INT, --The CurrencyTo of the selected Exchange Rate
	@IdWP	AS INT)	--The Year and Month of the selected Exchange Rate
RETURNS BIT
AS
BEGIN
	DECLARE @Id INT
	SELECT @Id = IdWorkPackage 
	FROM PROJECTS_INTERCO AS [PI] 
	WHERE 	([PI].IdProject = @IdProject) AND
		([PI].IdPhase = @IdPhase) AND
		([PI].IdWorkPackage = @IdWP) AND
		[PI].IdCountry = (SELECT MAX(IdCountry) 
				FROM PROJECTS_INTERCO AS [PI2] 
				WHERE 	([PI2].IdProject = [PI].IdProject) AND
					([PI2].IdPhase = [PI].IdPhase) AND
					([PI2].IdWorkPackage = [PI].IdWorkPackage))
	IF (@Id IS NULL)
		RETURN 1
	RETURN 0
END
GO

--Drops the Procedure impAnnualProcessErrorsToLogTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impAnnualProcessErrorsToLogTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impAnnualProcessErrorsToLogTables
GO


CREATE    PROCEDURE impAnnualProcessErrorsToLogTables
	@IdImport INT,
	@fileName nvarchar(400),
	@Message nvarchar(255)
AS

IF (@IdImport is null )
	BEGIN 
		RAISERROR('No id import provided',16,1)		
		RETURN -1
	END

DECLARE @RealFileName nvarchar(100)
SELECT @RealFileName= dbo.fnGetFileNameFromPath(@fileName)


DECLARE @YEAR INT
SET @YEAR=SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),4,4)

if not exists(select IdImport from [ANNUAL_BUDGET_IMPORT_LOGS] where IdImport = @IDImport)
-- if some quantity/value was not numeric, it was already inserted a record with "Orange" code
   begin
		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
			( [IdImport], [Year], [Validation] )
		VALUES (@IDImport, @YEAR, 'R')

		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
		(
			[IdImport], [IdRow], [Details]
		)
		VALUES(@IDIMPORT, 1, @Message)
	end




GO

--Drops the Procedure impAnnualUploadErrorsToLogTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impAnnualUploadErrorsToLogTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impAnnualUploadErrorsToLogTables
GO

--exec impAnnualUploadErrorsToLogTables @fileName = N'D:\Work\INDEV3\Source\TestData\ActualData\aaa\GRE2000.csv',
-- @Message = N'The file: GRE2000.csv you are trying to upload does not belong to country France you are registered in'
CREATE    PROCEDURE impAnnualUploadErrorsToLogTables
	@fileName 	nvarchar(400), 	--The name of the file	
	@Message nvarchar(255),		-- the upload error
	@IdAssociate INT
	
AS

IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END


--fill imports table
DECLARE @IDIMPORT INT
SELECT @IDIMPORT  = ISNULL(MAX(IdImport),0)+1 
FROM ANNUAL_BUDGET_IMPORTS (TABLOCKX)

DECLARE @RealFileName nvarchar(100)
SELECT @RealFileName= dbo.fnGetFileNameFromPath(@fileName)


--#############BECAUSE THE FILENAME MIGHT BE WRONG WE USE DEFAULT YEAR
	DECLARE @YEAR int
	SET @YEAR = 1900
-- 	SET @YEAR=SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),4,4)
-- 	PRINT @YEAR
--#############################################################################################



INSERT INTO [ANNUAL_BUDGET_IMPORTS]
	([IdImport], [ImportDate], [FileName], [IdAssociate], ExclusionCostCenterRowsNo, ExclusionGlAccountsRowsNo)
VALUES	(@IDIMPORT,  GETDATE(),	   @RealFileName, @IdAssociate, 0, 0)

INSERT INTO [ANNUAL_BUDGET_IMPORT_DETAILS]
( [IdImport], [IdRow])
VALUES(@IDIMPORT, 1)


INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
	( [IdImport], [Year], [Validation] )
VALUES (@IDImport, @YEAR, 'R')

INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
(
	[IdImport], [IdRow], [Details]
)
VALUES(@IDIMPORT, 1, @Message)




GO

--Drops the Procedure impCheckAnnualFileAlreadyUploaded if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impCheckAnnualFileAlreadyUploaded]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impCheckAnnualFileAlreadyUploaded
GO


CREATE    PROCEDURE impCheckAnnualFileAlreadyUploaded
	@fileName 	nvarchar(400) 	--The name of the file	
	
	
AS


IF (@fileName is null )
BEGIN 
	RAISERROR('No file has been selected',16,1)		
	RETURN -1
END
DECLARE @RealFileName nvarchar(100)
SELECT @RealFileName= dbo.fnGetFileNameFromPath(@fileName)
IF EXISTS
(
	SELECT *--AI.IdImport 
	FROM ANNUAL_BUDGET_IMPORTS AI INNER JOIN ANNUAL_BUDGET_IMPORT_LOGS AIL
	ON AI.IdImport = AIL.IdImport
	WHERE 	UPPER(REPLACE(AI.FileName,'ALL',SUBSTRING(@RealFileName,1,3))) 
		= 
		UPPER(REPLACE(@RealFileName,'ALL',SUBSTRING(AI.FileName,1,3)))
		
	AND AIL.Validation='G'
)


BEGIN
	return -1
END
ELSE
BEGIN
	return 1
END


GO

--Drops the Procedure impCheckFileAlreadyUploaded if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impCheckFileAlreadyUploaded]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impCheckFileAlreadyUploaded
GO


CREATE    PROCEDURE impCheckFileAlreadyUploaded
	@fileName 	nvarchar(400) 	--The name of the file	
	
	
AS


	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END
	DECLARE @RealFileName nvarchar(100)
	SELECT @RealFileName= dbo.fnGetFileNameFromPath(@fileName)
	IF EXISTS(
			SELECT Imports.IdImport 
			FROM IMPORTS INNER JOIN IMPORT_LOGS
			ON IMPORTS.IdImport = IMPORT_LOGS.IdImport
			WHERE IMPORTS.FileName = @RealFileName AND IMPORT_LOGS.Validation='G'
		)
	BEGIN
		return -1
	END
	ELSE
	BEGIN
		return 1
	END


GO



--#################### STORE PROCEDURE TO CHEKC THE CHRONOLOGICAL ORDER OR IMPORT FILE ####################
-- 		RETURNS 0 if OK TO CONTINUE IMPORT
-- 		YEARMONTH OF LAST CORRECT IMPORT IF NOT OK
--##########################################################################################################

--Drops the Procedure impCheckFileImportChronologicalOrder if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impCheckFileImportChronologicalOrder]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impCheckFileImportChronologicalOrder
GO


CREATE     PROCEDURE impCheckFileImportChronologicalOrder
	@fileName varchar(255)

AS
BEGIN	
	DECLARE @LAST_YearMonth INT
	DECLARE @File_YearMonth INT
	DECLARE @CountryCode varchar(3)
	DECLARE @YearMonth INT
	SET @CountryCode = SUBSTRING(@fileName, 4,3)

	DECLARE @Year varchar(4)
	DECLARE @Month varchar(2)
	DECLARE @ImportApplicationType varchar(3)
		
	SET @ImportApplicationType = SUBSTRING(@fileName, 1,3)
	SET @Year 		= SUBSTRING(@fileName, 9,4)
	SET @Month 		= SUBSTRING(@fileName,7,2)
	SET @File_YearMonth = @Year*100 + @Month

-- 	SELECT LAST SUCCEFULLY IMPORT YEARMONTH FOR THE FILE YEAR
	SELECT  @YearMonth = MAX(IL.YearMonth)
		FROM IMPORTS I
		INNER JOIN IMPORT_LOGS IL
			ON IL.IdImport = I.IdImport
		INNER JOIN IMPORT_SOURCES ISRC
			ON IL.IdSource = ISRC.Id
		INNER JOIN IMPORT_APPLICATION_TYPES IAT
			ON ISRC.IdApplicationTypes = IAT.Id
		WHERE  IL.Validation='G' AND
			   SUBSTRING(Filename, 4,3) = @CountryCode AND
		       IAT.Name = @ImportApplicationType AND
		       IL.YearMonth/100 = @Year

-- 	CHECK IF IS THIS IS THE FIRST IMPORT FROM THE SAME COUNTRY
	IF(@YearMonth IS NOT NULL)
	BEGIN
		SET @Month = @YearMonth % 100
		SET @Year = @YearMonth /100
		SET @Month = RIGHT('00' + CAST((CAST(@Month AS INT) -1) AS VARCHAR(2)),2)
		
	-- 	###################################
-- 		CHECK IF THE DATE FROM LAST SUCCESFULLY IMPORT IS THE PREVIOUS MONTH

		IF (@File_YearMonth - @YearMonth != 1)
		BEGIN
			SET @LAST_YearMonth=  @YearMonth		
		END			
	END
	
	DECLARE @ErrorMessage  VARCHAR(255)
	SET @ErrorMessage = 'File import must be made in chronological order. Expected period of imported file for year:' + @Year + ' is: ' + dbo.fnGetYMStringRepresentation(@LAST_YearMonth +1)
	IF (ISNULL(@LAST_YearMonth,0) <> 0)
		RAISERROR(@ErrorMessage, 16,1)
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impCheckImportedDataConsistency]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impCheckImportedDataConsistency
GO

--impCheckImportedDataConsistency 12
--impCheckImportedDataConsistency 10
CREATE PROCEDURE impCheckImportedDataConsistency
	@IdImport 	INT --ID of the import
AS	
BEGIN

Declare @IdSource int,
	@YearMonth int,
	@strError varchar(255),
	@hasKRMError bit,
	@KRMDiff int -- difference of key rows missing found in total

SET @hasKRMError = 0
SET @KRMDiff = 0

SELECT @IdSource = IL.IdSource,
	@YearMonth = IL.YearMonth
FROM IMPORT_LOGS IL
WHERE IL.IdImport = @IdImport

IF (@IdSource IS NULL) 
BEGIN
	SET @strError = 'Import with id '+ cast(@IdImport as varchar(10)) +' does not exists in the database.'
	RAISERROR(@strError, 16, 1)
	return -1
END


--prepare the null associates table per country
DECLARE @CountryCode varchar (3)
DECLARE @NULLASSOCIATES TABLE
(
	CountryCode		varchar(3),
	NullAssociateId		int,
	NullEmployeeNumber	varchar(15)
)

DECLARE @ACTUALCUMULATED TABLE
(
	IdProject		INT, 
        IdPhase			INT,
        IdWorkPackage		INT,
        IdCostCenter		INT, 
        IdAssociate		INT, 
        IdCountry		INT, 
	IdAccount		INT,
	ProjectCode		varchar(10),
	WPCode			varchar(3),
	CostCenter		varchar(15),
	AccountNumber		varchar(20),
	AssociateNumber		varchar(15),
	Country			varchar(3),
	Quantity		decimal(12,2),
	Value			decimal(18,2)

	PRIMARY KEY (IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount)
)

DECLARE @IMPORT_YTD TABLE
(
	ProjectCode		varchar(10),
	WPCode			varchar(3),
	CostCenter		varchar(15),
	AssociateNumber		varchar(15),
	Country			varchar(3),
	AccountNumber		varchar(20),
	Quantity		decimal(12,2),
	Value			decimal(18,2)

	PRIMARY KEY (ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber)
)


--read the cost type account
DECLARE @IdCostTypeHours INT
DECLARE @IdCostTypeSales INT
SELECT @IdCostTypeHours = dbo.fnGetHoursCostTypeID()
SELECT @IdCostTypeSales = dbo.fnGetSalesCostTypeID()

-- we will use this associate number TEMPORARY (in order to avoid NULL whcih cannot be part of a PK in a table) CCP = check consistency procedure
DECLARE @NULLTempAssociateNumber varchar(15)
SET @NULLTempAssociateNumber = 'CCP________' 

--read the null asscoiates for all the countries involved in an import
INSERT INTO @NULLASSOCIATES
	(CountryCode, NullAssociateId, NullEmployeeNumber)
SELECT Country,
       dbo.fnGetNullAssociateId(Country),
       null
FROM IMPORT_DETAILS
WHERE IdImport = @IdImport
GROUP BY Country

SELECT TOP 1 @CountryCode = CountryCode
FROM @NULLASSOCIATES
where NullAssociateId is null

IF (@CountryCode IS NOT NULL)
BEGIN
	RAISERROR('No null associate found for country %s.', 16, 1, @COUNTRYCODE)
	RETURN -2
END

UPDATE @NULLASSOCIATES
SET NullEmployeeNumber = EmployeeNumber
FROM @NULLASSOCIATES
INNER JOIN ASSOCIATES A
	ON NullAssociateId = A.Id

---
DECLARE @Application_Type_Name NVARCHAR(3)
SELECT @Application_Type_Name = [NAME] 
FROM IMPORT_APPLICATION_TYPES IAT
INNER JOIN IMPORT_SOURCES [IS]
	ON IAT.Id = [IS].IdApplicationTypes
WHERE [IS].Id = @IdSource


--A. Check the HoursQty and HoursVal
INSERT INTO @ACTUALCUMULATED
	(IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount, 
	ProjectCode, WPCode, CostCenter, AccountNumber, AssociateNumber,Country, 
	Quantity, Value)
SELECT ADH.IdProject, ADH.IdPhase, ADH.IdWorkPackage, ADH.IdCostCenter, ADH.IdAssociate, ADH.IdCountry, ADH.IdAccount, 
	NULL, NULL, NULL, NULL, NULL, NULL,
	SUM (ADH.HoursQty), SUM (ADH.HoursVal)
FROM ACTUAL_DATA_DETAILS_HOURS ADH
INNER JOIN IMPORT_LOGS IL
	ON ADH.IdImport = IL.IdImport
WHERE IL.IdSource = @IdSource AND                -- same source
      IL.YearMonth/100 = @YearMonth/100 and      -- same year
      IL.YearMonth % 100 <= @YearMonth % 100 and -- only the previous and current months
      IL.Validation = 'G'                        -- only the succeeded imports
GROUP BY IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount 

UPDATE A
SET A.ProjectCode = P.Code,
    A.WPCode = WP.Code,
    A.CostCenter = CC.Code,
    A.AssociateNumber = ASOC.EmployeeNumber,
    A.Country = C.Code,
    A.AccountNumber = GL.Account
FROM @ACTUALCUMULATED A
INNER JOIN PROJECTS P
	ON P.Id = A.IdProject
INNER JOIN WORK_PACKAGES WP
	ON A.IdProject = WP.IdProject and
	   A.IdPhase = WP.IdPhase and
	   A.IdWorkPackage = WP.Id
INNER JOIN COST_CENTERS CC
	ON A.IdCostCenter = CC.Id
INNER JOIN ASSOCIATES ASOC
	ON A.IdAssociate = ASOC.Id
INNER JOIN COUNTRIES C
	ON A.IdCountry = C.Id
INNER JOIN GL_ACCOUNTS GL
	ON A.IdCountry = GL.IdCountry and
	   A.IdAccount = GL.Id

INSERT INTO @IMPORT_YTD
	(ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber, Quantity, Value)
select  ProjectCode,
	WPCode, 
	CostCenter, 
	ISNULL(AssociateNumber, @NULLTempAssociateNumber)  AS AssociateNumber,
	Country,  
	AccountNumber,
	SUM (Quantity) AS HoursQty, 
	Sum(Value) AS HoursVal
from IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	on C.Code = IMD.Country
where IdImport  = @IdImport and 
      dbo.fnGetBudgetCostType(C.ID,IMD.AccountNumber)  = @IdCostTypeHours 
-- use group by and sum in order to summarize information where the associate is null
group by Country, Year, Month, CostCenter, ProjectCode, WPCode, AccountNumber, AssociateNumber

--put the account number of the null associates for all countries from the import
UPDATE I
SET AssociateNumber = NullEmployeeNumber
FROM @IMPORT_YTD I
INNER JOIN @NULLASSOCIATES NA
	ON I.Country = NA.CountryCode
WHERE AssociateNumber = @NULLTempAssociateNumber

-- if we have different number of rows, this means inconsistency
DECLARE @CountActual INT,
	@CountImport INT
SELECT @CountActual = COUNT (*) from @ACTUALCUMULATED
SELECT @CountImport = COUNT (*) from @IMPORT_YTD
IF (@CountActual <> @CountImport)
BEGIN
	SET @KRMDiff = @KRMDiff + (@CountActual - @CountImport)
	SET @hasKRMError = 1
END

IF (@hasKRMError = 0) -- if KRM is ok then we can verify details
BEGIN
	UPDATE I
	SET I.Quantity = I.Quantity - A.Quantity
	FROM @IMPORT_YTD I
	INNER JOIN @ACTUALCUMULATED A
		ON I.ProjectCode = A.ProjectCode AND
		   I.WPCode = A.WPCode AND
		   I.CostCenter = A.CostCenter AND
		   I.AssociateNumber = A.AssociateNumber AND
		   I.Country = A.Country AND
		   I.AccountNumber = A.AccountNumber
	
	DECLARE @CountImportDiffQty INT
	Select @CountImportDiffQty = Count(*) 
	FROM @IMPORT_YTD
	WHERE Quantity <> 0
	IF (@CountImportDiffQty > 0)
	BEGIN
		RAISERROR('Consistency check failed (HoursQty). Actual data imported is different then current import for %d row(s).', 16, 1, @CountImportDiffQty)
		RETURN -3
	END
	
	
	IF (@Application_Type_Name <> 'NET')
	BEGIN
		UPDATE I
		SET I.Value = I.Value - A.Value
		FROM @IMPORT_YTD I
		INNER JOIN @ACTUALCUMULATED A
			ON I.ProjectCode = A.ProjectCode AND
			   I.WPCode = A.WPCode AND
			   I.CostCenter = A.CostCenter AND
			   I.AssociateNumber = A.AssociateNumber AND
			   I.Country = A.Country AND
			   I.AccountNumber = A.AccountNumber
		
		DECLARE @CountImportDiffVal INT
		Select @CountImportDiffVal = Count(*) 
		FROM @IMPORT_YTD
		WHERE Value > 0
		IF (@CountImportDiffVal > 0)
		BEGIN	
			RAISERROR('Consistency check failed (HoursVal). Actual data imported is different then current import for %d row(s).', 16, 1, @CountImportDiffVal)
			RETURN -4
		END
	END
END

--B.Check the costs
--clean up data
DELETE @ACTUALCUMULATED
DELETE @IMPORT_YTD


INSERT INTO @ACTUALCUMULATED
	(IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount, 
	ProjectCode, WPCode, CostCenter, AccountNumber, AssociateNumber,Country, 
	Quantity, Value)
SELECT ADC.IdProject, ADC.IdPhase, ADC.IdWorkPackage, ADC.IdCostCenter, ADC.IdAssociate, ADC.IdCountry, ADC.IdAccount,
       NULL, NULL, NULL, NULL, NULL, NULL,
       NULL, SUM (ADC.CostVal) as CostVal
FROM ACTUAL_DATA_DETAILS_COSTS ADC
INNER JOIN IMPORT_LOGS IL
	ON ADC.IdImport = IL.IdImport
WHERE IL.IdSource = @IdSource AND                -- same source
      IL.YearMonth/100 = @YearMonth/100 and      -- same year
      IL.YearMonth % 100 <= @YearMonth % 100 and -- only the previous and current months
      IL.Validation = 'G'                        -- only the succeeded imports
GROUP BY IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount 

UPDATE A
SET A.ProjectCode = P.Code,
    A.WPCode = WP.Code,
    A.CostCenter = CC.Code,
    A.AssociateNumber = ASOC.EmployeeNumber,
    A.Country = C.Code,
    A.AccountNumber = GL.Account
FROM @ACTUALCUMULATED A
INNER JOIN PROJECTS P
	ON P.Id = A.IdProject
INNER JOIN WORK_PACKAGES WP
	ON A.IdProject = WP.IdProject and
	   A.IdPhase = WP.IdPhase and
	   A.IdWorkPackage = WP.Id
INNER JOIN COST_CENTERS CC
	ON A.IdCostCenter = CC.Id
INNER JOIN ASSOCIATES ASOC
	ON A.IdAssociate = ASOC.Id
INNER JOIN COUNTRIES C
	ON A.IdCountry = C.Id
INNER JOIN GL_ACCOUNTS GL
	ON A.IdCountry = GL.IdCountry and
	   A.IdAccount = GL.Id

INSERT INTO @IMPORT_YTD
	(ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber, Quantity, Value)
SELECT  ProjectCode,
	WPCode, 
	CostCenter, 
	ISNULL(AssociateNumber, @NULLTempAssociateNumber)  AS AssociateNumber,
	Country,  
	AccountNumber,
	NULL AS Quantity, 
	Sum(Value) AS CostVal
from IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	ON C.Code = IMD.Country
WHERE IdImport  = @IdImport and 
      dbo.fnGetBudgetCostType(C.ID,IMD.AccountNumber) BETWEEN 1 AND 5
-- use group by and sum in order to summarize information where the associate is null
GROUP BY Country, Year, Month, CostCenter, ProjectCode, WPCode, AccountNumber, AssociateNumber

--put the account number of the null associates for all countries from the import
UPDATE I
SET AssociateNumber = NullEmployeeNumber
FROM @IMPORT_YTD I
INNER JOIN @NULLASSOCIATES NA
	ON I.Country = NA.CountryCode
WHERE AssociateNumber = @NULLTempAssociateNumber

-- if we have different number of rows, this means inconsistency
SELECT @CountActual = COUNT (*) from @ACTUALCUMULATED
SELECT @CountImport = COUNT (*) from @IMPORT_YTD
IF (@CountActual <> @CountImport)
BEGIN
	SET @KRMDiff = @KRMDiff + (@CountActual - @CountImport)
	SET @hasKRMError = 1
END

IF (@hasKRMError = 0) -- if KRM is ok then we can verify details
BEGIN
	UPDATE I
	SET I.Value = I.Value - A.Value
	FROM @IMPORT_YTD I
	INNER JOIN @ACTUALCUMULATED A
		ON I.ProjectCode = A.ProjectCode AND
		   I.WPCode = A.WPCode AND
		   I.CostCenter = A.CostCenter AND
		   I.AssociateNumber = A.AssociateNumber AND
		   I.Country = A.Country AND
		   I.AccountNumber = A.AccountNumber
	
	SELECT @CountImportDiffVal = Count(*) 
	FROM @IMPORT_YTD
	WHERE Value > 0
	IF (@CountImportDiffVal > 0)
	BEGIN
		RAISERROR('Consistency check failed (CostVal). Actual data imported is different then current import for %d row(s).', 16, 1, @CountImportDiffVal)
		RETURN -5
	END
END


--C.Check the sales
DELETE @ACTUALCUMULATED
DELETE @IMPORT_YTD


INSERT INTO @ACTUALCUMULATED
	(IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount, 
	ProjectCode, WPCode, CostCenter, AccountNumber, AssociateNumber,Country, 
	Quantity, Value)
SELECT ADS.IdProject, ADS.IdPhase, ADS.IdWorkPackage, ADS.IdCostCenter, ADS.IdAssociate, ADS.IdCountry, ADS.IdAccount,
	NULL, NULL, NULL, NULL, NULL, NULL,
       NULL, SUM (ADS.SalesVal)
FROM ACTUAL_DATA_DETAILS_SALES ADS
INNER JOIN IMPORT_LOGS IL
	ON ADS.IdImport = IL.IdImport
WHERE IL.IdSource = @IdSource AND                -- same source
      IL.YearMonth/100 = @YearMonth/100 and      -- same year
      IL.YearMonth % 100 <= @YearMonth % 100 and -- only the previous and current months
      IL.Validation = 'G'                        -- only the succeeded imports
GROUP BY IdProject, IdPhase, IdWorkPackage, IdCostCenter, IdAssociate, IdCountry, IdAccount 

UPDATE A
SET A.ProjectCode = P.Code,
    A.WPCode = WP.Code,
    A.CostCenter = CC.Code,
    A.AssociateNumber = ASOC.EmployeeNumber,
    A.Country = C.Code,
    A.AccountNumber = GL.Account
FROM @ACTUALCUMULATED A
INNER JOIN PROJECTS P
	ON P.Id = A.IdProject
INNER JOIN WORK_PACKAGES WP
	ON A.IdProject = WP.IdProject and
	   A.IdPhase = WP.IdPhase and
	   A.IdWorkPackage = WP.Id
INNER JOIN COST_CENTERS CC
	ON A.IdCostCenter = CC.Id
INNER JOIN ASSOCIATES ASOC
	ON A.IdAssociate = ASOC.Id
INNER JOIN COUNTRIES C
	ON A.IdCountry = C.Id
INNER JOIN GL_ACCOUNTS GL
	ON A.IdCountry = GL.IdCountry and
	   A.IdAccount = GL.Id

INSERT INTO @IMPORT_YTD
	(ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber, Quantity, Value)
SELECT  ProjectCode,
	WPCode, 
	CostCenter, 
	ISNULL(AssociateNumber, @NULLTempAssociateNumber)  AS AssociateNumber,
	Country,  
	AccountNumber, 
	NULL AS Quantity, 
	Sum(Value) AS SalesVal
FROM IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	ON C.Code = IMD.Country
WHERE IdImport  = @IdImport and 
      dbo.fnGetBudgetCostType(C.ID,IMD.AccountNumber) = @IdCostTypeSales
-- use group by and sum in order to summarize information where the associate is null
GROUP BY Country, Year, Month, CostCenter, ProjectCode, WPCode, AccountNumber, AssociateNumber

--put the account number of the null associates for all countries from the import
UPDATE I
SET AssociateNumber = NullEmployeeNumber
FROM @IMPORT_YTD I
INNER JOIN @NULLASSOCIATES NA
	ON I.Country = NA.CountryCode
WHERE AssociateNumber = @NULLTempAssociateNumber

-- if we have different number of rows, this means inconsistency
SELECT @CountActual = COUNT (*) from @ACTUALCUMULATED
SELECT @CountImport = COUNT (*) from @IMPORT_YTD
IF (@CountActual <> @CountImport)
BEGIN
	SET @KRMDiff = @KRMDiff + (@CountActual - @CountImport)
	SET @hasKRMError = 1
END

IF (@hasKRMError = 0) -- if KRM is ok then we can verify details
BEGIN
	UPDATE I
	SET I.Value = I.Value - A.Value
	FROM @IMPORT_YTD I
	INNER JOIN @ACTUALCUMULATED A
		ON I.ProjectCode = A.ProjectCode AND
		   I.WPCode = A.WPCode AND
		   I.CostCenter = A.CostCenter AND
		   I.AssociateNumber = A.AssociateNumber AND
		   I.Country = A.Country AND
		   I.AccountNumber = A.AccountNumber

	SELECT @CountImportDiffVal = Count(*) 
	FROM @IMPORT_YTD
	WHERE Value > 0
	IF (@CountImportDiffVal > 0)
	BEGIN	
		RAISERROR('Consistency check failed (SalesVal). Actual data imported is different then current import for %d row(s).', 16, 1, @CountImportDiffVal)
		RETURN -6
	END
END

--it is important to return with error in case there were KRM type check failes (@KRMDiff > 0)
IF (@hasKRMError > 0)
BEGIN
	SET @strError = 'Consistency check failed. A number of ' + cast(@KRMDiff as varchar(10)) + ' key row(s) were missing from import.'
	RAISERROR (@strError, 16,1)
	RETURN -7
END



END
GO

--Drops the Procedure impChronologicalErrorsToLogTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impChronologicalErrorsToLogTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impChronologicalErrorsToLogTables
GO


CREATE    PROCEDURE impChronologicalErrorsToLogTables
	@fileName 	nvarchar(400), 	--The name of the file	
	@IdAssociate INT,		--ID of the associate
	@Message nvarchar(255),		-- the upload error
	 @IdSource INT			-- ID of source application
AS

IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

DECLARE @RealFileName nvarchar(100)
Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)

	IF (@IdSource=-1)
	BEGIN
		RAISERROR('File in wrong format: no id source!',16,1)		
		RETURN -2
	END

--fill imports table
DECLARE @IDIMPORT INT
SELECT @IDIMPORT  = ISNULL(MAX(IdImport),0)+1 
FROM IMPORTS (TABLOCKX)

DECLARE @YEARMONTH INT
	SET @YEARMONTH=SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),3,4) + 
	SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),1,2)

INSERT INTO [IMPORTS]([IdImport], [ImportDate], [FileName], [IdAssociate], [ExclusionCostCenterRowsNo], [ExclusionGlAccountsRowsNo])
VALUES(@IDIMPORT, GETDATE(), @RealFileName, @IdAssociate, 0, 0)


INSERT INTO [IMPORT_DETAILS]([IdImport], [IdRow])
VALUES(@IDIMPORT, 1)

INSERT INTO [IMPORT_LOGS]([IdImport], [IdSource], [YearMonth], [Validation])
VALUES(@IDIMPORT, @IdSource, @YEARMONTH, 'R')

INSERT INTO [IMPORT_LOGS_DETAILS]([IdImport], [IdRow], [Details])
VALUES(@IDIMPORT, 1, @Message)



GO

--Drops the Procedure impDeleteAnnualImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impDeleteAnnualImportDetails]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impDeleteAnnualImportDetails
GO
CREATE PROCEDURE impDeleteAnnualImportDetails
(
	@IdImport INT
)

AS

	DELETE FROM ANNUAL_BUDGET_IMPORT_DETAILS WHERE IdImport = @IdImport

GO

--Drops the Procedure bgtDeleteDataLogs if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impDeleteImport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impDeleteImport
GO
CREATE PROCEDURE impDeleteImport
	@IdImport INT
AS

DELETE FROM IMPORT_LOGS_DETAILS 
WHERE IdImport = @IdImport

DELETE FROM IMPORT_LOGS_DETAILS_KEYROWS_MISSING
WHERE IdImport = @IdImport

DELETE FROM IMPORT_DETAILS_KEYROWS_MISSING
WHERE IdImport = @IdImport

DELETE FROM IMPORT_LOGS 
WHERE IdImport = @IdImport	

DELETE FROM IMPORT_DETAILS 
WHERE IdImport = @IdImport

DELETE FROM IMPORTS 
WHERE IdImport = @IdImport

GO

--Drops the Procedure impDeleteImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impDeleteImportDetails]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impDeleteImportDetails
GO
CREATE PROCEDURE impDeleteImportDetails
(
	@IdImport INT
)

AS

DELETE FROM IMPORT_DETAILS WHERE IdImport = @IdImport

GO

--Drops the Procedure impDeleteImportRows if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impDeleteImportRows]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impDeleteImportRows
GO
CREATE PROCEDURE impDeleteImportRows
(
	@IdImport INT,
	@IdRow INT
)

AS
	DELETE FROM IMPORT_LOGS_DETAILS WHERE IdImport = @IdImport AND IdRow = @IdRow
	DELETE FROM IMPORT_LOGS_DETAILS_KEYROWS_MISSING WHERE IdImport = @IdImport AND IdRow = @IdRow
	DELETE FROM IMPORT_DETAILS WHERE IdImport = @IdImport AND IdRow = @IdRow
	DELETE FROM IMPORT_DETAILS_KEYROWS_MISSING WHERE IdImport = @IdImport AND IdRow = @IdRow

GO
--Drops the Procedure impDeleteImportSourcesCountries if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impDeleteImportSourcesCountries]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impDeleteImportSourcesCountries
GO

CREATE PROCEDURE [dbo].[impDeleteImportSourcesCountries]
	@IdCountry	AS INT		
AS
BEGIN
	DELETE FROM [IMPORT_SOURCES_COUNTRIES]
	WHERE 	IdCountry = @IdCountry 
	IF (@@ERROR <> 0)
		BEGIN
			RAISERROR ('There was error deleting ImportSourcesCountries.',16,1)
			RETURN -1
		END	
END
GO

--Drops the Procedure impGetNonExistingAssociateNumbers if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impGetNonExistingAssociateNumbers]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impGetNonExistingAssociateNumbers
GO


CREATE     PROCEDURE impGetNonExistingAssociateNumbers	
	@IdImport INT			-- ID of the import
	
AS

IF @IdImport IS NULL
BEGIN
	RAISERROR('No id import',16,1)		
	RETURN -1
END


-- #################### TAKE ALL RECORDS FROM IMPORT DETAILS THAT HAVE NON VALID ASSOCIATE NUMBER CODES######
SELECT DISTINCT IMD.AssociateNumber, A.ID
FROM IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	ON C.Code = IMD.Country
LEFT JOIN ASSOCIATES A
	ON A.IdCountry = C.Id AND
	A.EmployeeNumber = IMD.AssociateNumber
WHERE 	IdImport = @IdImport AND
	SUBSTRING(A.InergyLogin,1,7) = 'UPLOAD\' AND
	IMD.AssociateNumber IS NOT NULL AND
	RIGHT(A.InergyLogin,LEN(A.InergyLogin)-CHARINDEX('_',A.InergyLogin)) = CONVERT(VARCHAR(10), @IdImport)


GO

--Drops the Procedure impIsUserAllowedOnImportSource if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impIsUserAllowedOnImportSource]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impIsUserAllowedOnImportSource
GO

CREATE PROCEDURE impIsUserAllowedOnImportSource
	@IdAssociate 		AS INT,
	@IdImportSource       	AS INT		
AS	
declare @IsAllowed int
declare @UserCountry int

select @UserCountry = IdCountry 
from ASSOCIATES 
where Id = @IdAssociate

if (select COUNT(*)
    from IMPORT_SOURCES_COUNTRIES ISC
    where ISC.IdImportSource = @IdImportSource and
          ISC.IdCountry = @UserCountry) > 0
	set @IsAllowed = 1
else
	set @IsAllowed = 0

select @IsAllowed as 'isAllowed'

GO


--Drops the Procedure impProcessErrorToLogTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impProcessErrorToLogTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impProcessErrorToLogTable
GO


CREATE    PROCEDURE impProcessErrorToLogTable
	@IdImport INT,
	@Message nvarchar(255)
AS

-- we have an error
UPDATE IMPORT_LOGS
SET Validation = 'R'
WHERE IdImport = @IdImport

INSERT INTO [IMPORT_LOGS_DETAILS]
	([IdImport], [IdRow], [Details])
VALUES(@IDIMPORT, 1, @Message)

GO



IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impRemoveActualImport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[impRemoveActualImport]
GO


CREATE procedure [impRemoveActualImport]
@IdImport int
as

declare @errMessage varchar(500)

if not exists (select IdImport from IMPORTS (nolock) where IdImport=@IdImport)
  return


begin tran

DELETE ACTUAL_DATA_DETAILS_HOURS where IdImport=@IdImport

if @@error <> 0
  begin
     set @errMessage = 'ACTUAL_DATA_DETAILS_HOURS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE ACTUAL_DATA_DETAILS_SALES where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ACTUAL_DATA_DETAILS_SALES for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE ACTUAL_DATA_DETAILS_COSTS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ACTUAL_DATA_DETAILS_COSTS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end
 
DELETE IMPORT_LOGS_DETAILS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORT_LOGS_DETAILS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE IMPORT_LOGS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORT_LOGS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE IMPORT_DETAILS_KEYROWS_MISSING where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORT_DETAILS_KEYROWS_MISSING for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE IMPORT_DETAILS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORT_DETAILS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE IMPORTS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORTS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

	commit
	select 0
	goto retur

err:
	rollback
	raiserror(@errMessage,16,1)
	select -1

retur:
    return


GO

/****** Object:  StoredProcedure [dbo].[impRemoveAnnualImport]    Script Date: 9/29/2015 5:28:14 PM ******/
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impRemoveAnnualImport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[impRemoveAnnualImport]
GO


Create procedure [impRemoveAnnualImport]
@IdImport int
as

declare @errMessage varchar(500)

if not exists (select IdImport from ANNUAL_BUDGET_IMPORTS (nolock) where IdImport=@IdImport)
  return
  
begin tran

DELETE ANNUAL_BUDGET_DATA_DETAILS_HOURS where IdImport=@IdImport

if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_DATA_DETAILS_HOURS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
DELETE ANNUAL_BUDGET_DATA_DETAILS_SALES where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_DATA_DETAILS_SALES for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE ANNUAL_BUDGET_DATA_DETAILS_COSTS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_DATA_DETAILS_COSTS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end
 
DELETE ANNUAL_BUDGET_IMPORT_LOGS_DETAILS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_IMPORT_LOGS_DETAILS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE ANNUAL_BUDGET_IMPORT_LOGS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_IMPORT_LOGS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE IMPORT_DETAILS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'IMPORT_DETAILS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

DELETE ANNUAL_BUDGET_IMPORT_DETAILS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_IMPORT_DETAILS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end

  
DELETE ANNUAL_BUDGET_IMPORTS where IdImport=@IdImport
if @@error <> 0
  begin
     set @errMessage = 'ANNUAL_BUDGET_IMPORTS for IdImport = ' + cast(@IdImport as varchar) + ' couldn''t be deleted'
	 goto err
  end
  
	commit
	select 0
	goto retur

err:
	rollback
	raiserror(@errMessage,16,1)
	select -1

retur:
    return


GO
--Drops the Procedure impSelectAnnualImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectAnnualImportDetails]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectAnnualImportDetails
GO
CREATE PROCEDURE impSelectAnnualImportDetails
(
	@IdImport INT
)
AS
IF (@IdImport is null )
BEGIN 
	RAISERROR('No import selected',16,1)		
	RETURN -1
END


SELECT  BID.IdImport,
	BID.IdRow,
	BID.CostCenter,
	BID.ProjectCode,
	P.Id as ProjectId,
	BID.WPCode,
	BID.AccountNumber,
	isnull(BID.Quantity1,0) + isnull(BID.Quantity2,0) + isnull(BID.Quantity3,0) + isnull(BID.Quantity4,0) + isnull(BID.Quantity5,0) + isnull(BID.Quantity6,0) 
	+ isnull(BID.Quantity7,0) + isnull(BID.Quantity8,0) + isnull(BID.Quantity9,0) + isnull(BID.Quantity10,0) + isnull(BID.Quantity11,0) + isnull(BID.Quantity12,0)
	as Quantity,
	isnull(BID.Value1,0) + isnull(BID.Value2,0) + isnull(BID.Value3,0) + isnull(BID.Value4,0) + isnull(BID.Value5,0) + isnull(BID.Value6,0)
	+ isnull(BID.Value7,0) + isnull(BID.Value8,0) + isnull(BID.Value9,0) + isnull(BID.Value10,0) + isnull(BID.Value11,0) + isnull(BID.Value12,0)
	as Value,
	BID.CurrencyCode,
	BID.Date 
FROM ANNUAL_BUDGET_IMPORT_DETAILS BID
INNER JOIN ANNUAL_BUDGET_IMPORT_LOGS_DETAILS BILD
	ON BILD.IdImport = BID.IdImport AND
	BILD.IdRow = BID.IdRow AND
-- HACK TO TAKE ONLY ROWS THAT EXISTS IN ANNUAL_BUDGET_IMPORT_LOGS_DETAILS
	BILD.Id = (SELECT MIN(ID)
		   FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS ild
		   WHERE ild.idimport = BILD.idimport AND
		   ild.idrow = BILD.idrow)
LEFT JOIN PROJECTS P
	ON BID.ProjectCode = P.CODE
	
WHERE BID.IdImport = @IdImport
union
-- get column1..12, value1..12 not numeric errors from ANNUAL_BUDGET_IMPORT_LOGS_DETAILS
SELECT  IdImport,
	IdRow,
	'',
	'',
	null,
	'',
	'',
	null as Quantity,
	null as Value,
	'',
	null 
FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS 
WHERE IdImport = @IdImport and Details like '%not numeric%'
ORDER BY 2

GO
--Drops the Procedure impSelectAnnualImportDetailsErrors if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.impSelectAnnualImportDetailsErrors') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectAnnualImportDetailsErrors
GO


CREATE PROCEDURE impSelectAnnualImportDetailsErrors
(
	@IdImport INT
)
AS
BEGIN
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

	SELECT IMPD.IdImport, IMPD.IdRow, IMPD.Id, 
	       IMPD.Details, IMPD.Module, ISNULL(MDL.Name,'') AS ModuleName
	FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS IMPD (nolock)
	LEFT JOIN MODULES MDL
		on IMPD.Module = MDL.Code
	WHERE IdImport = @IdImport
	ORDER BY IdImport, IdRow, Id
END
GO

--Drops the Procedure impSelectAnnualImportDetailsForExport if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectAnnualImportDetailsForExport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectAnnualImportDetailsForExport
GO
CREATE PROCEDURE impSelectAnnualImportDetailsForExport
(
	@IdImport INT
)

AS
IF (@IdImport is null )
BEGIN 
	RAISERROR('No import selected',16,1)		
	RETURN -1
END


SELECT  IdImport,
	IdRow,
	Country,
	Year,
	CostCenter,
	ProjectCode,
	WPCode,
	AccountNumber,
	isnull(Value1,0) as Value1,
	isnull(Value2,0) as Value2,
	isnull(Value3,0) as Value3,
	isnull(Value4,0) as Value4,
	isnull(Value5,0) as Value5, 
	isnull(Value6,0) as Value6,
	isnull(Value7,0) as Value7,
	isnull(Value8,0) as Value8,
	isnull(Value9,0) as Value9,
	isnull(Value10,0) as Value10,
	isnull(Value11,0) as Value11,
	isnull(Value12,0) as Value12,
	isnull(Quantity1,0) as Quantity1,
	isnull(Quantity2,0) as Quantity2,
	isnull(Quantity3,0) as Quantity3,
	isnull(Quantity4,0) as Quantity4,
	isnull(Quantity5,0) as Quantity5, 
	isnull(Quantity6,0) as Quantity6,
	isnull(Quantity7,0) as Quantity7,
	isnull(Quantity8,0) as Quantity8,
	isnull(Quantity9,0) as Quantity9,
	isnull(Quantity10,0) as Quantity10,
	isnull(Quantity11,0) as Quantity11,
	isnull(Quantity12,0) as Quantity12,
	CurrencyCode,
	Date 
FROM ANNUAL_BUDGET_IMPORT_DETAILS BID	
WHERE IdImport = @IdImport

GO

--Drops the Procedure impSelectAnnualImportDetailsHeader if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectAnnualImportDetailsHeader]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectAnnualImportDetailsHeader
GO
CREATE PROCEDURE impSelectAnnualImportDetailsHeader
(
	@IdImport INT
)

AS

DECLARE @Semaphore nvarchar(1)
DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

SELECT @Semaphore=Validation FROM ANNUAL_BUDGET_IMPORT_LOGS WHERE IDIMPORT=@IdImport
-- PRINT @SEMAPHORE


IF @Semaphore=N'R'
BEGIN
	SELECT 
	C.[Name]			AS	'Country',
	I.[FileName]			AS	'FileName',
	I.ImportDate			AS	'Date',
	IL.[Year]				AS	'Period',
	[ASC].[Name]			AS	'UserName',
	0				AS	'Lines'
	FROM ANNUAL_BUDGET_IMPORT_LOGS AS IL
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN 
	(select IdImport, IdRow from ANNUAL_BUDGET_IMPORT_DETAILS where IdImport=@IdImport union 
		SELECT  IdImport, IdRow FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS WHERE IdImport = @IdImport 
		and Details like '%not numeric%') ID
		ON IL.IdImport = Id.IDImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	LEFT JOIN COUNTRIES AS C
		ON SUBSTRING(I.[FileName],1,3) = C.Code
	WHERE IL.IdImport = @IdImport
	GROUP BY C.[Name], I.[FileName], I.ImportDate, IL.[Year], [ASC].[Name]
	
	SELECT COUNT(idRow) AS 'NoOfErrors' 
	FROM [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS] 
	WHERE idimport = @IdImport

	SELECT 0 as 'NoOfRowsOk'
END
ELSE
BEGIN


SELECT @ROWCOUNTDELETED_CC =ExclusionCostCenterRowsNo,
	@ROWCOUNTDELETED_GL=ExclusionGlAccountsRowsNo
FROM ANNUAL_BUDGET_IMPORTS
WHERE IDIMPORT = @IdImport

-- PRINT @ROWCOUNTDELETED_CC
-- PRINT @ROWCOUNTDELETED_GL

	SELECT 
	C.[Name]							AS	'Country',
	I.[FileName]							AS	'FileName',
	I.ImportDate							AS	'Date',
	IL.[Year]								AS	'Period',
	[ASC].[Name]							AS	'UserName',
	COUNT (ID.IdRow) + @ROWCOUNTDELETED_CC + @ROWCOUNTDELETED_GL	AS	'Lines'	
	FROM ANNUAL_BUDGET_IMPORT_LOGS AS IL
	INNER JOIN ANNUAL_BUDGET_IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ANNUAL_BUDGET_IMPORT_DETAILS ID
		ON IL.IdImport = Id.IDImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	LEFT JOIN COUNTRIES AS C
		ON SUBSTRING(I.[FileName],1,3) = C.Code
	WHERE IL.IdImport = @IdImport
	GROUP BY C.[Name], I.[FileName], I.ImportDate, IL.[Year], [ASC].[Name]

	SELECT COUNT(idRow) AS 'NoOfErrors' 
	FROM [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS] 
	WHERE idimport = @IdImport

	SELECT COUNT(IdImport)  AS 'NoOfRowsOk'
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE IMD.IDIMPORT=@IdImport
	AND NOT EXISTS(	SELECT Id 
			FROM ANNUAL_BUDGET_IMPORT_LOGS_DETAILS ILD 
			WHERE ILD.IDIMPORT = IMD.IDIMPORT AND 
			ILD.IdROW = IMD.IDROW
		      )	

END
GO


--Drops the Procedure impSelectAnnualImports if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectAnnualImports]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectAnnualImports
GO
CREATE PROCEDURE impSelectAnnualImports
(
	@IdImport INT
)

AS


	IF(@IdImport >0)
	BEGIN
		SELECT [IdImport], [ImportDate], [FileName]
		FROM [ANNUAL_BUDGET_IMPORTS]
		WHERE IdImport = @IdImport
			
	END
	ELSE
	BEGIN
		SELECT [IdImport], [ImportDate], [FileName]
		FROM [ANNUAL_BUDGET_IMPORTS]
	END

GO
--Drops the Procedure impSelectDataLogs if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectDataLogs]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectDataLogs
GO
CREATE PROCEDURE impSelectDataLogs
	@CountryCode AS varchar(5) --the code of the country
AS
IF @CountryCode IS NULL
	SELECT 
		IL.YearMonth			AS	'YearMonth',
		ISRC.SourceName			AS	'ApplicationName',
		I.[FileName]			AS	'FileName',
		I.ImportDate			AS	'Date',
		SUBSTRING(I.[FileName],4,3)	AS	'CountryCode',
		[ASC].[Name]			AS	'UserName',
		IL.Validation			AS	'Validation',
		I.IdImport			AS	'IdImport',
		I.IdAssociate			AS	'IdUser'
	FROM IMPORT_LOGS AS IL
	INNER JOIN IMPORT_SOURCES AS ISRC ON
		IL.IdSource = ISRC.[Id]
	INNER JOIN IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	ORDER BY IdImport DESC

ELSE
	SELECT 
		IL.YearMonth			AS	'YearMonth',
		ISRC.SourceName			AS	'ApplicationName',
		I.[FileName]			AS	'FileName',
		I.ImportDate			AS	'Date',
		SUBSTRING(I.[FileName],4,3)	AS	'CountryCode',
		[ASC].[Name]			AS	'UserName',
		IL.Validation			AS	'Validation',
		I.IdImport			AS	'IdImport',
		I.IdAssociate			AS	'IdUser'
	FROM IMPORT_LOGS AS IL
	INNER JOIN IMPORT_SOURCES AS ISRC ON
		IL.IdSource = ISRC.[Id]
	INNER JOIN IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN ASSOCIATES AS [ASC] ON 
		I.IdAssociate = [ASC].Id
	INNER JOIN IMPORT_SOURCES_COUNTRIES AS ISC ON 
		IL.IdSource = ISC.IdImportSource
	INNER JOIN COUNTRIES AS C ON 
		ISC.IdCountry = C.Id
	WHERE C.Code = @CountryCode
	ORDER BY IdImport DESC

	RETURN 1
GO
	
		
--Drops the Procedure bgtGetDataLogsDetail if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectDataLogsDetail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectDataLogsDetail
GO
CREATE PROCEDURE impSelectDataLogsDetail
	@IdImport INT
AS


	SELECT 	
		ILD.IdRow	AS 'RowNo',
		ILD.Details 	AS 'Details',
		Module		AS 'Module'
	FROM IMPORT_LOGS_DETAILS AS ILD
	WHERE ILD.IdImport = @IdImport
	ORDER BY ILD.IdRow

	RETURN 1
GO

--Drops the Procedure impSelectDataStatus if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectDataStatus]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectDataStatus
GO
CREATE PROCEDURE impSelectDataStatus
	@Year	AS	INT
AS
	SELECT 				  0 as IdImport,
						  IMS.SourceName 	AS	'Country',
					  	  0 AS  'January',
					  	  0 AS  'February',
					  	  0 AS  'March',
					  	  0 AS  'April',
					  	  0 AS  'May',
					  	  0 AS  'June',
					  	  0 AS  'July',
					  	  0 AS  'August',
					  	  0 AS  'September',
					  	  0 AS  'October',
					  	  0 AS  'November',
					  	  0 AS  'December',
			IMS.Rank AS Rank
	INTO #DataLogs
	FROM IMPORT_SOURCES IMS
	WHERE Active = 1


	UPDATE a
	SET 
		January = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 1 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)

	UPDATE a
	SET 
		February = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 2 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)

	UPDATE a
	SET 
		March = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 3 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		April = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 4 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)

	UPDATE a
	SET 
		May = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 5 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		June = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 6 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		July = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 7 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		August = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 8 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName 
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		September = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 9 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName  
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		October = 1, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 10 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName  
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)


	UPDATE a
	SET 
		November = 11, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 11 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName  
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)

	UPDATE a
	SET 
		December = 12, IdImport = IL.IdImport
	from #DataLogs a
	join IMPORT_LOGS IL on IL.YearMonth / 100 = @Year AND IL.YearMonth % 100 = 12 AND IL.Validation = 'G'
	INNER JOIN IMPORT_SOURCES AS IMS ON IMS.Id = IL.IdSource
	where a.Country = IMS.SourceName  
	--and not exists(select IdImport from IMPORT_LOGS x INNER JOIN IMPORT_SOURCES y ON y.Id = x.IdSource where YearMonth / 100 > @Year and Validation = 'G' and  y.SourceName = a.Country)

	SELECT IdImport,
		   Country,
		   January,
		   February,
		   March,
		   April,
		   May,
		   June,
		   July,
		   August,
		   September,
		   October,
		   November,
		   December
	FROM #DataLogs
	ORDER BY Rank

GO--delete impSelectImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.impSelectImportDetails') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportDetails
GO

-- impSelectImportDetails 447
CREATE PROCEDURE impSelectImportDetails
(
	@IdImport INT
)
AS
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

SELECT * FROM
(
	SELECT 	IMPD.IdImport,
			IMPD.IdRow,
			IMPD.CostCenter, 
			IMPD.ProjectCode, 
			P.ID AS ProjectID, 
			IMPD.WPCode,
	       		IMPD.AccountNumber, 
			IMPD.AssociateNumber, 
			IMPD.Quantity, 
			IMPD.UnitQty,
	       		IMPD.Value, 
			IMPD.CurrencyCode 
		-- 	IMPD.Date
	FROM IMPORT_DETAILS IMPD
	LEFT JOIN PROJECTS P
	 ON IMPD.ProjectCode = P.CODE
		INNER JOIN IMPORT_LOGS_DETAILS IMPL
			on IMPL.IdImport = IMPD.IdImport and 
			   IMPL.IdRow = IMPD.IdRow and
			   IMPL.Id = (SELECT MIN(id) 
					  FROM IMPORT_LOGS_DETAILS ild
					  WHERE ild.idImport = impl.idImport and
						ild.IdRow = impl.idRow)
	WHERE IMPD.IdImport = @IdImport

	UNION ALL

	SELECT 	IMKM.IdImport,
			IMKM.IdRow,
			IMKM.CostCenter, 
			IMKM.ProjectCode, 
			P.ID AS ProjectID, 
			IMKM.WPCode,
	       		IMKM.AccountNumber, 
			IMKM.AssociateNumber, 
			IMKM.Quantity, 
			IMKM.UnitQty,
	       		IMKM.Value, 
			IMKM.CurrencyCode 
		-- 	IMPD.Date
	FROM IMPORT_DETAILS_KEYROWS_MISSING IMKM
	LEFT JOIN PROJECTS P
	 ON IMKM.ProjectCode = P.CODE
		INNER JOIN IMPORT_LOGS_DETAILS_KEYROWS_MISSING IMPL
			on IMPL.IdImport = IMKM.IdImport and 
			   IMPL.IdRow = IMKM.IdRow and
			   IMPL.Id = (SELECT MIN(id) 
					FROM IMPORT_LOGS_DETAILS_KEYROWS_MISSING ild
					  WHERE ild.idImport = impl.idImport and
						ild.IdRow = impl.idRow)
	WHERE IMKM.IdImport = @IdImport

) AS S
ORDER BY S.IdRow
GO



--Drops the Procedure impSelectImportDetailsErrors if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.impSelectImportDetailsErrors') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportDetailsErrors
GO

-- impSelectImportDetailsErrors 77
CREATE PROCEDURE impSelectImportDetailsErrors
(
	@IdImport INT
)
AS
BEGIN
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

SELECT ERR.IdImport, ERR.IdRow, ERR.Id, 
	       ERR.Details, ERR.Module, ERR.ModuleName
FROM
(
	SELECT IMPD.IdImport, IMPD.IdRow, IMPD.Id, 
	       IMPD.Details, IMPD.Module, ISNULL(MDL.Name,'') AS ModuleName
	FROM IMPORT_LOGS_DETAILS IMPD (nolock)
	LEFT JOIN MODULES MDL
		on IMPD.Module = MDL.Code
	WHERE IdImport = @IdImport

UNION 

	SELECT ILDKM.IdImport, ILDKM.IdRow, ILDKM.Id, 
	       ILDKM.Details, ILDKM.Module, ISNULL(MDL.Name,'') AS ModuleName
	FROM IMPORT_LOGS_DETAILS_KEYROWS_MISSING ILDKM (nolock)
	LEFT JOIN MODULES MDL
		on ILDKM.Module = MDL.Code
	WHERE IdImport = @IdImport

) AS ERR
	ORDER BY ERR.IdImport, ERR.IdRow, ERR.Id
END
GO


--Drops the Procedure impSelectImportDetailsForExport if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.impSelectImportDetailsForExport') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportDetailsForExport
GO

-- exec impSelectImportDetailsForExport 451

CREATE PROCEDURE impSelectImportDetailsForExport
(
	@IdImport INT
)
AS
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END


SELECT 	IdImport,
	IdRow, 
	Country, 
	Year, 
	Month, 
	CostCenter, 
	ProjectCode, 
	WPCode,
       	AccountNumber, 
	AssociateNumber, 
	Quantity, 
	UnitQty,
       	Value, 
	CurrencyCode,
	[Date]
FROM IMPORT_DETAILS IMPD
WHERE IdImport = @IdImport

UNION

SELECT 	IdImport,
	IdRow, 
	Country, 
	Year, 
	Month, 
	CostCenter, 
	ProjectCode, 
	WPCode,
       	AccountNumber, 
	AssociateNumber, 
	Quantity, 
	UnitQty,
       	Value, 
	CurrencyCode,
	[Date]
FROM IMPORT_DETAILS_KEYROWS_MISSING
WHERE IdImport = @IdImport

GO


--Drops the Procedure impSelectImportDetailsHeader if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectImportDetailsHeader]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportDetailsHeader
GO
CREATE PROCEDURE impSelectImportDetailsHeader
(
	@IdImport INT
)

AS

DECLARE @Semaphore nvarchar(1)
DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT,
	@NoOfErrors int

SELECT @Semaphore=Validation FROM IMPORT_LOGS WHERE IDIMPORT=@IdImport

IF @Semaphore=N'R'
BEGIN
	SELECT 
	C.[Name]			AS	'Country',
	I.[FileName]			AS	'FileName',
	I.ImportDate			AS	'Date',
	IL.YearMonth			AS	'Period',
	[ASC].[Name]			AS	'UserName',
	0				AS	'Lines',
	IL.IdSource			AS	'IdSource'
	FROM IMPORT_LOGS AS IL
	INNER JOIN IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN IMPORT_DETAILS ID
		ON IL.IdImport = Id.IDImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	LEFT JOIN COUNTRIES AS C
		ON SUBSTRING(I.[FileName],4,3) = C.Code
	WHERE IL.IdImport =@IdImport
	GROUP BY C.[Name], I.[FileName], I.ImportDate, IL.YearMonth, [ASC].[Name], IL.IdSource
	
	SELECT @NoOfErrors = COUNT(idRow) 
	FROM [IMPORT_LOGS_DETAILS] 
	WHERE idimport = @IdImport
		
	SELECT @NoOfErrors = @NoOfErrors + COUNT(idRow)
	FROM [IMPORT_LOGS_DETAILS_KEYROWS_MISSING] 
	WHERE idimport = @IdImport
	SELECT @NoOfErrors AS 'NoOfErrors'

	SELECT 0 as 'NoOfRowsOk'
END
ELSE
BEGIN


SELECT @ROWCOUNTDELETED_CC =ExclusionCostCenterRowsNo,
	@ROWCOUNTDELETED_GL=ExclusionGlAccountsRowsNo
FROM IMPORTS
WHERE IDIMPORT = @IdImport

-- PRINT @ROWCOUNTDELETED_CC
-- PRINT @ROWCOUNTDELETED_GL

	SELECT 
	C.[Name]							AS	'Country',
	I.[FileName]							AS	'FileName',
	I.ImportDate							AS	'Date',
	IL.YearMonth							AS	'Period',
	[ASC].[Name]							AS	'UserName',
	COUNT (ID.IdRow) + @ROWCOUNTDELETED_CC + @ROWCOUNTDELETED_GL	AS	'Lines',
	IL.IdSource							AS	'IdSource'
	FROM IMPORT_LOGS AS IL
	INNER JOIN IMPORTS AS I ON 
		IL.IdImport = I.IdImport
	INNER JOIN IMPORT_DETAILS ID
		ON IL.IdImport = Id.IDImport
	INNER JOIN ASSOCIATES AS [ASC]
		ON I.IdAssociate = [ASC].Id
	LEFT JOIN COUNTRIES AS C
		ON SUBSTRING(I.[FileName],4,3) = C.Code
	WHERE IL.IdImport =@IdImport
	GROUP BY C.[Name], I.[FileName], I.ImportDate, IL.YearMonth, [ASC].[Name], IL.IdSource

	SELECT @NoOfErrors = COUNT(idRow) 
	FROM [IMPORT_LOGS_DETAILS] 
	WHERE idimport = @IdImport
		
	SELECT @NoOfErrors = @NoOfErrors + COUNT(idRow)
	FROM [IMPORT_LOGS_DETAILS_KEYROWS_MISSING] 
	WHERE idimport = @IdImport
	SELECT @NoOfErrors AS 'NoOfErrors'

	SELECT COUNT(IdImport)  AS 'NoOfRowsOk'
	FROM IMPORT_DETAILS IMD
	WHERE IMD.IDIMPORT=@IdImport
	AND NOT EXISTS(	SELECT Id 
			FROM IMPORT_LOGS_DETAILS ILD 
			WHERE ILD.IDIMPORT = IMD.IDIMPORT AND 
			ILD.IdROW = IMD.IDROW
		      )	
	AND NOT EXISTS(	SELECT Id 
			FROM IMPORT_LOGS_DETAILS_KEYROWS_MISSING ILD 
			WHERE ILD.IDIMPORT = IMD.IDIMPORT AND 
			ILD.IdROW = IMD.IDROW
		      )	
END
GO

--Drops the Procedure impSelectImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'dbo.impSelectImportDetailsKeyRowsMissing') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportDetailsKeyRowsMissing
GO

-- impSelectImportDetails 77
CREATE PROCEDURE impSelectImportDetailsKeyRowsMissing
(
	@IdImport INT
)
AS
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

--we select all the records of the import
SELECT 	IDKRM.IdImport,
	IDKRM.IdRow,
	IDKRM.IdImportPrevious,
	IDKRM.Country,
	IDKRM.[Year],
	IDKRM.[Month],
	IDKRM.CostCenter, 
	IDKRM.ProjectCode, 
	IDKRM.WPCode,
       	IDKRM.AccountNumber, 
	IDKRM.AssociateNumber, 
	IDKRM.Quantity, 
	IDKRM.UnitQty,
       	IDKRM.Value, 
	IDKRM.CurrencyCode,
	GETDATE() as [Date]
FROM IMPORT_DETAILS_KEYROWS_MISSING IDKRM (holdlock)
WHERE IDKRM.IdImport = @IdImport
ORDER BY IDKRM.IdRow

GO


--Drops the Procedure impSelectImports if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectImports]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImports
GO
CREATE PROCEDURE impSelectImports
(
	@IdImport INT
)

AS
	

	IF(@IdImport >0)
	BEGIN
		SELECT [IdImport], [ImportDate], [FileName], [IdAssociate] 
		FROM [IMPORTS]
		WHERE IdImport = @IdImport
			
	END
	ELSE
	BEGIN
		SELECT [IdImport], [ImportDate], [FileName], [IdAssociate] 
		FROM [IMPORTS]
	END

GO
--Drops the Procedure impSelectImportSource if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impSelectImportSource]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impSelectImportSource
GO
CREATE PROCEDURE impSelectImportSource

AS

	SELECT 
		ISR.[Id] AS 'Id', 
		ISR.[IdApplicationTypes] AS 'IdApplicationTypes',
		ISR.[Code] AS 'Code', 
		ISR.[SourceName] AS 'SourceName', 
		CAST(ISR.ID as NVARCHAR(10)) + '|' + IAP.Name AS 'IdCodeName'
	FROM [IMPORT_SOURCES] ISR INNER JOIN IMPORT_APPLICATION_TYPES IAP
		ON ISR.IdApplicationTypes = IAP.ID
	WHERE 	Active = 1
	ORDER BY Rank ASC

GO




--Drops the Procedure impUpdateAnnualImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impUpdateAnnualImportDetails]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impUpdateAnnualImportDetails
GO
CREATE PROCEDURE impUpdateAnnualImportDetails
(
	@IdImport INT,
	@IdRow	INT,
	--@Country VARCHAR(3),
	--@Year INT,
	--@Month INT,
	@CostCenter VARCHAR(10),
	@ProjectCode VARCHAR(10),
	@WPCode VARCHAR(4),
	@AccountNumber NVARCHAR(20),
	@Quantity DECIMAL,
	@Value DECIMAL,
	@CurrencyCode VARCHAR(3),
	@Date SMALLDATETIME
)

AS
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No row selected',16,1)		
		RETURN -2
	END

	
	UPDATE [ANNUAL_BUDGET_IMPORT_DETAILS]
	SET 
-- 		[Country]=@Country, 
-- 		[Year]=@Year, 
-- 		[Month]=@Month, 
		[CostCenter]=@CostCenter, 
		[ProjectCode]=@ProjectCode, 
		[WPCode]=@WPCode, 
		[AccountNumber]=@AccountNumber, 
		--[Quantity]=@Quantity, 
		--[Value]=@Value, 
		[CurrencyCode]=@CurrencyCode, 
		[Date]=@Date
	WHERE IdImport = @IdImport AND IdRow = @IdRow


GO

--Drops the Procedure impUpdateImportDetails if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impUpdateImportDetails]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impUpdateImportDetails
GO
CREATE PROCEDURE impUpdateImportDetails
(
	@IdImport INT,
	@IdRow	INT,
	@CostCenter VARCHAR(10),
	@ProjectCode VARCHAR(10),
	@WPCode VARCHAR(4),
	@AccountNumber NVARCHAR(20),
	@AssociateNumber VARCHAR(15),
	@Quantity DECIMAL,
	@UnitQty varchar(4),
	@Value DECIMAL,
	@CurrencyCode VARCHAR(3)
)

AS
	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No import selected',16,1)		
		RETURN -1
	END

	IF (@IdImport is null )
	BEGIN 
		RAISERROR('No row selected',16,1)		
		RETURN -2
	END

	
	UPDATE [IMPORT_DETAILS]
	SET 
		[CostCenter]=@CostCenter, 
		[ProjectCode]=@ProjectCode, 
		[WPCode]=@WPCode, 
		[AccountNumber]=@AccountNumber, 
		[AssociateNumber]=@AssociateNumber, 
		[Quantity]=@Quantity, 
		[UnitQty]=@UnitQty, 
		[Value]=@Value, 
		[CurrencyCode]=@CurrencyCode
	WHERE IdImport = @IdImport AND IdRow = @IdRow

	UPDATE [IMPORT_DETAILS_KEYROWS_MISSING]
	SET 
		[CostCenter]=@CostCenter, 
		[ProjectCode]=@ProjectCode, 
		[WPCode]=@WPCode, 
		[AccountNumber]=@AccountNumber, 
		[AssociateNumber]=@AssociateNumber, 
		[Quantity]=@Quantity, 
		[UnitQty]=@UnitQty, 
		[Value]=@Value, 
		[CurrencyCode]=@CurrencyCode
	WHERE IdImport = @IdImport AND IdRow = @IdRow


GO

--Drops the Procedure impUploadErrorsToLogTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impUploadErrorsToLogTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impUploadErrorsToLogTables
GO


CREATE    PROCEDURE impUploadErrorsToLogTables
	@fileName 	nvarchar(400), 	--The name of the file	
	@IdAssociate INT,		--ID of the associate
	@Message nvarchar(255),		-- the upload error
	 @IdSource INT			-- ID of source application
AS

IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

DECLARE @RealFileName nvarchar(100)
Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)

	IF (@IdSource=-1)
	BEGIN
		RAISERROR('File in wrong format: no id source!',16,1)		
		RETURN -2
	END

--fill imports table
DECLARE @IDIMPORT INT
SELECT @IDIMPORT  = ISNULL(MAX(IdImport),0)+1 
FROM IMPORTS (TABLOCKX)

DECLARE @YEARMONTH INT
-- DON'T USE THE YEARMONTH FROM FILENAME CAUSE NAME MIGHT BE IN WRONG FORMAT. INSTEAD USE DEFAULT
SET @YEARMONTH = '190001'
-- 	SET @YEARMONTH=SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),3,4) + 
-- 	SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),1,2)

INSERT INTO [IMPORTS]([IdImport], [ImportDate], [FileName], [IdAssociate], [ExclusionCostCenterRowsNo], [ExclusionGlAccountsRowsNo])
VALUES(@IDIMPORT, GETDATE(), @RealFileName, @IdAssociate, 0, 0)


INSERT INTO [IMPORT_DETAILS]([IdImport], [IdRow])
VALUES(@IDIMPORT, 1)

INSERT INTO [IMPORT_LOGS]([IdImport], [IdSource], [YearMonth], [Validation])
VALUES(@IDIMPORT, @IdSource, @YEARMONTH, 'R')

INSERT INTO [IMPORT_LOGS_DETAILS]([IdImport], [IdRow], [Details])
VALUES(@IDIMPORT, 1, @Message)



GO

--Drops the Procedure impWriteActualTableCosts if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteActualTableCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteActualTableCosts
GO

CREATE     PROCEDURE impWriteActualTableCosts
@IdImport INT			-- ID of the import
	
AS

Declare @YearMonth int,
	@strError varchar(255)

SELECT @YearMonth = IL.YearMonth
FROM IMPORT_LOGS IL
WHERE IL.IdImport = @IdImport

IF (@YearMonth IS NULL) 
BEGIN
	SET @strError = 'Import with id '+ cast(@IdImport as varchar(10)) +' does not exists in the database.'
	RAISERROR(@strError, 16, 1)
	return -1
END

--prepare the null associates table per country
DECLARE @CountryCode varchar (3)
DECLARE @NULLASSOCIATES TABLE
(
	CountryCode		varchar(3)  NOT NULL,
	NullAssociateId		int 	    NULL,
	NullEmployeeNumber	varchar(15) NULL
)

INSERT INTO @NULLASSOCIATES
	(CountryCode, NullAssociateId, NullEmployeeNumber)
SELECT Country,
       dbo.fnGetNullAssociateId(Country),
       null
FROM IMPORT_DETAILS
WHERE IdImport = @IdImport
GROUP BY Country

SELECT TOP 1 @CountryCode = CountryCode
FROM @NULLASSOCIATES
where NullAssociateId is null

IF (@CountryCode IS NOT NULL)
BEGIN
	RAISERROR('No null associate found for country %s.', 16, 1, @COUNTRYCODE)
	RETURN -1
END

UPDATE @NULLASSOCIATES
SET NullEmployeeNumber = EmployeeNumber
FROM @NULLASSOCIATES
INNER JOIN ASSOCIATES A
	ON NullAssociateId = A.Id



INSERT INTO [ACTUAL_DATA_DETAILS_COSTS]
(
	[IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter]
	, [YearMonth], [IdAssociate], [IdCostType], [IdCountry]
	, [CostVal], [IdAccount], [DateImport], [IdImport]
)
SELECT
	WP.IdProject ,WP.IdPhase ,WP.Id ,CC.Id
	,@YearMonth ,A.Id ,dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber) 
	,C.Id
	,ISNULL(IMD.Value,0) - ISNULL((SELECT SUM(ISNULL(ADC.CostVal,0))
				      FROM ACTUAL_DATA_DETAILS_COSTS ADC 
				      WHERE ADC.IdProject = WP.IdProject AND
					    ADC.IdPhase = WP.IdPhase AND
					    ADC.IdWorkPackage =WP.Id AND
					    ADC.IdCostCenter = CC.Id  AND
					    ADC.YearMonth/100 = @YearMonth/100 AND -- check only year
					    ADC.IdAssociate = A.Id AND
					    ADC.IdCountry = C.Id AND
					    ADC.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0)
	,dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)
	,IMD.[Date]
	,@IdImport
FROM IMPORT_DETAILS IMD
INNER JOIN PROJECTS P 
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON P.ID = WP.IdProject AND
	IMD.WPCode = WP.Code
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber
WHERE   dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber) BETWEEN 1 AND 5 AND		       
	IMD.IdImport = @IdImport AND
	IMD.AssociateNumber IS NOT NULL


DECLARE @IMPORT_NULL_ASSOCIATES TABLE
(
	Country VARCHAR(3),
	CostCenter VARCHAR(10),
	ProjectCode VARCHAR(10),
	WPCode VARCHAR(4),
	AccountNumber NVARCHAR(10),
	AssociateNumber VARCHAR(15),
	Quantity DECIMAL(18,2),
	UnitQty VARCHAR(4),
	[Value] DECIMAL(18,2),
	CurrencyCode VARCHAR(3),
	[Date] SMALLDATETIME
)

INSERT INTO @IMPORT_NULL_ASSOCIATES
(Country, CostCenter, ProjectCode, 
WPCode,AccountNumber, AssociateNumber, Quantity, UnitQty,
[Value], CurrencyCode, [Date])
SELECT 	IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber,
	MAX(NA.NullEmployeeNumber),
	SUM(IMD.Quantity),
	MAX(ISNULL(IMD.UnitQty,'')),
	SUM(IMD.Value),
	MAX(IMD.CurrencyCode),
	MAX(IMD.[Date])
FROM IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN @NULLASSOCIATES NA
	ON IMD.Country = NA.CountryCode
WHERE   IMD.IdImport = @IdImport AND
	dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber) BETWEEN 1 AND 5 AND
	IMD.AssociateNumber IS NULL--take only records that doesn't have valid associate ids
GROUP BY IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber


INSERT INTO [ACTUAL_DATA_DETAILS_COSTS]
(
	[IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter]
	, [YearMonth], [IdAssociate], [IdCostType], [IdCountry]
	, [CostVal], [IdAccount], [DateImport], [IdImport]
)
SELECT
	WP.IdProject ,WP.IdPhase ,WP.Id ,CC.Id
	,@YearMonth ,A.Id ,dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber) 
	,C.Id
	,ISNULL(IMD.Value,0) - ISNULL((SELECT SUM(ISNULL(ADC.CostVal,0))
					FROM ACTUAL_DATA_DETAILS_COSTS ADC 
					WHERE ADC.IdProject = WP.IdProject AND
					      ADC.IdPhase = WP.IdPhase AND
					      ADC.IdWorkPackage =WP.Id AND
					      ADC.IdCostCenter = CC.Id  AND
					      ADC.YearMonth/100  = @YearMonth/100 AND -- check only year 
					      ADC.IdAssociate = A.Id AND
					      ADC.IdCountry = C.Id AND
					      ADC.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0)
		
	,dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)
	,ISNULL(IMD.[Date], GETDATE())
	,@IdImport
FROM @IMPORT_NULL_ASSOCIATES IMD
INNER JOIN Projects P 
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON P.ID = WP.IdProject AND
	IMD.WPCode = WP.Code
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber



-- delete the rows that obtained 0 by calculating MTD from YTD
-- these rows have value not null for previous periods of the same year
DELETE A
FROM ACTUAL_DATA_DETAILS_COSTS A
WHERE IdImport = @IdImport and
	  CostVal = 0 AND
      (SELECT SUM(CostVal)
	  FROM ACTUAL_DATA_DETAILS_COSTS
	  WHERE IdProject = A.IdProject AND 
			  IdPhase = A.IdPhase AND 
			  IdWorkPackage = A.IdWorkPackage AND
			  IdCostCenter = A.IdCostCenter AND
			  IdAssociate = A.IdAssociate AND
			  IdCountry = A.IdCountry AND
			  IdAccount = A.IdAccount AND
			  YearMonth/100 = A.YearMonth/100 AND
			  YearMonth < A.YearMonth) IS NOT NULL


GO


--Drops the Procedure impWriteActualTableHours if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteActualTableHours]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteActualTableHours

GO

CREATE PROCEDURE impWriteActualTableHours
	@IdImport INT
AS

Declare @IdSource int,
	@YearMonth int,
	@strError varchar(255)

SELECT @IdSource = IL.IdSource,
	@YearMonth = IL.YearMonth
FROM IMPORT_LOGS IL
WHERE IL.IdImport = @IdImport

IF (@IdSource IS NULL) 
BEGIN
	SET @strError = 'Import with id '+ cast(@IdImport as varchar(10)) +' does not exists in the database.'
	RAISERROR(@strError, 16, 1)
	return -1
END

--prepare the null associates table per country
DECLARE @CountryCode varchar (3)
DECLARE @NULLASSOCIATES TABLE
(
	CountryCode		varchar(3)  NOT NULL,
	NullAssociateId		int 	    NULL,
	NullEmployeeNumber	varchar(15) NULL
)

INSERT INTO @NULLASSOCIATES
	(CountryCode, NullAssociateId, NullEmployeeNumber)
SELECT Country,
       dbo.fnGetNullAssociateId(Country),
       null
FROM IMPORT_DETAILS
WHERE IdImport = @IdImport
GROUP BY Country

SELECT TOP 1 @CountryCode = CountryCode
FROM @NULLASSOCIATES
where NullAssociateId is null

IF (@CountryCode IS NOT NULL)
BEGIN
	RAISERROR('No null associate found for country %s.', 16, 1, @COUNTRYCODE)
	RETURN -1
END

UPDATE @NULLASSOCIATES
SET NullEmployeeNumber = EmployeeNumber
FROM @NULLASSOCIATES
INNER JOIN ASSOCIATES A
	ON NullAssociateId = A.Id

--read the cost type account
DECLARE @IdCostTypeHours INT
SELECT @IdCostTypeHours = dbo.fnGetHoursCostTypeID()

--read the application type that did the CSV file
DECLARE @Application_Type_Name NVARCHAR(3)
SELECT @Application_Type_Name = [NAME] 
FROM IMPORT_APPLICATION_TYPES IAT
INNER JOIN IMPORT_SOURCES [IS]
	ON IAT.Id = [IS].IdApplicationTypes
WHERE [IS].Id = @IdSource





INSERT INTO [ACTUAL_DATA_DETAILS_HOURS]
	([IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter], 
	[YearMonth], [IdAssociate], [IdCountry], [IdAccount], 
	[HoursQty], [HoursVal], [DateImport], [IdImport])
SELECT	P.Id, WP.IdPhase, WP.Id, CC.Id,
	 @YearMonth, A.Id, C.Id, dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber),
	ISNULL(IMD.Quantity,0) - ISNULL((SELECT SUM(ISNULL(ADH.HoursQty,0))
					FROM ACTUAL_DATA_DETAILS_HOURS ADH 
					WHERE ADH.IdProject = WP.IdProject AND
					      ADH.IdPhase = WP.IdPhase AND
					      ADH.IdWorkPackage =WP.Id AND
					      ADH.IdCostCenter = CC.Id AND
					      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
					      ADH.IdAssociate = A.Id AND	
					      ADH.IdCountry = C.Id AND
					      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)), 0),

	CASE WHEN (@Application_Type_Name ='NET' AND IMD.Quantity <> 0)
	THEN dbo.fnGetValuedHours(CC.Id, 
		ISNULL(IMD.Quantity,0) - ISNULL((SELECT SUM(ISNULL(ADH.HoursQty,0)) 
						FROM ACTUAL_DATA_DETAILS_HOURS ADH 
						WHERE ADH.IdProject = WP.IdProject AND
						      ADH.IdPhase = WP.IdPhase AND
						      ADH.IdWorkPackage =WP.Id AND
						      ADH.IdCostCenter = CC.Id AND
						      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
						      ADH.IdAssociate = A.Id AND	
						      ADH.IdCountry = C.Id AND
						      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0),@YearMonth)
	ELSE
	 ISNULL(IMD.Value,0) - ISNULL((SELECT (SUM(ISNULL(ADH.HoursVal,0))) 
					  FROM ACTUAL_DATA_DETAILS_HOURS ADH 
					  WHERE ADH.IdProject = WP.IdProject AND
					      ADH.IdPhase = Wp.IdPhase AND
					      ADH.IdWorkPackage =WP.Id AND
					      ADH.IdCostCenter = CC.Id AND
					      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
					      ADH.IdAssociate = A.Id AND			      
					      ADH.IdCountry = C.Id AND
					      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0)
	END,
	ISNULL(IMD.[Date], GETDATE()),
	@IdImport
FROM IMPORT_DETAILS IMD
INNER JOIN PROJECTS P
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = P.ID AND 
	   WP.Code = IMD.WPCode
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber
WHERE  IMD.IdImport = @IdImport AND
       dbo.fnGetBudgetCostType(C.ID,IMD.AccountNumber)  = @IdCostTypeHours AND
	IMD.AssociateNumber IS NOT NULL -- only update the rows that have valid associatenumbers


-- 	TAKE NULL ASSOCIATE NUMBERS RECORDS
DECLARE @IMPORT_NULL_ASSOCIATES TABLE
(
	Country VARCHAR(3),
	CostCenter VARCHAR(10),
	ProjectCode VARCHAR(10),
	WPCode VARCHAR(4),
	AccountNumber NVARCHAR(10),
	AssociateNumber VARCHAR(15),
	Quantity DECIMAL(18,2),
	UnitQty VARCHAR(4),
	[Value] DECIMAL(18,2),
	CurrencyCode VARCHAR(3),
	[Date] SMALLDATETIME
)

-- insert into variable table with sumed values for nullassociates

INSERT INTO @IMPORT_NULL_ASSOCIATES
(Country, CostCenter, ProjectCode, 
WPCode,AccountNumber, AssociateNumber, Quantity, UnitQty,
[Value], CurrencyCode, [Date])
SELECT 	IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber,
	MAX(NA.NullEmployeeNumber),
	SUM(IMD.Quantity),
	MAX(ISNULL(IMD.UnitQty,'')),
	SUM(IMD.Value),
	MAX(IMD.CurrencyCode),
	MAX(IMD.[Date])
FROM IMPORT_DETAILS IMD
INNER JOIN @NULLASSOCIATES NA
	ON IMD.Country = NA.CountryCode
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
WHERE IMD.IdImport = @IdImport AND
      dbo.fnGetBudgetCostType(C.ID,IMD.AccountNumber)  = @IdCostTypeHours AND
      IMD.AssociateNumber IS NULL-- only take the rows that doesn't have valid associatenumbers
GROUP BY IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber


INSERT INTO [ACTUAL_DATA_DETAILS_HOURS]
	([IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter], 
	[YearMonth], [IdAssociate], [IdCountry], [IdAccount], 
	[HoursQty], [HoursVal], [DateImport], [IdImport])
SELECT
	P.Id, WP.IdPhase, WP.Id, CC.Id,
	@YearMonth, A.Id, C.Id,dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber),
	ISNULL(IMD.Quantity,0) - ISNULL((SELECT SUM(ISNULL(ADH.HoursQty,0)) 
					FROM ACTUAL_DATA_DETAILS_HOURS ADH 
					WHERE ADH.IdProject = WP.IdProject AND
					      ADH.IdPhase = WP.IdPhase AND
					      ADH.IdWorkPackage =WP.Id AND
					      ADH.IdCostCenter = CC.Id AND	      
					      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
					      ADH.IdAssociate = A.Id AND
					      ADH.IdCountry = C.Id AND
					      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0),

	CASE WHEN (@Application_Type_Name ='NET' AND IMD.Quantity <> 0)
	     THEN dbo.fnGetValuedHours(CC.Id,
		ISNULL(IMD.Quantity,0) - ISNULL((SELECT SUM(ISNULL(ADH.HoursQty,0))
						FROM ACTUAL_DATA_DETAILS_HOURS ADH 
						WHERE ADH.IdProject = WP.IdProject AND
						      ADH.IdPhase = WP.IdPhase AND
						      ADH.IdWorkPackage =WP.Id AND
						      ADH.IdCostCenter = CC.Id AND
						      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
						      ADH.IdAssociate = A.Id AND	
						      ADH.IdCountry = C.Id AND
						      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0),
						@YearMonth)
		ELSE
		 ISNULL(IMD.Value,0) - ISNULL((SELECT SUM(ISNULL(ADH.HoursVal,0))
						  FROM ACTUAL_DATA_DETAILS_HOURS ADH 
						  WHERE ADH.IdProject = WP.IdProject AND
						      ADH.IdPhase = Wp.IdPhase AND
						      ADH.IdWorkPackage =WP.Id AND
						      ADH.IdCostCenter = CC.Id AND
						      ADH.YearMonth/100 = @YearMonth/100 AND --check just year
						      ADH.IdAssociate = A.Id AND		     
						      ADH.IdCountry = C.Id AND
						      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0)
	      END,
	IMD.[Date],
	@IdImport

FROM 	@IMPORT_NULL_ASSOCIATES IMD
INNER JOIN PROJECTS P
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = P.ID AND 
	   WP.Code = IMD.WPCode
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber

-- delete the rows that obtained 0 by calculating MTD from YTD
-- these rows have either qty not null or value not null for previous periods of the same year
DELETE A
FROM ACTUAL_DATA_DETAILS_HOURS A
WHERE IdImport = @IdImport and
	  HoursQty = 0 AND
      HoursVal = 0 AND
       (((Select SUM(HoursQty)
	    from ACTUAL_DATA_DETAILS_HOURS
	    Where IdProject = A.IdProject AND 
		  IdPhase = A.IdPhase AND 
		  IdWorkPackage = A.IdWorkPackage AND
		  IdCostCenter = A.IdCostCenter AND
		  IdAssociate = A.IdAssociate AND
		  IdCountry = A.IdCountry AND
		  IdAccount = A.IdAccount AND
		  YearMonth/100 = A.YearMonth/100 AND
		  YearMonth < A.YearMonth) IS NOT NULL) OR
      ((Select SUM(HoursVal)
	    from ACTUAL_DATA_DETAILS_HOURS
	    Where IdProject = A.IdProject AND 
		  IdPhase = A.IdPhase AND 
		  IdWorkPackage = A.IdWorkPackage AND
		  IdCostCenter = A.IdCostCenter AND
		  IdAssociate = A.IdAssociate AND
		  IdCountry = A.IdCountry AND
		  IdAccount = A.IdAccount AND
		  YearMonth/100 = A.YearMonth/100 AND
		  YearMonth < A.YearMonth) IS NOT NULL))




GO

--Drops the Procedure impWriteActualTableSales if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteActualTableSales]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteActualTableSales

GO

CREATE     PROCEDURE impWriteActualTableSales
@IdImport INT			-- ID of the import
	
AS


Declare @YearMonth int,
	@strError varchar(255)

SELECT @YearMonth = IL.YearMonth
FROM IMPORT_LOGS IL
WHERE IL.IdImport = @IdImport

IF (@YearMonth IS NULL) 
BEGIN
	SET @strError = 'Import with id '+ cast(@IdImport as varchar(10)) +' does not exists in the database.'
	RAISERROR(@strError, 16, 1)
	return -1
END


DECLARE @IdCostTypeSales INT
SELECT @IdCostTypeSales = dbo.fnGetSalesCostTypeID()

--prepare the null associates table per country
DECLARE @CountryCode varchar (3)
DECLARE @NULLASSOCIATES TABLE
(
	CountryCode		varchar(3)  NOT NULL,
	NullAssociateId		int 	    NULL,
	NullEmployeeNumber	varchar(15) NULL
)

INSERT INTO @NULLASSOCIATES
	(CountryCode, NullAssociateId, NullEmployeeNumber)
SELECT Country,
       dbo.fnGetNullAssociateId(Country),
       null
FROM IMPORT_DETAILS
WHERE IdImport = @IdImport
GROUP BY Country

SELECT TOP 1 @CountryCode = CountryCode
FROM @NULLASSOCIATES
where NullAssociateId is null

IF (@CountryCode IS NOT NULL)
BEGIN
	RAISERROR('No null associate found for country %s.', 16, 1, @COUNTRYCODE)
	RETURN -1
END

UPDATE @NULLASSOCIATES
SET NullEmployeeNumber = EmployeeNumber
FROM @NULLASSOCIATES
INNER JOIN ASSOCIATES A
	ON NullAssociateId = A.Id

INSERT INTO [ACTUAL_DATA_DETAILS_SALES]
	([IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter], 
	[YearMonth], [IdAssociate], [IdCountry], [IdAccount],
	[SalesVal], [DateImport], [IdImport])
SELECT	P.Id, WP.IdPhase, WP.Id, CC.Id,
	@YearMonth, A.Id, C.Id, dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber),
	ISNULL(IMD.Value,0) - ISNULL((SELECT SUM(ISNULL(ADH.SalesVal,0))
					FROM ACTUAL_DATA_DETAILS_SALES ADH 
					WHERE ADH.IdProject = WP.IdProject AND
					      ADH.IdPhase = Wp.IdPhase AND
					      ADH.IdWorkPackage =WP.Id AND
					      ADH.IdCostCenter = CC.Id AND
					      ADH.YearMonth/100 = @YearMonth/100 AND
					      ADH.IdAssociate = A.Id AND
					      ADH.IdCountry = C.Id AND
				      	      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0),
	IMD.[Date],
	@IdImport

FROM IMPORT_DETAILS IMD
INNER JOIN Projects P 
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON IMD.WPCode = WP.Code AND 
	P.ID = WP.IdProject 
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber
WHERE  IMD.IdImport = @IdImport AND
	dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber)  = @IdCostTypeSales AND
	IMD.AssociateNumber IS NOT NULL--only take records with valid associate ids


DECLARE @IMPORT_NULL_ASSOCIATES TABLE
(
	Country VARCHAR(3),
	CostCenter VARCHAR(10),
	ProjectCode VARCHAR(10),
	WPCode VARCHAR(4),
	AccountNumber NVARCHAR(10),
	AssociateNumber VARCHAR(15),
	Quantity DECIMAL(18,2),
	UnitQty VARCHAR(4),
	[Value] DECIMAL(18,2),
	CurrencyCode VARCHAR(3),
	[Date] SMALLDATETIME
)


INSERT INTO @IMPORT_NULL_ASSOCIATES
(Country, CostCenter, ProjectCode, 
WPCode,AccountNumber, AssociateNumber, Quantity, UnitQty,
[Value], CurrencyCode, [Date])
SELECT 	IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber,
	MAX(NA.NullEmployeeNumber),
	SUM(IMD.Quantity),
	MAX(ISNULL(IMD.UnitQty,'')),
	SUM(IMD.Value),
	MAX(IMD.CurrencyCode),
	MAX(IMD.[Date])
FROM IMPORT_DETAILS IMD
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN @NULLASSOCIATES NA
	ON IMD.Country = NA.CountryCode
WHERE IMD.IdImport = @IdImport AND
      dbo.fnGetBudgetCostType(C.Id,IMD.AccountNumber)  = @IdCostTypeSales AND
      IMD.AssociateNumber IS NULL--take only records that doesn't have valid associate ids
GROUP BY IMD.Country,
	IMD.CostCenter,
	IMD.ProjectCode,
	IMD.WPCode,
	IMD.AccountNumber


INSERT INTO [ACTUAL_DATA_DETAILS_SALES]
	([IdProject], [IdPhase], [IdWorkPackage], [IdCostCenter], 
	[YearMonth], [IdAssociate], [IdCountry], [IdAccount],
	[SalesVal], [DateImport], [IdImport])
SELECT	
	P.Id, WP.IdPhase, WP.Id, CC.Id,
	@YearMonth, A.Id, C.Id, dbo.fnGetActualDetailIdAccount(C.Id, IMD.AccountNumber),
	ISNULL(IMD.Value,0) - ISNULL((SELECT SUM(ISNULL(ADH.SalesVal,0))
					FROM ACTUAL_DATA_DETAILS_SALES ADH 
					WHERE ADH.IdProject = WP.IdProject AND
					      ADH.IdPhase = WP.IdPhase AND
					      ADH.IdWorkPackage =WP.Id AND
					      ADH.IdCostCenter = CC.Id AND
					      ADH.YearMonth/100 = @YearMonth/100 AND
					      ADH.IdAssociate = A.Id AND
					      ADH.IdCountry = C.Id AND
				      	      ADH.IdAccount = dbo.fnGetActualDetailIdAccount(C.Id,IMD.AccountNumber)),0),
	ISNULL(IMD.[Date], GETDATE()),
	@IdImport
FROM 	@IMPORT_NULL_ASSOCIATES IMD
INNER JOIN PROJECTS P
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP
	ON WP.IdProject = P.ID AND 
	   WP.Code = IMD.WPCode
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN INERGY_LOCATIONS IL
	ON C.Id = IL.IdCountry
INNER JOIN COST_CENTERS CC 
	ON IL.Id = CC.IdInergyLocation and
	   IMD.CostCenter = CC.Code
INNER JOIN ASSOCIATES A
	ON C.Id = A.IdCountry AND
	   IMD.AssociateNumber = A.EmployeeNumber

-- delete the rows that obtained 0 by calculating MTD from YTD
-- these rows have value not null for previous periods of the same year
DELETE A
FROM ACTUAL_DATA_DETAILS_SALES A
WHERE IdImport = @IdImport and
	  SalesVal = 0 AND
      (SELECT SUM(SalesVal)
	  FROM ACTUAL_DATA_DETAILS_SALES
	  WHERE IdProject = A.IdProject AND 
			  IdPhase = A.IdPhase AND 
			  IdWorkPackage = A.IdWorkPackage AND
			  IdCostCenter = A.IdCostCenter AND
			  IdAssociate = A.IdAssociate AND
			  IdCountry = A.IdCountry AND
			  IdAccount = A.IdAccount AND
			  YearMonth/100 = A.YearMonth/100 AND
			  YearMonth < A.YearMonth) IS NOT NULL


GO
--Drops the Procedure impWriteAnnualTableDetailsCosts if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteAnnualTableDetailsCosts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteAnnualTableDetailsCosts
GO

CREATE PROCEDURE impWriteAnnualTableDetailsCosts
	@IdImport INT,			
	@SkipStartEndPhaseErrors bit = 0			
AS

declare @CurrentRow int,
	@CurrentMonth int,
	@CurrentMonth2 int

declare @IdProject	int,
	@IdPhase	int,
	@IdWorkPackage	int,
	@StartYearMonth	int,
	@EndYearMonth	int,
	@YearImport	int,	
	@IdCostCenter	int,
	@IdCostType	int,
	@IdCountry	int,
	@CostVal1	decimal(18,2),
	@CostVal2	decimal(18,2),
	@CostVal3	decimal(18,2),
	@CostVal4	decimal(18,2),
	@CostVal5	decimal(18,2),
	@CostVal6	decimal(18,2),
	@CostVal7	decimal(18,2),
	@CostVal8	decimal(18,2),
	@CostVal9	decimal(18,2),
	@CostVal10	decimal(18,2),
	@CostVal11	decimal(18,2),
	@CostVal12	decimal(18,2),
	@IdAccount	int,
	@DateImport	smalldatetime,
	@StartWPYear	int,
	@StartWPMonth	int,
	@EndWPYear	int,
	@EndWPMonth	int,
	@MonthCount	int,
	@EndMonth	int,
	@ErrStr 	varchar(200),
	@EndDevelopmentPhaseYM int,
	@StartDevelopmentPhaseYM int

declare @ProjectCode varchar(10)

DECLARE @Module varchar(10)
DECLARE @IdRow int,
		@Message varchar(510)
DECLARE @YEAR int
SELECT @YEAR = SUBSTRING([FileName], 4, 4) FROM ANNUAL_BUDGET_IMPORTS WHERE IdImport = @IdImport


CREATE TABLE #ImportBudgetAnnualDetailsCosts 
	(
	IdProject	int NOT NULL,
	IdPhase		int NOT NULL,
	IdWorkPackage	int NOT NULL,
	StartYearMonth	int,
	EndYearMonth	int,
	YearImport	int,
	IdCostCenter	int NOT NULL,
	IdCountry	int NOT NULL,
	IdAccount	int NOT NULL,
	IdCostType	int NOT NULL,
	CostVal1	decimal(18,2),
	CostVal2	decimal(18,2),
	CostVal3	decimal(18,2),
	CostVal4	decimal(18,2),
	CostVal5	decimal(18,2),
	CostVal6	decimal(18,2),
	CostVal7	decimal(18,2),
	CostVal8	decimal(18,2),
	CostVal9	decimal(18,2),
	CostVal10	decimal(18,2),
	CostVal11	decimal(18,2),
	CostVal12	decimal(18,2),
	DateImport	smalldatetime,
	IdRow		int NOT NULL,
	StartDevelopmentPhaseYM int,
	EndDevelopmentPhaseYM int
	)
declare @Command nvarchar(200)
set @Command = 'create index ImportBudgetAnnualDetails_IdRow_' + cast(@@SPID as varchar(10)) + ' on #ImportBudgetAnnualDetailsCosts (IdRow)'
exec(@Command)

INSERT INTO #ImportBudgetAnnualDetailsCosts
	(IdProject,
	IdPhase, 
	IdWorkPackage,
	StartYearMonth,	
	EndYearMonth,
	YearImport,
	IdCostCenter,
	IdCountry,
	IdAccount,
	IdCostType,
	CostVal1,
	CostVal2,
	CostVal3,
	CostVal4,
	CostVal5,
	CostVal6,
	CostVal7,
	CostVal8,
	CostVal9,
	CostVal10,
	CostVal11,
	CostVal12,
	DateImport,
	IdRow
	)
SELECT
	WP.IdProject,
	WP.IdPhase,
	WP.Id,
	case when PH.Code in ('1', '7') 
	then
		WP.StartYearMonth
	else 
		isnull(WP.StartYearMonth, IMD.Year*100 + 1)
	end,

	case when PH.Code in ('1', '7') 
	then
		WP.EndYearMonth
	else 
		isnull(WP.EndYearMonth, IMD.Year*100 + 12)
	end,
	IMD.Year,
	CC.Id,
	C.Id,
	dbo.fnGetActualDetailIdAccount(C.Id, IMD.AccountNumber),
	GL.IdCostType,
	isnull(IMD.Value1, 0),
	isnull(IMD.Value2, 0),
	isnull(IMD.Value3, 0),
	isnull(IMD.Value4, 0),
	isnull(IMD.Value5, 0),
	isnull(IMD.Value6, 0),
	isnull(IMD.Value7, 0),
	isnull(IMD.Value8, 0),
	isnull(IMD.Value9, 0),
	isnull(IMD.Value10, 0),
	isnull(IMD.Value11, 0),
	isnull(IMD.Value12, 0),
	IMD.[Date],
	IMD.IdRow
FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
INNER JOIN PROJECTS P 
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON IMD.WPCode = WP.Code AND 
	P.ID = WP.IdProject
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code
INNER JOIN COST_CENTERS CC 
	ON IMD.Country = dbo.fnGetCountryCodeFromCostCenter(CC.Id) and
	   IMD.CostCenter = CC.Code
INNER JOIN GL_ACCOUNTS GL
	ON C.Id = GL.IdCountry AND
	   IMD.AccountNumber = GL.Account
INNER JOIN PROJECT_PHASES PH 
	ON WP.IdPhase = PH.Id
WHERE   GL.IdCostType BETWEEN 1 AND 5 AND
	IMD.IdImport = @IdImport
ORDER BY IdRow

update #ImportBudgetAnnualDetailsCosts
set StartDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'S'), YearImport*100 + 1),
      EndDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'E'), YearImport*100 + 12)


if @SkipStartEndPhaseErrors  = 0
   begin
	if exists (
		select IdRow
		from #ImportBudgetAnnualDetailsCosts
		where IdPhase in (1,2,3,4,5,6,7,8)	
			AND (
				(StartDevelopmentPhaseYM/100 < YearImport and EndDevelopmentPhaseYM/100 < YearImport)
				OR
				(StartDevelopmentPhaseYM/100 > YearImport and EndDevelopmentPhaseYM/100 > YearImport)
				 )
		   )
	begin
		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
		( [IdImport], [Year], [Validation] )
		VALUES (@IdImport, @YEAR, 'O')

		SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'


		DECLARE alog_cursor CURSOR FAST_FORWARD FOR
		select 
			t.IdRow,
			'Development Phase [' + dbo.fnGetYMStringRepresentation(t.StartDevelopmentPhaseYM) + 
						', ' + dbo.fnGetYMStringRepresentation(t.EndDevelopmentPhaseYM) + 
						'] for project ' + PRJ.Code + ' is outside the import year. Row number ' + cast(t.IdRow as varchar(10)) + '.'
		from #ImportBudgetAnnualDetailsCosts t
		inner join PROJECTS PRJ
			on t.IdProject = PRJ.Id
		where t.IdPhase in (1,2,3,4,5,6,7,8)	
				and (
					(t.StartDevelopmentPhaseYM/100 < t.YearImport and t.EndDevelopmentPhaseYM/100 < t.YearImport)
					or
					(t.StartDevelopmentPhaseYM/100 > t.YearImport and t.EndDevelopmentPhaseYM/100 > t.YearImport)
					 )
		OPEN alog_cursor
		FETCH NEXT FROM alog_cursor INTO @IdRow, @Message

		WHILE @@FETCH_STATUS = 0
		BEGIN
			INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
			( [IdImport], [IdRow], [Details], [Module] )
			VALUES (@IdImport, @IdRow, @Message, @Module)
		
			FETCH NEXT FROM alog_cursor INTO @IdRow, @Message
		END
	
		CLOSE alog_cursor
		DEALLOCATE alog_cursor

		return -2000
	end
   end

-- Check if a Value or Quantity is in a month outside WP interval
declare @ErrorQVOutsideInterval int = 0
declare @ErrorOnRow int = 0
------------------------------------------
if @SkipStartEndPhaseErrors  = 0
   begin
		select @CurrentRow = Min(IdRow)
		from #ImportBudgetAnnualDetailsCosts
		where IdRow > 0

		set @CurrentMonth = 0

		while @CurrentRow is not null
		begin
			select 
				@IdProject = IdProject,
				@IdPhase = IdPhase,
				@IdWorkPackage = IdWorkPackage,
				@StartYearMonth = StartYearMonth,
				@EndYearMonth = EndYearMonth,
				@YearImport = YearImport,
				@IdCostCenter = IdCostCenter,
				@IdCostType = IdCostType,
				@IdCountry = IdCountry,
				@CostVal1 = CostVal1,
				@CostVal2 = CostVal2,
				@CostVal3 = CostVal3,
				@CostVal4 = CostVal4,
				@CostVal5 = CostVal5,
				@CostVal6 = CostVal6,
				@CostVal7 = CostVal7,
				@CostVal8 = CostVal8,
				@CostVal9 = CostVal9,
				@CostVal10 = CostVal10,
				@CostVal11 = CostVal11,
				@CostVal12 = CostVal12,
				@IdAccount = IdAccount,
				@DateImport = DateImport,
				@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
				@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM
			from #ImportBudgetAnnualDetailsCosts
			where IdRow = @CurrentRow

			set @ErrorOnRow = 0

			--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
						  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

			if @IdPhase in (1,2,3,4,5,6,7,8)
			begin
				set @StartYearMonth = @StartDevelopmentPhaseYM
				set @EndYearMonth = @EndDevelopmentPhaseYM

				set @StartWPYear	= @StartYearMonth/100
				set @StartWPMonth	= @StartYearMonth%100
				set @EndWPYear		= @EndYearMonth/100
				set @EndWPMonth		= @EndYearMonth%100

				--adjust the lower and upper limit of the WP period in case the overlap 
				-- with the year of upload is outside the year of upload.
				if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @EndWPMonth = 12
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
				BEGIN
					set @StartWPMonth = 1
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @StartWPMonth = 1
					set @EndWPMonth = 12
				END

				set @CurrentMonth2 = 1
				while @CurrentMonth2 < @StartWPMonth
				   begin 

					if case @CurrentMonth2
							when 1 then @CostVal1 when 2 then @CostVal2 when 3 then @CostVal3 when 4 then @CostVal4
							when 5 then @CostVal5 when 6 then @CostVal6 when 7 then @CostVal7 when 8 then @CostVal8
							when 9 then @CostVal9 when 10 then @CostVal10 when 11 then @CostVal11 when 12 then @CostVal12
						end <> 0 and @ErrorOnRow = 0
						   begin
								set @ErrorOnRow = 1

								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Cost Value cannot be different from zero before Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'
						
								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1

									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)

						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end

				set @CurrentMonth2 = @EndWPMonth + 1
				while @CurrentMonth2 <= 12
				   begin 
					if  case @CurrentMonth2
							when 1 then @CostVal1 when 2 then @CostVal2 when 3 then @CostVal3 when 4 then @CostVal4
							when 5 then @CostVal5 when 6 then @CostVal6 when 7 then @CostVal7 when 8 then @CostVal8
							when 9 then @CostVal9 when 10 then @CostVal10 when 11 then @CostVal11 when 12 then @CostVal12
						end <> 0 and @ErrorOnRow = 0
						   begin
								set @ErrorOnRow = 1

								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Cost Value cannot be different from zero after End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+  ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'

								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1
							
									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)
						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end
			end

			select @CurrentRow = Min(IdRow)
			from #ImportBudgetAnnualDetailsCosts
			where IdRow > @CurrentRow

		end

		if @ErrorQVOutsideInterval = 1
		   begin
			  return -2000
		   end
   end

------------------------------------------



select @CurrentRow = Min(IdRow)
from #ImportBudgetAnnualDetailsCosts
where IdRow > 0

set @CurrentMonth = 0

while @CurrentRow is not null
begin
	select 
		@IdProject = IdProject,
		@IdPhase = IdPhase,
		@IdWorkPackage = IdWorkPackage,
		@StartYearMonth = StartYearMonth,
		@EndYearMonth = EndYearMonth,
		@YearImport = YearImport,
		@IdCostCenter = IdCostCenter,
		@IdCostType = IdCostType,
		@IdCountry = IdCountry,
		@CostVal1 = CostVal1,
		@CostVal2 = CostVal2,
		@CostVal3 = CostVal3,
		@CostVal4 = CostVal4,
		@CostVal5 = CostVal5,
		@CostVal6 = CostVal6,
		@CostVal7 = CostVal7,
		@CostVal8 = CostVal8,
		@CostVal9 = CostVal9,
		@CostVal10 = CostVal10,
		@CostVal11 = CostVal11,
		@CostVal12 = CostVal12,
		@IdAccount = IdAccount,
		@DateImport = DateImport,
		@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
		@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM
	from #ImportBudgetAnnualDetailsCosts
	where IdRow = @CurrentRow


	--Phases 0, NA: upload blocked; error thrown with row number
	if @IdPhase in (9)
	begin 

		declare @errWP varchar(150)
		declare @PhaseName varchar(50)
		set @PhaseName = case 
					when @IdPhase = 1 then 'No Phase'
					when @IdPhase = 9 then 'Not Allocated Phase'
				 end
		set @errWP = 'Work Packages belonging to ' + @PhaseName + ' are not allowed (line number ' + cast(@CurrentRow as varchar(10)) + ').'

		raiserror(@errWP,16,1)		
		return -1
	end


	--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
				  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

	if @IdPhase in (1,2,3,4,5,6,7,8)
	begin
		--set @StartYearMonth = @StartDevelopmentPhaseYM
		--set @EndYearMonth = @EndDevelopmentPhaseYM

		set @StartYearMonth =@Year*100 + 1
		set @EndYearMonth = @Year*100 + 12

		--if @StartYearMonth > @EndYearMonth
		--BEGIN 
		--	select @ProjectCode = Code
		--	FROM PROJECTS
		--	where Id = @IdProject

		--	set @ErrStr = 'Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
		--			') is not allowed to be greater than End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
		--			') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ '.'

		--	raiserror(@ErrStr,16,1)		
		--	return -3
		--END

		set @StartWPYear	= @StartYearMonth/100
		set @StartWPMonth	= @StartYearMonth%100
		set @EndWPYear		= @EndYearMonth/100
		set @EndWPMonth		= @EndYearMonth%100

		--adjust the lower and upper limit of the WP period in case the overlap 
		-- with the year of upload is outside the year of upload.
		--if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @EndWPMonth = 12
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--	set @EndWPMonth = 12
		--END

		set @CurrentMonth = @StartWPMonth
		set @EndMonth = @EndWPMonth
	
		while @CurrentMonth <= @EndMonth
		begin
			insert into ANNUAL_BUDGET_DATA_DETAILS_COSTS
					(
					IdProject,
					IdPhase,
					IdWorkPackage,
					IdCostCenter,
					YearMonth,
					IdCostType,
					IdCountry,
					CostVal,
					IdAccount,
					DateImport,
					IdImport
					)
				values
					(
					@IdProject, 
					@IdPhase,
					@IdWorkPackage,
					@IdCostCenter,
					@YearImport*100 + @CurrentMonth,
					@IdCostType,
					@IdCountry,
					case @CurrentMonth
						when 1 then @CostVal1
						when 2 then @CostVal2
						when 3 then @CostVal3
						when 4 then @CostVal4
						when 5 then @CostVal5
						when 6 then @CostVal6
						when 7 then @CostVal7
						when 8 then @CostVal8
						when 9 then @CostVal9
						when 10 then @CostVal10
						when 11 then @CostVal11
						when 12 then @CostVal12
					end,
					@IdAccount,
					@DateImport,
					@IdImport
					)
			if (@@error <> 0)
				return -5
			set @CurrentMonth = @CurrentMonth + 1
		end
	end

	select @CurrentRow = Min(IdRow)
	from #ImportBudgetAnnualDetailsCosts
	where IdRow > @CurrentRow

end
GO
--Drops the Procedure impWriteAnnualTableHours if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteAnnualTableHours]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteAnnualTableHours
GO

create PROCEDURE [dbo].[impWriteAnnualTableHours]
	@IdImport INT,
	@SkipStartEndPhaseErrors bit = 0
AS

DECLARE @IdCostTypeHours INT
SET @IdCostTypeHours = dbo.fnGetHoursCostTypeID()

declare @CurrentRow int,
	@CurrentMonth int,
	@CurrentMonth2 int

declare @IdProject	int,
	@IdPhase	int,
	@IdWorkPackage	int,
	@StartYearMonth	int,
	@EndYearMonth	int,
	@YearImport	int,
	@IdCostCenter	int,
	@IdCountry	int,
	@IdAccount	int,
	@HoursQty1	decimal(18,2),
	@HoursQty2	decimal(18,2),
	@HoursQty3	decimal(18,2),
	@HoursQty4	decimal(18,2),
	@HoursQty5	decimal(18,2),
	@HoursQty6	decimal(18,2),
	@HoursQty7	decimal(18,2),
	@HoursQty8	decimal(18,2),
	@HoursQty9	decimal(18,2),
	@HoursQty10	decimal(18,2),
	@HoursQty11	decimal(18,2),
	@HoursQty12	decimal(18,2),
	@HoursVal1	decimal(18,2),
	@HoursVal2	decimal(18,2),
	@HoursVal3	decimal(18,2),
	@HoursVal4	decimal(18,2),
	@HoursVal5	decimal(18,2),
	@HoursVal6	decimal(18,2),
	@HoursVal7	decimal(18,2),
	@HoursVal8	decimal(18,2),
	@HoursVal9	decimal(18,2),
	@HoursVal10	decimal(18,2),
	@HoursVal11	decimal(18,2),
	@HoursVal12	decimal(18,2),
	@DateImport	smalldatetime,
	@StartWPYear	int,
	@StartWPMonth	int,
	@EndWPYear	int,
	@EndWPMonth	int,
	@MonthCount	int,
	@EndMonth	int,
	@IdProjectType int
	
declare @ProjectIsBillable bit	

declare @CumulativeQty int,
	@CurrentHoursQty int,
	@CumulativeHoursVal decimal(18,2),
	@CurrentHoursVal decimal(18,2),
	@CurrentHoursValfromDB decimal(18,2),
	@ErrStr varchar(200),
	@EndDevelopmentPhaseYM int,
	@StartDevelopmentPhaseYM int

declare @ProjectCode varchar(10)

DECLARE @YEAR int
SELECT @YEAR = SUBSTRING([FileName], 4, 4) FROM ANNUAL_BUDGET_IMPORTS WHERE IdImport = @IdImport

DECLARE @Module varchar(10)
DECLARE @IdRow int,
		@Message varchar(510)

create table #ImportBudgetAnnualDetailsHours 
	(
	IdProject	int NOT NULL,
	IdProjectType int not null,
	IdPhase		int NOT NULL,
	IdWorkPackage	int NOT NULL,
	StartYearMonth	int,
	EndYearMonth	int,
	YearImport	int,
	IdCostCenter	int NOT NULL,
	IdCountry	int NOT NULL,
	IdAccount	int NOT NULL,
	HoursQty1	decimal(18,2),
	HoursQty2	decimal(18,2),
	HoursQty3	decimal(18,2),
	HoursQty4	decimal(18,2),
	HoursQty5	decimal(18,2),
	HoursQty6	decimal(18,2),
	HoursQty7	decimal(18,2),
	HoursQty8	decimal(18,2),
	HoursQty9	decimal(18,2),
	HoursQty10	decimal(18,2),
	HoursQty11	decimal(18,2),
	HoursQty12	decimal(18,2),
	HoursVal1	decimal(18,2),
	HoursVal2	decimal(18,2),
	HoursVal3	decimal(18,2),
	HoursVal4	decimal(18,2),
	HoursVal5	decimal(18,2),
	HoursVal6	decimal(18,2),
	HoursVal7	decimal(18,2),
	HoursVal8	decimal(18,2),
	HoursVal9	decimal(18,2),
	HoursVal10	decimal(18,2),
	HoursVal11	decimal(18,2),
	HoursVal12	decimal(18,2),
	DateImport	smalldatetime,
	IdRow		int NOT NULL,
	StartDevelopmentPhaseYM int,
	EndDevelopmentPhaseYM int
	) 

declare @Command nvarchar(200)
set @Command = 'create index ImportBudgetAnnualDetails_IdRow_' + cast(@@SPID as varchar(10)) + ' on #ImportBudgetAnnualDetailsHours (IdRow)'
exec(@Command)

INSERT INTO #ImportBudgetAnnualDetailsHours
	(IdProject,
	IdProjectType,
	IdPhase, 
	IdWorkPackage,
	StartYearMonth,	
	EndYearMonth,
	YearImport,
	IdCostCenter,
	IdCountry,
	IdAccount,
	HoursQty1,
	HoursQty2,
	HoursQty3,
	HoursQty4,
	HoursQty5,
	HoursQty6,
	HoursQty7,
	HoursQty8,
	HoursQty9,
	HoursQty10,
	HoursQty11,
	HoursQty12,
	HoursVal1,
	HoursVal2,
	HoursVal3,
	HoursVal4,
	HoursVal5,
	HoursVal6,
	HoursVal7,
	HoursVal8,
	HoursVal9,
	HoursVal10,
	HoursVal11,
	HoursVal12,
	DateImport,
	IdRow
	)
SELECT 
	P.Id,
	P.IdProjectType,
	WP.IdPhase,
	WP.Id,
	case when PH.Code in ('1', '7') 
	then
		WP.StartYearMonth
	else 
		isnull(WP.StartYearMonth, IMD.Year*100 + 1)
	end,
	case when PH.Code in ('1', '7')  
	then
		WP.EndYearMonth
	else 
		isnull(WP.EndYearMonth, IMD.Year*100 + 12)
	end,
	IMD.Year,
	CC.Id,
	C.Id, 
	dbo.fnGetAnnualIdGLAccount(IMD.AccountNumber, IMD.Country), 
	IMD.Quantity1,
	IMD.Quantity2,
	IMD.Quantity3,
	IMD.Quantity4,
	IMD.Quantity5,
	IMD.Quantity6,
	IMD.Quantity7,
	IMD.Quantity8,
	IMD.Quantity9,
	IMD.Quantity10,
	IMD.Quantity11,
	IMD.Quantity12,
	isnull(IMD.Value1, 0),
	isnull(IMD.Value2, 0),
	isnull(IMD.Value3, 0),
	isnull(IMD.Value4, 0),
	isnull(IMD.Value5, 0),
	isnull(IMD.Value6, 0),
	isnull(IMD.Value7, 0),
	isnull(IMD.Value8, 0),
	isnull(IMD.Value9, 0),
	isnull(IMD.Value10, 0),
	isnull(IMD.Value11, 0),
	isnull(IMD.Value12, 0),
	IMD.[Date],
	IMD.IdRow
FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
INNER JOIN PROJECTS P 
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON IMD.WPCode = WP.Code AND 
	P.ID = WP.IdProject
INNER JOIN COUNTRIES C
	ON IMD.Country = C.Code 
INNER JOIN COST_CENTERS CC 
	ON IMD.Country = dbo.fnGetCountryCodeFromCostCenter(CC.Id) and
	   IMD.CostCenter = CC.Code
INNER JOIN GL_ACCOUNTS GL
	ON C.Id = GL.IdCountry AND
	   IMD.AccountNumber = GL.Account
INNER JOIN PROJECT_PHASES PH 
	ON WP.IdPhase = PH.Id
WHERE  IMD.IdImport = @IdImport AND
       GL.IdCostType = @IdCostTypeHours
ORDER BY IdRow

update #ImportBudgetAnnualDetailsHours
set StartDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'S'), YearImport*100 + 1),
      EndDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'E'), YearImport*100 + 12)


if @SkipStartEndPhaseErrors = 0
   begin
	if exists (
		select IdRow
		from #ImportBudgetAnnualDetailsHours
		where IdPhase in (1,2,3,4,5,6,7,8)	
			AND (
				(StartDevelopmentPhaseYM/100 < YearImport and EndDevelopmentPhaseYM/100 < YearImport)
				OR
				(StartDevelopmentPhaseYM/100 > YearImport and EndDevelopmentPhaseYM/100 > YearImport)
				 )
		   )
	begin
		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
		( [IdImport], [Year], [Validation] )
		VALUES (@IdImport, @YEAR, 'O')

		SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'

		DECLARE alog_cursor CURSOR FAST_FORWARD FOR
		select 
			t.IdRow,
			'Development Phase [' + dbo.fnGetYMStringRepresentation(t.StartDevelopmentPhaseYM) + 
						', ' + dbo.fnGetYMStringRepresentation(t.EndDevelopmentPhaseYM) + 
						'] for project ' + PRJ.Code + ' is outside the import year. Row number ' + cast(t.IdRow as varchar(10)) + '.'
		from #ImportBudgetAnnualDetailsHours t
		inner join PROJECTS PRJ
			on t.IdProject = PRJ.Id
		where t.IdPhase in (1,2,3,4,5,6,7,8)	
				and (
					(t.StartDevelopmentPhaseYM/100 < t.YearImport and t.EndDevelopmentPhaseYM/100 < t.YearImport)
					or
					(t.StartDevelopmentPhaseYM/100 > t.YearImport and t.EndDevelopmentPhaseYM/100 > t.YearImport)
					 )
		OPEN alog_cursor
		FETCH NEXT FROM alog_cursor INTO @IdRow, @Message

		WHILE @@FETCH_STATUS = 0
		BEGIN
			INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
			( [IdImport], [IdRow], [Details], [Module] )
			VALUES (@IdImport, @IdRow, @Message, @Module)
		
			FETCH NEXT FROM alog_cursor INTO @IdRow, @Message
		END
	
		CLOSE alog_cursor
		DEALLOCATE alog_cursor

		return -1000
	end
   end

-- Check if a Value or Quantity is in a month outside WP interval
declare @ErrorQVOutsideInterval int = 0
declare @ErrorOnRow int = 0
------------------------------------------
if @SkipStartEndPhaseErrors = 0
   begin
		select @CurrentRow = Min(IdRow)
		from #ImportBudgetAnnualDetailsHours
		where IdRow > 0

		set @CurrentMonth = 0

		while @CurrentRow is not null
		begin
			select 
				@IdProject = IdProject,
				@IdPhase = IdPhase,
				@IdWorkPackage = IdWorkPackage,
				@StartYearMonth = StartYearMonth,
				@EndYearMonth = EndYearMonth,
				@YearImport = YearImport,
				@IdCostCenter = IdCostCenter,
				@IdCountry = IdCountry,
				@IdAccount = IdAccount,
				@HoursQty1 = round(HoursQty1, 0),
				@HoursQty2 = round(HoursQty2, 0),
				@HoursQty3 = round(HoursQty3, 0),
				@HoursQty4 = round(HoursQty4, 0),
				@HoursQty5 = round(HoursQty5, 0),
				@HoursQty6 = round(HoursQty6, 0),
				@HoursQty7 = round(HoursQty7, 0),
				@HoursQty8 = round(HoursQty8, 0),
				@HoursQty9 = round(HoursQty9, 0),
				@HoursQty10 = round(HoursQty10, 0),
				@HoursQty11 = round(HoursQty11, 0),
				@HoursQty12 = round(HoursQty12, 0),
				@HoursVal1 = HoursVal1,
				@HoursVal2 = HoursVal2,
				@HoursVal3 = HoursVal3,
				@HoursVal4 = HoursVal4,
				@HoursVal5 = HoursVal5,
				@HoursVal6 = HoursVal6,
				@HoursVal7 = HoursVal7,
				@HoursVal8 = HoursVal8,
				@HoursVal9 = HoursVal9,
				@HoursVal10 = HoursVal10,
				@HoursVal11 = HoursVal11,
				@HoursVal12 = HoursVal12,
				@DateImport = DateImport,
				@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
				@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM,
				@IdProjectType = IdProjectType
			from #ImportBudgetAnnualDetailsHours
			where IdRow = @CurrentRow

			set @ErrorOnRow = 0

			set @ProjectIsBillable = case when @IdProjectType = 5 or @IdProjectType = 6 then 0 else 1 end

			--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
						  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

			if @IdPhase in (1,2,3,4,5,6,7,8)
			begin	
				set @StartYearMonth = @StartDevelopmentPhaseYM 
				set @EndYearMonth = @EndDevelopmentPhaseYM

				set @StartWPYear	= @StartYearMonth/100
				set @StartWPMonth	= @StartYearMonth%100
				set @EndWPYear		= @EndYearMonth/100
				set @EndWPMonth		= @EndYearMonth%100

				-- adjust the lower and upper limit of the WP period in case the overlap 
				-- with the year of upload is outside the year of upload.
				if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @EndWPMonth = 12
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
				BEGIN
					set @StartWPMonth = 1
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @StartWPMonth = 1
					set @EndWPMonth = 12
				END

				set @CurrentMonth2 = 1
				while @CurrentMonth2 < @StartWPMonth
				   begin 

					if ((case @CurrentMonth2
							when 1 then @HoursQty1 when 2 then @HoursQty2 when 3 then @HoursQty3 when 4 then @HoursQty4
							when 5 then @HoursQty5 when 6 then @HoursQty6 when 7 then @HoursQty7 when 8 then @HoursQty8
							when 9 then @HoursQty9 when 10 then @HoursQty10 when 11 then @HoursQty11 when 12 then @HoursQty12
						end <> 0
						or
					   case @CurrentMonth2
							when 1 then @HoursVal1 when 2 then @HoursVal2 when 3 then @HoursVal3 when 4 then @HoursVal4
							when 5 then @HoursVal5 when 6 then @HoursVal6 when 7 then @HoursVal7 when 8 then @HoursVal8
							when 9 then @HoursVal9 when 10 then @HoursVal10 when 11 then @HoursVal11 when 12 then @HoursVal12
						end <> 0)) and @ErrorOnRow = 0
						   begin
								set @ErrorOnRow = 1
								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Quantity or Value cannot be different from zero before Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'

								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1

									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)
						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end

				set @CurrentMonth2 = @EndWPMonth + 1
				while @CurrentMonth2 <= 12
				   begin 
					if ((case @CurrentMonth2
							when 1 then @HoursQty1 when 2 then @HoursQty2 when 3 then @HoursQty3 when 4 then @HoursQty4
							when 5 then @HoursQty5 when 6 then @HoursQty6 when 7 then @HoursQty7 when 8 then @HoursQty8
							when 9 then @HoursQty9 when 10 then @HoursQty10 when 11 then @HoursQty11 when 12 then @HoursQty12
						end <> 0
						or
					   case @CurrentMonth2
							when 1 then @HoursVal1 when 2 then @HoursVal2 when 3 then @HoursVal3 when 4 then @HoursVal4
							when 5 then @HoursVal5 when 6 then @HoursVal6 when 7 then @HoursVal7 when 8 then @HoursVal8
							when 9 then @HoursVal9 when 10 then @HoursVal10 when 11 then @HoursVal11 when 12 then @HoursVal12
						end <> 0)) and @ErrorOnRow = 0
						   begin
								 set @ErrorOnRow = 1

								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Quantity or Value cannot be different from zero after End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+  ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'
						
								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1

									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)
						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end
			end

			SELECT @CurrentRow = Min(IdRow)
			from #ImportBudgetAnnualDetailsHours
			where IdRow > @CurrentRow
		end

		if @ErrorQVOutsideInterval = 1
		   begin
			  return -1000
		   end

   end
------------------------------------------

select @CurrentRow = Min(IdRow)
from #ImportBudgetAnnualDetailsHours
where IdRow > 0

set @CurrentMonth = 0

while @CurrentRow is not null
begin
	select 
		@IdProject = IdProject,
		@IdPhase = IdPhase,
		@IdWorkPackage = IdWorkPackage,
		@StartYearMonth = StartYearMonth,
		@EndYearMonth = EndYearMonth,
		@YearImport = YearImport,
		@IdCostCenter = IdCostCenter,
		@IdCountry = IdCountry,
		@IdAccount = IdAccount,
		@HoursQty1 = round(HoursQty1, 0),
		@HoursQty2 = round(HoursQty2, 0),
		@HoursQty3 = round(HoursQty3, 0),
		@HoursQty4 = round(HoursQty4, 0),
		@HoursQty5 = round(HoursQty5, 0),
		@HoursQty6 = round(HoursQty6, 0),
		@HoursQty7 = round(HoursQty7, 0),
		@HoursQty8 = round(HoursQty8, 0),
		@HoursQty9 = round(HoursQty9, 0),
		@HoursQty10 = round(HoursQty10, 0),
		@HoursQty11 = round(HoursQty11, 0),
		@HoursQty12 = round(HoursQty12, 0),
		@HoursVal1 = HoursVal1,
		@HoursVal2 = HoursVal2,
		@HoursVal3 = HoursVal3,
		@HoursVal4 = HoursVal4,
		@HoursVal5 = HoursVal5,
		@HoursVal6 = HoursVal6,
		@HoursVal7 = HoursVal7,
		@HoursVal8 = HoursVal8,
		@HoursVal9 = HoursVal9,
		@HoursVal10 = HoursVal10,
		@HoursVal11 = HoursVal11,
		@HoursVal12 = HoursVal12,
		@DateImport = DateImport,
		@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
		@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM,
		@IdProjectType = IdProjectType
	from #ImportBudgetAnnualDetailsHours
	where IdRow = @CurrentRow

	set @ProjectIsBillable = case when @IdProjectType = 5 or @IdProjectType = 6 then 0 else 1 end

	if @IdPhase in (9)
	begin 
		declare @PhaseName varchar(50)
		set @PhaseName = case 
					when @IdPhase = 9 then 'Not Allocated Phase'
				 end
		set @ErrStr = 'Work Packages belonging to ' + @PhaseName + ' are not allowed (line number ' + cast(@CurrentRow as varchar(10)) + ').'

		raiserror(@ErrStr,16,1)		
		return -1
	end


	--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
				  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

	if @IdPhase in (1,2,3,4,5,6,7,8)
	begin	
		--set @StartYearMonth = @StartDevelopmentPhaseYM 
		--set @EndYearMonth = @EndDevelopmentPhaseYM

		set @StartYearMonth =@Year*100 + 1
		set @EndYearMonth = @Year*100 + 12


		--if @StartYearMonth > @EndYearMonth
		--BEGIN 
		--	select @ProjectCode = Code
		--	FROM PROJECTS
		--	where Id = @IdProject

		--	set @ErrStr = 'Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
		--			') is not allowed to be greater than End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
		--			') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ '.'
		--	raiserror(@ErrStr,16,1)		
		--	return -3
		--END

		set @StartWPYear	= @StartYearMonth/100
		set @StartWPMonth	= @StartYearMonth%100
		set @EndWPYear		= @EndYearMonth/100
		set @EndWPMonth		= @EndYearMonth%100

		-- adjust the lower and upper limit of the WP period in case the overlap 
		-- with the year of upload is outside the year of upload.
		--if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @EndWPMonth = 12
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--	set @EndWPMonth = 12
		--END

		set @CurrentMonth = @StartWPMonth
		set @EndMonth = @EndWPMonth

		set @CurrentHoursQty = 0
		set @CumulativeQty = 0
		set @CurrentHoursVal = 0
		set @CurrentHoursValFromDB = 0
		set @CumulativeHoursVal = 0


		-- we loop through all the month we need to split the values
		while @CurrentMonth <= @EndMonth
		begin
			select @CurrentHoursQty = case @CurrentMonth
										when 1 then @HoursQty1
										when 2 then @HoursQty2
										when 3 then @HoursQty3
										when 4 then @HoursQty4
										when 5 then @HoursQty5
										when 6 then @HoursQty6
										when 7 then @HoursQty7
										when 8 then @HoursQty8
										when 9 then @HoursQty9
										when 10 then @HoursQty10
										when 11 then @HoursQty11
										when 12 then @HoursQty12
									   end,
					@CurrentHoursValfromDB = case @CurrentMonth
										when 1 then @HoursVal1
										when 2 then @HoursVal2
										when 3 then @HoursVal3
										when 4 then @HoursVal4
										when 5 then @HoursVal5
										when 6 then @HoursVal6
										when 7 then @HoursVal7
										when 8 then @HoursVal8
										when 9 then @HoursVal9
										when 10 then @HoursVal10
										when 11 then @HoursVal11
										when 12 then @HoursVal12
				end


			set @CurrentHoursVal = @CurrentHoursValfromDB

			insert into ANNUAL_BUDGET_DATA_DETAILS_HOURS
					(
					IdProject,
					IdPhase,
					IdWorkPackage,
					IdCostCenter,
					YearMonth,
					IdCountry,
					IdAccount,
					HoursQty,
					HoursVal,
					DateImport,
					IdImport
					)
			values
					(
					@IdProject, 
					@IdPhase,
					@IdWorkPackage,
					@IdCostCenter,
					@YearImport*100 + @CurrentMonth,
					@IdCountry,
					@IdAccount,
					@CurrentHoursQty,
					case when @ProjectIsBillable = 0 then 0 else @CurrentHoursVal end,
						--case  WHEN @CurrentHoursValfromDB = 0 THEN dbo.fnGetValuedHours(@IdCostCenter, 
						--					@CurrentHoursQty, 
						--					@YearImport*100 + @CurrentMonth)
		    --    			       ELSE  @CurrentHoursVal end
					@DateImport,
					@IdImport
					)
			if (@@error <> 0)
			begin
				return -5
			end

			set @CumulativeQty = @CumulativeQty + @CurrentHoursQty
			set @CumulativeHoursVal = @CumulativeHoursVal + @CurrentHoursVal
			set @CurrentMonth = @CurrentMonth + 1	
		end
	end


	SELECT @CurrentRow = Min(IdRow)
	from #ImportBudgetAnnualDetailsHours
	where IdRow > @CurrentRow
end
go
--Drops the Procedure impWriteAnnualTableSales if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteAnnualTableSales]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteAnnualTableSales
GO

CREATE PROCEDURE impWriteAnnualTableSales
	@IdImport INT,
	@SkipStartEndPhaseErrors bit = 0	
AS

DECLARE @IdCostTypeSales INT
SET @IdCostTypeSales = dbo.fnGetSalesCostTypeID()

DECLARE @YEAR int
SELECT @YEAR = SUBSTRING([FileName], 4, 4) FROM ANNUAL_BUDGET_IMPORTS WHERE IdImport = @IdImport

DECLARE @Module varchar(10)

declare @CurrentRow int,
	@CurrentMonth int,
	@CurrentMonth2 int

DECLARE @IdRow int,
	@Message varchar(510)

declare @IdProject	int,
	@IdPhase	int,
	@IdWorkPackage	int,
	@StartYearMonth	int,
	@EndYearMonth	int,
	@YearImport	int,
	@IdCostCenter	int,
	@IdCountry	int,
	@IdAccount	int,
	@SalesVal1	decimal(18,2),
	@SalesVal2	decimal(18,2),
	@SalesVal3	decimal(18,2),
	@SalesVal4	decimal(18,2),
	@SalesVal5	decimal(18,2),
	@SalesVal6	decimal(18,2),
	@SalesVal7	decimal(18,2),
	@SalesVal8	decimal(18,2),
	@SalesVal9	decimal(18,2),
	@SalesVal10	decimal(18,2),
	@SalesVal11	decimal(18,2),
	@SalesVal12	decimal(18,2),
	@DateImport	smalldatetime,
	@StartWPYear	int,
	@StartWPMonth	int,
	@EndWPYear	int,
	@EndWPMonth	int,
	@MonthCount	int,
	@EndMonth	int,
	@ErrStr 	varchar(200),
	@EndDevelopmentPhaseYM int,
	@StartDevelopmentPhaseYM int

declare @ProjectCode varchar(10)



CREATE TABLE #ImportBudgetAnnualDetailsSales 
	(
	IdProject	int NOT NULL,
	IdPhase		int NOT NULL,
	IdWorkPackage	int NOT NULL,
	StartYearMonth	int,
	EndYearMonth	int,
	YearImport	int,
	IdCostCenter	int NOT NULL,
	IdCountry	int NOT NULL,
	IdAccount	int NOT NULL,
	SalesVal1	decimal(18,2),
	SalesVal2	decimal(18,2),
	SalesVal3	decimal(18,2),
	SalesVal4	decimal(18,2),
	SalesVal5	decimal(18,2),
	SalesVal6	decimal(18,2),
	SalesVal7	decimal(18,2),
	SalesVal8	decimal(18,2),
	SalesVal9	decimal(18,2),
	SalesVal10	decimal(18,2),
	SalesVal11	decimal(18,2),
	SalesVal12	decimal(18,2),
	DateImport	smalldatetime,
	IdRow		int NOT NULL,
	StartDevelopmentPhaseYM int,
	EndDevelopmentPhaseYM int
	)

declare @Command nvarchar(200)
set @Command = 'create index ImportBudgetAnnualDetails_IdRow_' + cast(@@SPID as varchar(10)) + ' on #ImportBudgetAnnualDetailsSales (IdRow)'
exec(@Command)

INSERT INTO #ImportBudgetAnnualDetailsSales
	(IdProject,
	IdPhase, 
	IdWorkPackage,
	StartYearMonth,	
	EndYearMonth,
	YearImport,
	IdCostCenter,
	IdCountry,
	IdAccount,
	SalesVal1,
	SalesVal2,
	SalesVal3,
	SalesVal4,
	SalesVal5,
	SalesVal6,
	SalesVal7,
	SalesVal8,
	SalesVal9,
	SalesVal10,
	SalesVal11,
	SalesVal12,
	DateImport,
	IdRow
	)
SELECT 
	P.Id, 
	WP.IdPhase, 
	WP.Id, 
	case when PH.Code in ('1', '7') 
	then
		WP.StartYearMonth
	else 
		isnull(WP.StartYearMonth, IMD.Year*100 + 1)
	end,

	case when PH.Code in ('1', '7') 
	then
		WP.EndYearMonth
	else 
		isnull(WP.EndYearMonth, IMD.Year*100 + 12)
	end,
	IMD.Year,
	CC.Id,
	C.Id, 
	dbo.fnGetAnnualIdGLAccount(IMD.AccountNumber, IMD.Country),
	isnull(IMD.Value1, 0),
	isnull(IMD.Value2, 0),
	isnull(IMD.Value3, 0),
	isnull(IMD.Value4, 0),
	isnull(IMD.Value5, 0),
	isnull(IMD.Value6, 0),
	isnull(IMD.Value7, 0),
	isnull(IMD.Value8, 0),
	isnull(IMD.Value9, 0),
	isnull(IMD.Value10, 0),
	isnull(IMD.Value11, 0),
	isnull(IMD.Value12, 0),
	IMD.[Date],
	IMD.IdRow
FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
INNER JOIN PROJECTS P
	ON IMD.ProjectCode = P.Code
INNER JOIN WORK_PACKAGES WP 
	ON IMD.WPCode = WP.Code AND 
	   P.ID = WP.IdProject 
INNER JOIN COUNTRIES C
	ON C.Code = IMD.Country
INNER JOIN COST_CENTERS CC 
	ON IMD.Country = dbo.fnGetCountryCodeFromCostCenter(CC.Id) and
	   IMD.CostCenter = CC.Code
INNER JOIN GL_ACCOUNTS GL
	ON C.Id = GL.IdCountry AND
	   IMD.AccountNumber = GL.Account	
INNER JOIN PROJECT_PHASES PH 
	ON WP.IdPhase = PH.Id		
WHERE  IMD.IdImport = @IdImport AND
	GL.IdCostType = @IdCostTypeSales
ORDER BY IdRow

update #ImportBudgetAnnualDetailsSales
set StartDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'S'), YearImport*100 + 1),
      EndDevelopmentPhaseYM = ISNULL(dbo.fnGetNormalizedDevelopmentPhase(IdProject, IdPhase, YearImport, StartYearMonth, EndYearMonth, N'E'), YearImport*100 + 12)


if @SkipStartEndPhaseErrors = 0
   begin
		if exists (
			select IdRow
			from #ImportBudgetAnnualDetailsSales
			where IdPhase in (1,2,3,4,5,6,7,8)	
				AND (
					(StartDevelopmentPhaseYM/100 < YearImport and EndDevelopmentPhaseYM/100 < YearImport)
					OR
					(StartDevelopmentPhaseYM/100 > YearImport and EndDevelopmentPhaseYM/100 > YearImport)
					 )
			   )
		begin
			INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
			( [IdImport], [Year], [Validation] )
			VALUES (@IdImport, @YEAR, 'O')

			SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'

			DECLARE alog_cursor CURSOR FAST_FORWARD FOR
			select 
				t.IdRow,
				'Development Phase [' + dbo.fnGetYMStringRepresentation(t.StartDevelopmentPhaseYM) + 
							', ' + dbo.fnGetYMStringRepresentation(t.EndDevelopmentPhaseYM) + 
							'] for project ' + PRJ.Code + ' is outside the import year. Row number ' + cast(t.IdRow as varchar(10)) + '.'
			from #ImportBudgetAnnualDetailsSales t
			inner join PROJECTS PRJ
				on t.IdProject = PRJ.Id
			where t.IdPhase in (1,2,3,4,5,6,7,8)	
					and (
						(t.StartDevelopmentPhaseYM/100 < t.YearImport and t.EndDevelopmentPhaseYM/100 < t.YearImport)
						or
						(t.StartDevelopmentPhaseYM/100 > t.YearImport and t.EndDevelopmentPhaseYM/100 > t.YearImport)
						 )
			OPEN alog_cursor
			FETCH NEXT FROM alog_cursor INTO @IdRow, @Message

			WHILE @@FETCH_STATUS = 0
			BEGIN
				INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
				( [IdImport], [IdRow], [Details], [Module] )
				VALUES (@IdImport, @IdRow, @Message, @Module)
		
				FETCH NEXT FROM alog_cursor INTO @IdRow, @Message
			END
	
			CLOSE alog_cursor
			DEALLOCATE alog_cursor

			return -3000
		end
   end

-- Check if a Value or Quantity is in a month outside WP interval
declare @ErrorQVOutsideInterval int = 0
declare @ErrorOnRow int = 0
------------------------------------------
if @SkipStartEndPhaseErrors = 0
   begin
		select @CurrentRow = Min(IdRow)
		from #ImportBudgetAnnualDetailsSales
		where IdRow > 0

		set @CurrentMonth = 0

		while @CurrentRow is not null
		begin
			select 
				@IdProject = IdProject,
				@IdPhase = IdPhase,
				@IdWorkPackage = IdWorkPackage,
				@StartYearMonth = StartYearMonth,
				@EndYearMonth = EndYearMonth,
				@YearImport = YearImport,
				@IdCostCenter = IdCostCenter,
				@IdCountry = IdCountry,
				@IdAccount = IdAccount,
				@SalesVal1 = SalesVal1,
				@SalesVal2 = SalesVal2,
				@SalesVal3 = SalesVal3,
				@SalesVal4 = SalesVal4,
				@SalesVal5 = SalesVal5,
				@SalesVal6 = SalesVal6,
				@SalesVal7 = SalesVal7,
				@SalesVal8 = SalesVal8,
				@SalesVal9 = SalesVal9,
				@SalesVal10 = SalesVal10,
				@SalesVal11 = SalesVal11,
				@SalesVal12 = SalesVal12,
				@DateImport = DateImport,
				@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
				@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM
			from #ImportBudgetAnnualDetailsSales
			where IdRow = @CurrentRow

			set @ErrorOnRow = 0

			--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
						  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

			if @IdPhase in (1,2,3,4,5,6,7,8)
			begin
				set @StartYearMonth = @StartDevelopmentPhaseYM
				set @EndYearMonth = @EndDevelopmentPhaseYM

				set @StartWPYear	= @StartYearMonth/100
				set @StartWPMonth	= @StartYearMonth%100
				set @EndWPYear		= @EndYearMonth/100
				set @EndWPMonth		= @EndYearMonth%100

				--adjust the lower and upper limit of the WP period in case the overlap 
				-- with the year of upload is outside the year of upload.
				if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @EndWPMonth = 12
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
				BEGIN
					set @StartWPMonth = 1
				END
	
				if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
				BEGIN
					set @StartWPMonth = 1
					set @EndWPMonth = 12
				END

				set @CurrentMonth2 = 1
				while @CurrentMonth2 < @StartWPMonth
				   begin 

					if case @CurrentMonth2
							when 1 then @SalesVal1 when 2 then @SalesVal2 when 3 then @SalesVal3 when 4 then @SalesVal4
							when 5 then @SalesVal5 when 6 then @SalesVal6 when 7 then @SalesVal7 when 8 then @SalesVal8
							when 9 then @SalesVal9 when 10 then @SalesVal10 when 11 then @SalesVal11 when 12 then @SalesVal12
						end <> 0 and @ErrorOnRow = 0
						   begin
								set @ErrorOnRow = 1

								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Sales Value cannot be different from zero before Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'
						
								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1

									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)

						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end

				set @CurrentMonth2 = @EndWPMonth + 1
				while @CurrentMonth2 <= 12
				   begin 
					if  case @CurrentMonth2
							when 1 then @SalesVal1 when 2 then @SalesVal2 when 3 then @SalesVal3 when 4 then @SalesVal4
							when 5 then @SalesVal5 when 6 then @SalesVal6 when 7 then @SalesVal7 when 8 then @SalesVal8
							when 9 then @SalesVal9 when 10 then @SalesVal10 when 11 then @SalesVal11 when 12 then @SalesVal12
						end <> 0 and @ErrorOnRow = 0
						   begin
								set @ErrorOnRow = 1

								select @ProjectCode = Code
								FROM PROJECTS
								where Id = @IdProject

								set @Message = 'Sales Value cannot be different from zero after End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
										') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+  ', month on the row ' + cast(@currentMonth2 as varchar(2)) + '.'

								if @ErrorQVOutsideInterval = 0
								begin
									set @ErrorQVOutsideInterval = 1
							
									INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
									( [IdImport], [Year], [Validation] )
									VALUES (@IdImport, @YEAR, 'O')

									SELECT  @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
								end

								INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
								( [IdImport], [IdRow], [Details], [Module] )
								VALUES (@IdImport, @CurrentRow, @Message, @Module)
						   end

					set @CurrentMonth2 = @CurrentMonth2 + 1
				   end
			end

			select @CurrentRow = Min(IdRow)
			from #ImportBudgetAnnualDetailsSales
			where IdRow > @CurrentRow

		end

		if @ErrorQVOutsideInterval = 1
		   begin
			  return -3000
		   end
   end
------------------------------------------


select @CurrentRow = Min(IdRow)
from #ImportBudgetAnnualDetailsSales
where IdRow > 0

set @CurrentMonth = 0

while @CurrentRow is not null
begin
	select 
		@IdProject = IdProject,
		@IdPhase = IdPhase,
		@IdWorkPackage = IdWorkPackage,
		@StartYearMonth = StartYearMonth,
		@EndYearMonth = EndYearMonth,
		@YearImport = YearImport,
		@IdCostCenter = IdCostCenter,
		@IdCountry = IdCountry,
		@IdAccount = IdAccount,
		@SalesVal1 = SalesVal1,
		@SalesVal2 = SalesVal2,
		@SalesVal3 = SalesVal3,
		@SalesVal4 = SalesVal4,
		@SalesVal5 = SalesVal5,
		@SalesVal6 = SalesVal6,
		@SalesVal7 = SalesVal7,
		@SalesVal8 = SalesVal8,
		@SalesVal9 = SalesVal9,
		@SalesVal10 = SalesVal10,
		@SalesVal11 = SalesVal11,
		@SalesVal12 = SalesVal12,
		@DateImport = DateImport,
		@StartDevelopmentPhaseYM = StartDevelopmentPhaseYM,
		@EndDevelopmentPhaseYM = EndDevelopmentPhaseYM
	from #ImportBudgetAnnualDetailsSales
	where IdRow = @CurrentRow

	--Phases 0, NA: upload blocked; error thrown with row number
	if @IdPhase in (9)
	begin 

		declare @errWP varchar(150)
		declare @PhaseName varchar(50)
		set @PhaseName = case 
					when @IdPhase = 1 then 'No Phase'
					when @IdPhase = 9 then 'Not Allocated Phase'
				 end
		set @errWP = 'Work Packages belonging to ' + @PhaseName + ' are not allowed (line number ' + cast(@CurrentRow as varchar(10)) + ').'

		raiserror(@errWP,16,1)
		return -1
	end


	--Phases 1-6 and also 7:   - for WPs belonging to phases 1-6 the split is done to the month inside the interval 
				  -- [Min StartYearMonth WPs Phase 2 - Max EndYearMonth Phase 6]

	if @IdPhase in (1,2,3,4,5,6,7,8)
	begin
		--set @StartYearMonth = @StartDevelopmentPhaseYM
		--set @EndYearMonth = @EndDevelopmentPhaseYM

		set @StartYearMonth = @Year*100 + 1
		set @EndYearMonth = @Year*100 + 12

		--if @StartYearMonth > @EndYearMonth
		--BEGIN 
		--	declare @WPCode varchar(3)

		--	select @ProjectCode = Code
		--	FROM PROJECTS
		--	where Id = @IdProject

		--	set @ErrStr = 'Start Development Phase (' + dbo.fnGetYMStringRepresentation(@StartDevelopmentPhaseYM) + 
		--			') is not allowed to be greater than End Development Phase (' + dbo.fnGetYMStringRepresentation(@EndDevelopmentPhaseYM) + 
		--			') for project ' + @ProjectCode + '.' + 'Row number ' + cast(@CurrentRow as varchar(10))+ '.'
			
		--	raiserror(@ErrStr,16,1)		
		--	return -3
		--END

		set @StartWPYear	= @StartYearMonth/100
		set @StartWPMonth	= @StartYearMonth%100
		set @EndWPYear		= @EndYearMonth/100
		set @EndWPMonth		= @EndYearMonth%100

		-- adjust the lower and upper limit of the WP period in case the overlap 
		-- with the year of upload is outside the year of upload.
		--if (@StartWPYear = @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @EndWPMonth = 12
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear = @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--END
	
		--if (@StartWPYear < @YearImport  AND @EndWPYear > @YearImport)
		--BEGIN
		--	set @StartWPMonth = 1
		--	set @EndWPMonth = 12
		--END
		

		set @CurrentMonth = @StartWPMonth
		set @EndMonth = @EndWPMonth

		while @CurrentMonth <= @EndMonth
		begin
			insert into ANNUAL_BUDGET_DATA_DETAILS_SALES
					(
					IdProject,
					IdPhase,
					IdWorkPackage,
					IdCostCenter,
					YearMonth,
					IdCountry,
					IdAccount,
					SalesVal,
					DateImport,
					IdImport
					)
				values
					(
					@IdProject, 
					@IdPhase,
					@IdWorkPackage,
					@IdCostCenter,
					@YearImport*100 + @CurrentMonth,
					@IdCountry,
					@IdAccount,
					case @CurrentMonth
						when 1 then @SalesVal1
						when 2 then @SalesVal2
						when 3 then @SalesVal3
						when 4 then @SalesVal4
						when 5 then @SalesVal5
						when 6 then @SalesVal6
						when 7 then @SalesVal7
						when 8 then @SalesVal8
						when 9 then @SalesVal9
						when 10 then @SalesVal10
						when 11 then @SalesVal11
						when 12 then @SalesVal12
					end,
					@DateImport,
					@IdImport
					)

			if (@@error <> 0)
				return -5
			set @CurrentMonth = @CurrentMonth + 1
		end
	end

	select @CurrentRow = Min(IdRow)
	from #ImportBudgetAnnualDetailsSales
	where IdRow > @CurrentRow

end
GO

--Drops the Procedure impWriteKeyrowsMissingToLogTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteKeyrowsMissingToLogTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteKeyrowsMissingToLogTable
GO


CREATE    PROCEDURE impWriteKeyrowsMissingToLogTable
	@IdImport 	INT,
	@IdRow		INT,		
	@Message 	nvarchar(255)
AS

-- set validation flag to 'O' to allow creating new process file
UPDATE IMPORT_LOGS
SET Validation = 'O'
WHERE IdImport = @IdImport

INSERT INTO [IMPORT_LOGS_DETAILS_KEYROWS_MISSING]
	([IdImport], [IdRow], [Details])
VALUES(@IDIMPORT, @IdRow, @Message)

GO


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteKeysRowsMissingFromPreviousImport]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteKeysRowsMissingFromPreviousImport
GO

--impSelectMissingKeysFromPreviousImport 6
CREATE PROCEDURE impWriteKeysRowsMissingFromPreviousImport
	@IdImport 	INT --ID of the import
AS
BEGIN

Declare	@IdImportPrevious int

Declare @IdSource int,
	@YearMonth int,
	@MaxIdRow int

DECLARE @NULLTempAssociateNumber varchar(15)
SET @NULLTempAssociateNumber = 'WKRM________' 

DECLARE @IMPORT_PREVIOUS TABLE
(
	IdImport		int,
	IdRow			int,
	ProjectCode		varchar(10),
	WPCode			varchar(3),
	CostCenter		varchar(15),
	AssociateNumber		varchar(15),
	Country			varchar(3),
	AccountNumber		varchar(20)

	PRIMARY KEY (IdImport, IdRow),
	UNIQUE (ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber)
)

DECLARE @IMPORT_CURRENT TABLE
(
	ProjectCode		varchar(10),
	WPCode			varchar(3),
	CostCenter		varchar(15),
	AssociateNumber		varchar(15),
	Country			varchar(3),
	AccountNumber		varchar(20),

	PRIMARY KEY (ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber)
)

SELECT @IdSource = IL.IdSource,
	@YearMonth = IL.YearMonth
FROM IMPORT_LOGS IL
WHERE IL.IdImport = @IdImport

--we look for the previous import succeded for the same source, same year and with a month before
select @IdImportPrevious = IMP.IdImport
from IMPORTS IMP
INNER JOIN IMPORT_LOGS IL
	ON IMP.IdImport = IL.IdImport
WHERE IL.IdSource = @IdSource AND                -- same source
      IL.YearMonth/100 = @YearMonth/100 and      -- same year
      IL.YearMonth = @YearMonth - 1 and 	-- only the previous and current months
      IL.Validation = 'G'

IF (@IdImportPrevious is NULL)
BEGIN
	-- no previous succesfull import found - bail out - we have nothing to compare to
	RETURN
END

INSERT INTO @IMPORT_PREVIOUS
	(IdImport, IdRow, ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber)
SELECT	@IdImportPrevious,
	MAX(IdRow), -- we will have multiple IdRows in case the associate is NULL for multiple rows with the same rest of the key
	ProjectCode,
	WPCode, 
	CostCenter, 
	ISNULL(AssociateNumber, @NULLTempAssociateNumber) AS AssociateNumber,
	Country,  
	AccountNumber
from IMPORT_DETAILS
where IdImport = @IdImportPrevious
group by ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber

INSERT INTO @IMPORT_CURRENT
	(ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber)
select  ProjectCode,
	WPCode, 
	CostCenter, 
	ISNULL(AssociateNumber, @NULLTempAssociateNumber) AS AssociateNumber,
	Country,  
	AccountNumber
from IMPORT_DETAILS
where IdImport = @IdImport
group by ProjectCode, WPCode, CostCenter, AssociateNumber, Country, AccountNumber

--we remove the rows that are found in the next import
DELETE P
FROM @IMPORT_PREVIOUS P
INNER JOIN @IMPORT_CURRENT C
	ON P.ProjectCode = C.ProjectCode AND
    	   P.WPCode = C.WPCode AND
    	   P.CostCenter = C.CostCenter AND
    	   P.AssociateNumber = C.AssociateNumber AND
    	   P.Country = C.Country AND
    	   P.AccountNumber = C.AccountNumber


select @MaxIdRow = MAX(IdRow) FROM IMPORT_DETAILS where IdImport = @IdImport

Declare @RowCount int

INSERT INTO
IMPORT_DETAILS_KEYROWS_MISSING
	(IdImport, IdRow, Country, Year, Month, 
	CostCenter, ProjectCode, WPCode, AccountNumber, AssociateNumber, 
	Quantity, UnitQty, Value, CurrencyCode, Date, IdImportPrevious )
SELECT  @IdImport, IMD.IdRow + @MaxIdRow, IMD.Country, IMD.[Year], IMD.[Month] + 1, 
	IMD.CostCenter, IMD.ProjectCode, IMD.WPCode, IMD.AccountNumber, NULLIF(IMD.AssociateNumber, @NULLTempAssociateNumber),
	0,NULL,0,IMD.CurrencyCode, IMD.[Date], @IdImportPrevious
FROM IMPORT_DETAILS IMD
INNER JOIN @IMPORT_PREVIOUS IP
	on IMD.IdImport = IP.IdImport AND
	   IMD.IdRow = IP.IdRow
SET @RowCount = @@ROWCOUNT

Return @RowCount

END
GO



--Drops the Procedure impWriteToActualTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToActualTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToActualTable
GO

--impWriteToActualTable 10,5
CREATE PROCEDURE impWriteToActualTable
	@IdAssociate INT,		--ID of the associate	
	@IdImport INT,			--ID of the import	
	@SkipCCHRError bit		--Skip Cost Center without Hourly Rate error
AS
BEGIN
	DECLARE @result 	INT,
		@YEARMONTH 	INT,
		@IdSource 	INT,
		@Message 	varchar(255)
	
	SELECT @IdSource = IL.IdSource, 
		   @YearMonth = IL.YearMonth
	FROM IMPORT_LOGS IL
	WHERE IL.IdImport = @IdImport

	IF EXISTS (SELECT IdImport
		   FROM IMPORT_DETAILS
		   WHERE IdImport = @IdImport AND
			[YEAR]*100 + [MONTH] <> @YEARMONTH)
	BEGIN
		DECLARE @YMString varchar(255)
		SET @YMString = 'There is at list one row in the imported file that do not belong to YearMonth: ' + dbo.fnGetYMStringRepresentation(@YearMonth)
		exec impProcessErrorToLogTable @IdImport, @YMString
		RETURN -3
	END
		
	--check mandatory fields
	--#########################   INSERT INTO LOGS IF NULL OR NOT EXISTS
		
	IF EXISTS
	(
		SELECT IdImport 
		FROM Import_details IMD
		WHERE 
		IMD.IdImport = @IdImport
		AND
		
		(
			-- no country
			(IMD.Country IS NULL  OR 
				NOT EXISTS(SELECT ID 
					   FROM COUNTRIES 
					   WHERE CODE = IMD.Country)
			)
			-- no import source for country
			OR NOT EXISTS(SELECT C.Id	   
						  FROM COUNTRIES C
						  INNER JOIN IMPORT_SOURCES_COUNTRIES ISC 
							 ON C.Id = ISC.IdCountry AND
								@IdSource = ISC.IdImportSource
						   WHERE C.Code = IMD.Country)
			-- NO YEAR
			OR  IMD.Year IS NULL
-- 			YEAR not valid
			OR IMD.Year NOT BETWEEN 1900 AND 2079
			--NO MONTH
			OR IMD.Month IS NULL
			OR IMD.Month NOT BETWEEN 1 and 12
			-- NO cost center
			OR (IMD.CostCenter IS NULL OR
			    NOT EXISTS
				(
					SELECT CC.Id 
					FROM COST_CENTERS CC 
					INNER JOIN INERGY_LOCATIONS IL 
					        ON CC.IdInergyLocation = IL.ID 
					INNER JOIN Countries C 
						ON IL.IdCountry = C.Id     
					WHERE CC.CODE = IMD.CostCenter AND
					      C.Code = IMD.Country
				)
			   )
			--NO project code
			OR (IMD.ProjectCode IS NULL  OR 
				NOT EXISTS(SELECT ID 
					   FROM PROJECTS 
					   WHERE CODE = IMD.ProjectCode )
			    )
			--NO WP code
			OR (IMD.WPCode IS NULL OR
				NOT EXISTS(SELECT TOP 1  WP.Code 
					   FROM WORK_PACKAGES WP
					   INNER JOIN PROJECTS P
					      ON P.Id = WP.IdProject AND
						 P.Code = IMD.ProjectCode
					   WHERE WP.CODE = IMD.WPCode
						      )
			    )
			--NO Account Number
			OR (IMD.AccountNumber  IS NULL  OR 
					NOT EXISTS(SELECT GL.ID
						   FROM GL_ACCOUNTS GL 
						   INNER JOIN COUNTRIES C
							ON GL.IdCountry = C.Id 
						   WHERE Account = IMD.AccountNumber AND
							C.Code = IMD.Country )
			   )
			--NO Quantity
			OR (IMD.Quantity IS NULL)		
			--NO Hourly Rate
			-- Commented on 11/18/2014 per request

		)
	)
	BEGIN
		exec impWriteToLogTables @IdImport, @IdAssociate
		return -4
	END
	
-- CHECK TO SEE IF THERE ARE COST CENTERS WITHOUT HOURLEY RATE
if @SkipCCHRError = 0
  begin
	IF EXISTS
	(
		SELECT IdImport 
		FROM Import_details IMD
		WHERE 
		IMD.IdImport = @IdImport
		AND
		(
			--NO Hourly Rate
			-- Commented on 11/18/2014 per request
			  (NOT EXISTS(SELECT HourlyRate 
							FROM HOURLY_RATES AS HR
							INNER JOIN COST_CENTERS CC
									ON HR.IdCostCenter = CC.Id
							WHERE 	IMD.CostCenter = CC.Code AND
									HR.YearMonth = @YEARMONTH)
				)

		)
	)
	BEGIN
		exec impWriteToLogTables @IdImport, @IdAssociate
		return 1000 -- it is not a failure code
	END
  end
	

-- 	CHECK TO SEE IF THERE ARE DUPLICATED KEY VALUES IN IMPORT TABLE
	
	IF EXISTS
	(SELECT Country, 
		Year, 
		Month, 
		CostCenter, 
		ProjectCode, 
		WPCode, 
		AccountNumber,
		AssociateNumber
	FROM IMPORT_DETAILS
	WHERE IdImport = @IdImport AND
	      AssociateNumber IS NOT NULL
	GROUP BY Country, Year, Month, CostCenter, 
	 	ProjectCode, WPCode, AccountNumber,AssociateNumber
	HAVING COUNT(Country)>1)

	BEGIN
		

		UPDATE [IMPORT_LOGS]
		SET Validation = 'O'
		WHERE IdImport = @IdImport

		DECLARE @C VARCHAR(3), @Y int, @M int,
			@CC VARCHAR(10), @PC VARCHAR(10),
			@WP VARCHAR(4), @AN VARCHAR(10), @ASN VARCHAR(15)

		SET  @Message = 'There is at least another row which has the same Country + Year + Month + CostCenter + ProjectCode + WPCode + AccountNumber + AssociateNumber as this row. This is not allowed.'
		DECLARE log_cursor CURSOR FAST_FORWARD FOR
		SELECT 	Country, 
			Year, 
			Month, 
			CostCenter, 
			ProjectCode, 
			WPCode, 
			AccountNumber, 
			AssociateNumber
		FROM IMPORT_DETAILS
		WHERE IdImport = @IdImport AND
		AssociateNumber IS NOT NULL
		GROUP BY Country, Year, Month, CostCenter, 
		ProjectCode, WPCode, AccountNumber, AssociateNumber
		HAVING COUNT(Country)>1
		
		OPEN log_cursor
		FETCH NEXT FROM log_cursor 
		INTO @C,@Y, @M, @CC, @PC, @WP, @AN, @ASN
	
		WHILE @@FETCH_STATUS = 0
		BEGIN

			INSERT INTO [IMPORT_LOGS_DETAILS]
			([IdImport], [IdRow], [Details] )			
			SELECT @IdImport, IdRow, @Message
			FROM  IMPORT_DETAILS
			WHERE 	Country = @C AND
				Year = @Y AND
				Month = @M AND
				CostCenter = @CC AND
				ProjectCode = @PC AND
				WPCode = @WP AND
				AccountNumber = @AN AND
				AssociateNumber = @ASN AND
				IdImport = @IdImport
		
		FETCH NEXT FROM log_cursor 
		INTO @C,@Y, @M, @CC, @PC, @WP, @AN, @ASN
		END
	
		CLOSE log_cursor
		DEALLOCATE log_cursor
		

		return -5
	END

-- 	########################### AUTOMATICALLY INSERT ALL IMPORT ASSOCIATES WITH NOT NULL ASSOCIATESNUMBERS THAT NOT EXISTS IN ASSOCIATES TABLE
-- 	________________________________________________________________________
	DECLARE @AssociateNumber varchar(15)
	DECLARE @AssociateIdCountry varchar(3) 

	DECLARE @INERGYLOGIN VARCHAR(30)
	DECLARE @COUNT_ASSOC INT
	SET @COUNT_ASSOC = 0
	
	DECLARE ImportAssociatesCursor CURSOR FAST_FORWARD FOR
	SELECT 	DISTINCT C.Id, IMD.AssociateNumber	
	FROM IMPORT_DETAILS IMD 
	INNER JOIN COUNTRIES C
		ON IMD.Country = C.Code
	LEFT JOIN ASSOCIATES A 
		ON IMD.AssociateNumber = A.EmployeeNumber AND
		   C.Id = A.IdCountry 
	WHERE 	AssociateNumber IS NOT NULL AND
	      	A.Id IS NULL AND
	      	IMD.IdImport = @IdImport

	OPEN ImportAssociatesCursor
	FETCH NEXT FROM ImportAssociatesCursor INTO @AssociateIdCountry, @AssociateNumber
	WHILE @@FETCH_STATUS = 0
	BEGIN		
		SET @INERGYLOGIN = 'UPLOAD\' + @AssociateNumber + '_' + CAST(@IdImport AS VARCHAR(7))
		exec catInsertAssociate @AssociateIdCountry, @AssociateNumber, 'NULL, NULL', @INERGYLOGIN, 0, 0, 0

		SET @COUNT_ASSOC = @COUNT_ASSOC + 1

		FETCH NEXT FROM ImportAssociatesCursor INTO @AssociateIdCountry, @AssociateNumber
	END
	
	CLOSE ImportAssociatesCursor
	DEALLOCATE ImportAssociatesCursor	

-- 	######################### IF NO ERROR THEN BEGIN IMPORT TO ACTUAL	

	INSERT INTO ACTUAL_DATA (IDProject, [Date])
	SELECT DISTINCT P.ID, GETDATE()
	FROM PROJECTS P 
	INNER JOIN IMPORT_DETAILS IMD 
		ON P.CODE = IMD.PROJECTCODE
	LEFT JOIN ACTUAL_DATA AD
		ON AD.IDPROJECT = P.ID
	WHERE IMD.IDIMPORT = @IdImport AND 
	AD.IDPROJECT IS NULL
	
	IF(@@ERROR<>0)	
		return -6
	

	DECLARE @RetVal INT

	--insert hours
	EXEC @RetVal = impWriteActualTableHours @IdImport
	if (@@ERROR <> 0 OR @RetVal < 0)
		return -7

	--insert costs
	EXEC @RetVal = impWriteActualTableCosts @IdImport
	if (@@ERROR <> 0 OR @RetVal < 0)
		return -8

	-- insert sales
	EXEC @RetVal = impWriteActualTableSales @IdImport
	if (@@ERROR <> 0 OR @RetVal < 0)
		return -9


	-- import is succesfully
	UPDATE IMPORT_LOGS
	SET Validation = 'G'
	WHERE IdImport = @IdImport

	-- Do all 4 checks for the current import (hours, hoursval, costval, salesval)
	EXEC @RetVal = impCheckImportedDataConsistency @IdImport
	if (@@ERROR <> 0 OR @RetVal < 0)
	BEGIN
		-- import is not succesfully
		UPDATE IMPORT_LOGS
		SET Validation = 'R'
		WHERE IdImport = @IdImport

		RETURN -10
	END




	
	--mark in tocompletion  data the yearmonth in whcih the actual data has reached with data

	DECLARE @updatedProjects table
	(
		IdProject INT NOT NULL PRIMARY KEY
	)

	INSERT INTO @updatedProjects (IdProject)
	(SELECT DISTINCT IdProject
	FROM ACTUAL_DATA_DETAILS_HOURS
	WHERE IdImport = @IdImport)
	UNION
	(SELECT DISTINCT IdProject
	FROM ACTUAL_DATA_DETAILS_SALES
	WHERE IdImport = @IdImport)
	UNION
	(SELECT DISTINCT IdProject
	FROM ACTUAL_DATA_DETAILS_COSTS
	WHERE IdImport = @IdImport)


	UPDATE  BT
	SET YearMonthActualData = 
			CASE WHEN ISNULL(BT.YearMonthActualData,190001)<@YEARMONTH 
			THEN	@YEARMONTH ELSE BT.YearMonthActualData END
	FROM BUDGET_TOCOMPLETION BT
	INNER JOIN @updatedProjects up
	ON 	bt.IdProject = up.IdProject AND 
	      	bt.IdGeneration = (SELECT MAX(BTC.IdGeneration)
						  FROM BUDGET_TOCOMPLETION AS BTC
						  WHERE BTC.IdProject = bt.IdProject)
		

END

GO

--Drops the Procedure impWriteToAnnualImportTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToAnnualImportTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToAnnualImportTable
GO

--sp_helptext impWriteToAnnualImportTable
--impWriteToAnnualImportTable 'D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\XLSROM012007.csv',4, 10
CREATE    PROCEDURE impWriteToAnnualImportTable
	@fileName 	nvarchar(400),
	@IdAssociate	int
	
AS

declare @Year int
SET @Year=SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),4,4)


DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END


-- create temporary table
	DECLARE @SQL varchar(2000)
	CREATE TABLE #tempTable 
	(		
		[Country] varchar(3),
		[Year] varchar(4), 
		[CostCenter]	varchar(15), 
		[ProjectCode] 	varchar(10), 
		[WPCode]	varchar(3), 
		[AccountNumber]	varchar(20),
		[Value1]	varchar(19), 
		[Value2]	varchar(19), 
		[Value3]	varchar(19), 
		[Value4]	varchar(19), 
		[Value5]	varchar(19), 
		[Value6]	varchar(19), 
		[Value7]	varchar(19), 
		[Value8]	varchar(19), 
		[Value9]	varchar(19), 
		[Value10]	varchar(19), 
		[Value11]	varchar(19), 
		[Value12]	varchar(19), 
		[Quantity1]	varchar(15),
		[Quantity2]	varchar(15),
		[Quantity3]	varchar(15),
		[Quantity4]	varchar(15),
		[Quantity5]	varchar(15),
		[Quantity6]	varchar(15),
		[Quantity7]	varchar(15),
		[Quantity8]	varchar(15),
		[Quantity9]	varchar(15),
		[Quantity10]	varchar(15),
		[Quantity11]	varchar(15),
		[Quantity12]	varchar(15),
		[CurrencyCode]	varchar(3), 
		[Date]	varchar(203)--,
		--[FunctionName]	varchar(30),
		--[CostCenterName]	varchar(30),
		--[ProjectName]	varchar(50),
		--[CostType]	varchar(50),
		--[InergyLocationName]	varchar(30)
	)

-- CREATE INDEX IndexCostCenter on #tempTable (Country, CostCenter)
-- CREATE INDEX IndexGLAccounts on #tempTable (Country, AccountNumber)
	

	DECLARE @RealFileName nvarchar(100)
	Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)
-- 	PRINT @RealFileName


	--fill the temporary table from file
	SET @SQL = 'BULK INSERT #tempTable FROM '''+ @FileName +
	''' WITH (FIELDTERMINATOR  = '';'',ROWTERMINATOR = ''\n'',FIRSTROW = 1,CODEPAGE = 1252,TABLOCK)
	ALTER TABLE #tempTable ADD  [IdRow] int Identity '
	EXEC(@SQL)

	--update [Date] field in case the imported file has additional columns
	UPDATE #tempTable SET [Date] = LEFT([Date], 8)


DECLARE @COMMAND NVARCHAR(2000)
SET @COMMAND = 'CREATE INDEX AnnualIndexCostCenter_'+CAST(@@SPID as varchar(10)) + ' on #tempTable (Country, CostCenter);'
SET @COMMAND = @COMMAND + 'CREATE INDEX AnnualIndexGLAccounts_' + CAST(@@SPID as varchar(10)) + '  on #tempTable (Country, AccountNumber)'
EXEC(@COMMAND) 

-- #####   GET RIDD OF THE RECORDS FROM EXCLUSION TABLES #######
			
	DELETE #tempTable
	FROM #tempTable t
	INNER JOIN ANNUAL_EXCLUSION_COST_CENTERS AEC
		ON t.Country = AEC.CountryCode AND
		   t.CostCenter = AEC.CostCenterCode

	SET @ROWCOUNTDELETED_CC = @@ROWCOUNT
-- PRINT @@ROWCOUNT

	DELETE #tempTable
	FROM #tempTable t
	INNER JOIN  ANNUAL_EXCLUSION_GL_ACCOUNTS AEG
		ON t.Country = AEG.CountryCode AND
		   t.AccountNumber = AEG.GLAccountCode

	SET @ROWCOUNTDELETED_GL = @@ROWCOUNT
-- PRINT @@ROWCOUNT

-- Check if previous import failed but it wrote some records in data tables
declare @IdImportOld int

select @IdImportOld = max(IdImport)
from ANNUAL_BUDGET_IMPORTS a
where [FileName] = @RealFileName

if @IdImportOld is not null 
   begin
	 if (select [Validation] from [ANNUAL_BUDGET_IMPORT_LOGS] where IdImport = @IdImportOld)  <> 'G'
	    begin
			delete ANNUAL_BUDGET_DATA_DETAILS_SALES where IdImport = @IdImportOld
			delete ANNUAL_BUDGET_DATA_DETAILS_COSTS where IdImport = @IdImportOld
			delete ANNUAL_BUDGET_DATA_DETAILS_HOURS where IdImport = @IdImportOld
		end
   end

-- 	############################################################

	--fill imports table
	DECLARE @IdImport INT
	SELECT @IdImport  = ISNULL(MAX(IdImport),0)+1 
	FROM ANNUAL_BUDGET_IMPORTS (TABLOCKX)

-- 	############################################################
		if exists(select IdRow from #tempTable
				where isnumeric(quantity1) = 0 or isnumeric(quantity2) = 0 or isnumeric(quantity3) = 0 or isnumeric(quantity4) = 0
				or isnumeric(quantity5) = 0 or isnumeric(quantity6) = 0 or isnumeric(quantity7) = 0 or isnumeric(quantity7) = 0
				or isnumeric(quantity8) = 0 or isnumeric(quantity9) = 0 or isnumeric(quantity10) = 0 or isnumeric(quantity11) = 0 or isnumeric(quantity12) = 0
				or isnumeric(Value1) = 0 or isnumeric(Value2) = 0 or isnumeric(Value3) = 0 or isnumeric(Value4) = 0
				or isnumeric(Value5) = 0 or isnumeric(Value6) = 0 or isnumeric(Value7) = 0 or isnumeric(Value7) = 0
				or isnumeric(Value8) = 0 or isnumeric(Value9) = 0 or isnumeric(Value10) = 0 or isnumeric(Value11) = 0 or isnumeric(Value12) = 0)

		  begin
				INSERT INTO [ANNUAL_BUDGET_IMPORTS]
					([IdImport], [ImportDate], [FileName], [IdAssociate], 
						ExclusionCostCenterRowsNo, ExclusionGlAccountsRowsNo)
				VALUES	(@IdImport,  GETDATE(),	   @RealFileName, @IdAssociate,
					@ROWCOUNTDELETED_CC, @ROWCOUNTDELETED_GL)


				INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
				( [IdImport],[Year], [Validation] )
				VALUES (@IDImport, @YEAR, 'R')


				INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
				( [IdImport], [IdRow], [Details], [Module] )
				select @IdImport, [IdRow],'Row ' + cast(IdRow as varchar) 
				+ case when isnumeric(quantity1) = 0 then ' column Quantity1 is not numeric' else '' end
				+ case when isnumeric(quantity2) = 0 then ' column Quantity2 is not numeric' else '' end
				+ case when isnumeric(quantity3) = 0 then ' column Quantity3 is not numeric' else '' end
				+ case when isnumeric(quantity4) = 0 then ' column Quantity4 is not numeric' else '' end
				+ case when isnumeric(quantity5) = 0 then ' column Quantity5 is not numeric' else '' end
				+ case when isnumeric(quantity6) = 0 then ' column Quantity6 is not numeric' else '' end
				+ case when isnumeric(quantity7) = 0 then ' column Quantity7 is not numeric' else '' end
				+ case when isnumeric(quantity8) = 0 then ' column Quantity8 is not numeric' else '' end
				+ case when isnumeric(quantity9) = 0 then ' column Quantity9 is not numeric' else '' end
				+ case when isnumeric(quantity10) = 0 then ' column Quantity10 is not numeric' else '' end
				+ case when isnumeric(quantity11) = 0 then ' column Quantity11 is not numeric' else '' end
				+ case when isnumeric(quantity12) = 0 then ' column Quantity12 is not numeric' else '' end
				,null
				from #tempTable
				where isnumeric(quantity1) = 0 or isnumeric(quantity2) = 0 or isnumeric(quantity3) = 0 or isnumeric(quantity4) = 0
				or isnumeric(quantity5) = 0 or isnumeric(quantity6) = 0 or isnumeric(quantity7) = 0 or isnumeric(quantity7) = 0
				or isnumeric(quantity8) = 0 or isnumeric(quantity9) = 0 or isnumeric(quantity10) = 0 or isnumeric(quantity11) = 0 or isnumeric(quantity12) = 0

				INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
				( [IdImport], [IdRow], [Details], [Module] )
				select @IdImport, [IdRow],'Row ' + cast(IdRow as varchar) 
				+ case when isnumeric(Value1) = 0 then ' column Value1 is not numeric' else '' end
				+ case when isnumeric(Value2) = 0 then ' column Value2 is not numeric' else '' end
				+ case when isnumeric(Value3) = 0 then ' column Value3 is not numeric' else '' end
				+ case when isnumeric(Value4) = 0 then ' column Value4 is not numeric' else '' end
				+ case when isnumeric(Value5) = 0 then ' column Value5 is not numeric' else '' end
				+ case when isnumeric(Value6) = 0 then ' column Value6 is not numeric' else '' end
				+ case when isnumeric(Value7) = 0 then ' column Value7 is not numeric' else '' end
				+ case when isnumeric(Value8) = 0 then ' column Value8 is not numeric' else '' end
				+ case when isnumeric(Value9) = 0 then ' column Value9 is not numeric' else '' end
				+ case when isnumeric(Value10) = 0 then ' column Value10 is not numeric' else '' end
				+ case when isnumeric(Value11) = 0 then ' column Value11 is not numeric' else '' end
				+ case when isnumeric(Value12) = 0 then ' column Value12 is not numeric' else '' end
				,null
				from #tempTable
				where isnumeric(Value1) = 0 or isnumeric(Value2) = 0 or isnumeric(Value3) = 0 or isnumeric(Value4) = 0
				or isnumeric(Value5) = 0 or isnumeric(Value6) = 0 or isnumeric(Value7) = 0 or isnumeric(Value7) = 0
				or isnumeric(Value8) = 0 or isnumeric(Value9) = 0 or isnumeric(Value10) = 0 or isnumeric(Value11) = 0 or isnumeric(Value12) = 0
		  end
		else
		  begin
			INSERT INTO [ANNUAL_BUDGET_IMPORTS]
				([IdImport], [ImportDate], [FileName], [IdAssociate], 
					ExclusionCostCenterRowsNo, ExclusionGlAccountsRowsNo)
			VALUES	(@IdImport,  GETDATE(),	   @RealFileName, @IdAssociate,
				@ROWCOUNTDELETED_CC, @ROWCOUNTDELETED_GL)

			INSERT INTO [ANNUAL_BUDGET_IMPORT_DETAILS]
				( [IdImport], [IdRow], [Country]
				, [Year], [CostCenter]
				, [ProjectCode], [WPCode],[AccountNumber]
				, [Quantity1], [Quantity2], [Quantity3], [Quantity4] 
				, [Quantity5], [Quantity6], [Quantity7], [Quantity8] 
				, [Quantity9], [Quantity10], [Quantity11], [Quantity12]
				, [Value1], [Value2], [Value3], [Value4]
				, [Value5], [Value6], [Value7], [Value8]
				, [Value9], [Value10], [Value11], [Value12]
				, [CurrencyCode], [Date])

			SELECT @IdImport, [IdRow], RTRIM(LTRIM([Country])) 
				,RTRIM(LTRIM([Year])), RTRIM(LTRIM([CostCenter]))
				,RTRIM(LTRIM([ProjectCode])), RTRIM(LTRIM([WPCode])), RTRIM(LTRIM([AccountNumber]))
				,RTRIM(LTRIM([Quantity1])), RTRIM(LTRIM([Quantity2])), RTRIM(LTRIM([Quantity3])), RTRIM(LTRIM([Quantity4])) 
				,RTRIM(LTRIM([Quantity5])), RTRIM(LTRIM([Quantity6])), RTRIM(LTRIM([Quantity7])), RTRIM(LTRIM([Quantity8]))
				,RTRIM(LTRIM([Quantity9])), RTRIM(LTRIM([Quantity10])), RTRIM(LTRIM([Quantity11])), RTRIM(LTRIM([Quantity12])) 
				,RTRIM(LTRIM([Value1])), RTRIM(LTRIM([Value2])), RTRIM(LTRIM([Value3])), RTRIM(LTRIM([Value4])) 
				,RTRIM(LTRIM([Value5])), RTRIM(LTRIM([Value6])), RTRIM(LTRIM([Value7])), RTRIM(LTRIM([Value8])) 
				,RTRIM(LTRIM([Value9])), RTRIM(LTRIM([Value10])), RTRIM(LTRIM([Value11])), RTRIM(LTRIM([Value12]))
				,RTRIM(LTRIM([CurrencyCode])), RTRIM(LTRIM([Date]))
			FROM #tempTable
		  end

	RETURN @IdImport
	GO

/****** Object:  StoredProcedure [dbo].[dbo.impWriteToAnnualTable]    Script Date: 06/16/2014 17:30:08 ******/
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToAnnualTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToAnnualTable
GO



CREATE     PROCEDURE impWriteToAnnualTable
	@fileName 	nvarchar(400), 	--The name of the file	
	@IdImport INT,			-- ID of the import
	@SkipStartEndPhaseErrorsHours bit = 0, -- Skip Start/End Phase Validation for Hours/Vals
	@SkipStartEndPhaseErrorsCosts bit = 0, -- Skip Start/End Phase Validation for Costs
	@SkipStartEndPhaseErrorsSales bit = 0 -- Skip Start/End Phase Validation for Costs
AS

DECLARE @Year int
DECLARE @Country varchar(3)
DECLARE @Message varchar(200)
--#############BECAUSE THE FILENAME IS FIXED FORM WE CAN AFFORD TO TAKE THE YEAR FROM IT
-- 	DECLARE @fileName 	nvarchar(400)
-- 	SET @filename = 'D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\FRA2007_2007_9_4.csv'
	SET @Year=SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),4,4)
	set @Country = SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),1,3)
-- 	PRINT @YEAR
--#############################################################################################

	DECLARE @RetVal INT


	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

	-- Check if rows have imported into ANNUAL_BUDGET_IMPORT_DETAILS.
	-- If they don't and exist rows in ANNUAL_BUDGET_IMPORT_LOGS_DETAILS, this means
	-- that one of Quantity or Value columns was not numeric
	if exists(SELECT IdImport  FROM ANNUAL_BUDGET_IMPORTS WHERE IdImport = @IdImport)
	and not exists(select IdImport from ANNUAL_BUDGET_IMPORT_DETAILS WHERE IdImport = @IdImport)
	and exists(select IdImport from ANNUAL_BUDGET_IMPORT_LOGS_DETAILS WHERE IdImport = @IdImport)
	   begin
			SET @Message = 'There is at least one row in the imported file where there are not numeric Quantity or Value'
			RAISERROR(@Message, 16, 1)		
			RETURN -8
	   end

	IF EXISTS (SELECT IdImport
		   FROM ANNUAL_BUDGET_IMPORT_DETAILS
		   WHERE IdImport = @IdImport AND
			Country <> @Country AND 
			@Country <> 'All' )

	BEGIN
		SET @Message = 'There is at least one row in the imported file that do not belong to selected country: ' + @Country
		RAISERROR(@Message, 16, 1)		
		RETURN -1
	END

	IF EXISTS (SELECT IdImport
		   FROM ANNUAL_BUDGET_IMPORT_DETAILS
		   WHERE IdImport = @IdImport AND
			Year <> @Year )

	BEGIN
		SET @Message = 'There is at least one row in the imported file that do not belong to Year: ' + cast(@Year as varchar(4))
		RAISERROR(@Message, 16, 1)		
		RETURN -1
	END

	--check mandatory fields
	--#########################   INSERT INTO LOGS IF NULL OR NOT EXISTS
	
	
	IF EXISTS
	(
		SELECT IdImport 
		FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
		WHERE 
		IMD.IdImport = @IdImport
		AND
		
		(
			-- no country
			(IMD.Country IS NULL  OR 
				NOT EXISTS(SELECT ID 
						FROM COUNTRIES 
						WHERE CODE =IMD.Country)
			) 
			-- NO YEAR
			OR  IMD.Year IS NULL
			OR IMD.Year NOT BETWEEN 1900 and 2079
			-- NO cost center
			OR (IMD.CostCenter IS NULL
				OR NOT EXISTS
					(
						SELECT CC.Id 
						FROM COST_CENTERS CC 
						INNER JOIN INERGY_LOCATIONS IL 
							ON CC.IdInergyLocation = IL.ID 
						INNER JOIN Countries C 
							ON IL.IdCountry = C.Id						
						WHERE CC.CODE=IMD.CostCenter AND
						      C.Code =IMD.Country
					)
			   )
			--NO project code
			OR (IMD.ProjectCode IS NULL  OR 
				NOT EXISTS(SELECT ID FROM PROJECTS WHERE CODE=IMD.ProjectCode )
			    )
			-- Project is not of type CRAIN
			OR (left(IMD.ProjectCode,1) not in ('C','R','A','I','N','Z')
			)
			--NO WP code
			OR (IMD.WPCode IS NULL  
				OR NOT EXISTS(	SELECT TOP 1  WP.Code 
						FROM WORK_PACKAGES WP												
					      	INNER JOIN PROJECTS P
					      		ON P.Id	= WP.IdProject AND
							   P.Code = IMD.ProjectCode				
					     	WHERE WP.CODE = IMD.WPCode
					      )
			    )
            -- WPCode can be 0xy only and only for projects of type ZRAIN			    
			OR ( (IMD.WPCode like '0%' and left(IMD.ProjectCode,1) not in ('Z','R','A','I','N'))             )				  
			--NO Account Number
			OR (IMD.AccountNumber  IS NULL  OR 
					NOT EXISTS(SELECT GL.ID
						   FROM GL_ACCOUNTS GL 
						   INNER JOIN COUNTRIES C
							ON GL.IdCountry = C.Id 
						   WHERE Account = IMD.AccountNumber AND
							C.Code = IMD.Country )
			   )
			--NO Quantity
-- 			OR (IMD.Quantity IS NULL)
		)
		
	)
	
	BEGIN
		exec impWriteToLogAnnualTables @fileName, @IdImport
		RETURN -2
	END
	
-- 	CHECK TO SEE IF THERE ARE DUPLICATED KEY VALUES IN IMPORT TABLE
	DECLARE @ROWCOUNT INT


	IF EXISTS
	(SELECT Country, 
		ProjectCode,
		WPCode, 
		CostCenter,
		Year, 
		--Month, 
		AccountNumber
	FROM ANNUAL_BUDGET_IMPORT_DETAILS
	WHERE IdImport = @IdImport
	GROUP BY Country, ProjectCode, WPCode, CostCenter, Year, AccountNumber
	HAVING COUNT(ProjectCode) >1)		
	BEGIN
		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
		( [IdImport],[Year], [Validation] )
		VALUES (@IDImport, @YEAR, 'O')

		DECLARE @C VARCHAR(3), @Y int, 
		@CC VARCHAR(10), @PC VARCHAR(10),
		@WP VARCHAR(4), @AN VARCHAR(10)
		
		SET  @Message = 'There is at least another row which has the same Country + Year + CostCenter + ProjectCode + WPCode + AccountNumber as this row. This is not allowed.'

		DECLARE alog_cursor CURSOR FAST_FORWARD FOR
		SELECT 	Country, 
			ProjectCode,
			WPCode, 
			CostCenter,
			Year, 
			AccountNumber
		FROM ANNUAL_BUDGET_IMPORT_DETAILS
		WHERE IdImport = @IdImport
		GROUP BY Country, ProjectCode, WPCode, CostCenter, Year, AccountNumber
		HAVING COUNT(ProjectCode) >1

		OPEN alog_cursor
		FETCH NEXT FROM alog_cursor 
		INTO @C,@PC, @WP, @CC, @Y, @AN

		WHILE @@FETCH_STATUS = 0
		BEGIN
			INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
			([IdImport], [IdRow], [Details] )			
			SELECT @IdImport, IdRow, @Message
			FROM ANNUAL_BUDGET_IMPORT_DETAILS
			WHERE 	Country = @C AND
				Year = @Y AND
				CostCenter = @CC AND
				ProjectCode = @PC AND
				WPCode = @WP AND
				AccountNumber = @AN AND			
				IdImport = @IdImport

			FETCH NEXT FROM alog_cursor 
			INTO @C,@PC, @WP, @CC, @Y, @AN
		END
		CLOSE alog_cursor
		DEALLOCATE alog_cursor
		
		RETURN -3
	END


	--######################### IF NOT EXIST THEN DOCUMENT OK BEGIN IMPORT TO ANNUAL


	ELSE
	BEGIN
		

-- 		PRINT 'INSERT ANNUAL_BUDGET'
		INSERT INTO ANNUAL_BUDGET (IDProject, [Date])

		SELECT DISTINCT P.ID, GETDATE() 
		FROM Projects P 
		INNER JOIN ANNUAL_BUDGET_IMPORT_DETAILS IMD 
			ON P.Code = IMD.ProjectCode 
		LEFT JOIN ANNUAL_BUDGET AB
			ON AB.IdProject = P.ID
		WHERE IMD.IdImport = @IdImport
		AND AB.IdProject IS NULL	


		IF(@@ERROR<>0)
			RETURN -4
		

		--insert into hours table
		EXEC @RetVal = impWriteAnnualTableHours @IdImport, @SkipStartEndPhaseErrorsHours
		if (@@ERROR<>0 OR @RetVal < 0)
		   begin
			if @RetVal = -1000
			   return @RetVal
			else
				return -5
		   end

		-- insert into SALES table
		EXEC @RetVal = impWriteAnnualTableSales @IdImport, @SkipStartEndPhaseErrorsSales
		if (@@ERROR<>0 OR @RetVal < 0)
		   begin
			if @RetVal = -3000
			   return @RetVal
			else
				return -6
		   end
		
		--INSERT OTHER TYPE OF COSTS IN ANNUAL_BUDGET_DATA_DETAILS_COSTS
		EXEC @RetVal = impWriteAnnualTableDetailsCosts @IdImport, @SkipStartEndPhaseErrorsCosts
		if (@@ERROR<>0 OR @RetVal < 0)
		   begin
			if @RetVal = -2000
			   return @RetVal
			else
				return -7
		   end

		INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
			( [IdImport], [Year], [Validation] )
		VALUES (@IDImport, @YEAR, 'G')

	END



GO


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE Id = object_id(N'dbo.impWriteToBudgetRevisedTable') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToBudgetRevisedTable
GO

CREATE PROCEDURE dbo.impWriteToBudgetRevisedTable
	@IdImport INT,			-- Id of the import	
	@ForceDeleteExistingOpenBudget bit
AS	

	DECLARE @errMsg varchar(255)
	DECLARE @IdProject int

	--Verify if the IdImport exists
	IF NOT EXISTS(
		SELECT IBI.IdImport
		FROM IMPORT_BUDGET_REVISED IBI
		WHERE IBI.IdImport = @IdImport
	)
	BEGIN		
		SET @errMsg ='Import with Id ' + cast (@IdImport as varchar(3)) + ' was not found.' 
		RAISERROR(@errMsg , 16, 1 )
		RETURN -17
	END

	-- Verify preconditions
	IF EXISTS
	(
		SELECT IdImport 
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE IBI.IdImport = @IdImport
		AND		
		(
			--NO Country Code
			(ISNULL(IBI.CountryCode, '' ) = ''
			OR NOT EXISTS
			(
				SELECT C.Id 
				FROM COUNTRIES C
				WHERE C.Code = IBI.CountryCode
			))
			
			-- NO cost center
			OR (ISNULL(IBI.CostCenterCode, '' ) = '' 
			OR NOT EXISTS
			(
				SELECT CC.Id 
				FROM COST_CENTERS CC 
				INNER JOIN INERGY_LOCATIONS IL 
					ON CC.IdInergyLocation = IL.Id 
				INNER JOIN Countries C 
					ON IL.IdCountry = C.Id
				WHERE CC.CODE=IBI.CostCenterCode 
				AND C.Code = IBI.CountryCode
				AND CC.IsActive = 1
			))
			--NO project code
			OR (ISNULL(IBI.ProjectCode, '' ) = '' 
				OR NOT EXISTS
				(
					SELECT Id 
					FROM PROJECTS 
					WHERE CODE=IBI.ProjectCode 
				)
			)
			--NO WP code
			OR (IBI.WPCode IS NULL  OR 
			NOT EXISTS(SELECT TOP 1  WP.Code 
				   FROM WORK_PACKAGES WP
			      	   INNER JOIN PROJECTS P
					ON P.Id	= WP.IdProject 
					AND P.Code = IBI.ProjectCode				
			  	   WHERE WP.CODE = IBI.WPCode AND
					 WP.IsActive = 1))		
			--NO match between Currency_Code and Cost_Center_Code
			OR ISNULL(IBI.CurrencyCode, '' ) = '' 
			OR NOT EXISTS
			(
				SELECT * 
				FROM COUNTRIES C
				INNER JOIN CURRENCIES CURR
					ON C.IdCurrency = CURR.Id
				WHERE C.Code = IBI.CountryCode
		  		      AND CURR.Code = IBI.CurrencyCode
			)	
			--NO Account Number
			OR (ISNULL(IBI.AssociateNumber, '' ) = ''   
			OR NOT EXISTS
			   (
				SELECT A.Id 
				FROM ASSOCIATES A 
				WHERE A.EmployeeNumber = IBI.AssociateNumber 
			    )
			  )
			--Employee Number is dupplicate
			OR 
			(
				(SELECT COUNT(A.Id) 
				FROM ASSOCIATES A 
				WHERE A.EmployeeNumber = IBI.AssociateNumber) > 1
			) 
			
			--NO Project ready for Revised Budget
			OR NOT EXISTS
			(
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
				WHERE 
					P.CODE = IBI.ProjectCode 
					AND P.IsActive = 1
					AND WP.Code = IBI.WPCode
					AND WP.IsActive = 1
					AND WP.StartYearMonth IS NOT NULL 
					AND WP.EndYearMonth IS NOT NULL
				GROUP BY P.Id
			)
			--CHECK IF THE KEY ( ProjectCode, AssociateNumber, WPCode, CostCenterCode ) already exists 
			OR EXISTS
			(
				SELECT  BID.ProjectCode
				FROM IMPORT_BUDGET_REVISED_DETAILS BID 
				WHERE	IBI.ProjectCode = BID.ProjectCode AND
					IBI.WPCode = BID.WPCode AND
					BID.AssociateNumber = IBI.AssociateNumber AND
					BID.CountryCode = IBI.CountryCode AND
					BID.CostCenterCode = IBI.CostCenterCode
				group by  BID.ProjectCode, BID.WPCode, BID.AssociateNumber, BID.CountryCode, BID.CostCenterCode
				having count(*) > 1
			)
			OR NOT EXISTS
			(
				--CHECK CORE TEAM Members are active and not Project Readers
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN PROJECT_CORE_TEAMS  PT 
						ON P.Id = PT.IdProject
					INNER JOIN ASSOCIATES A 
						ON PT.IdAssociate = A.Id
				WHERE 
					P.Code = IBI.ProjectCode
					AND A.EmployeeNumber  = IBI.AssociateNumber
					AND PT.IsActive = 1  
					AND dbo.fnIsAssociateProjectReader(P.Id, A.Id ) <> 1
			)
			OR NOT EXISTS
			(
				--CHECK if there is an initial validated budget
				SELECT 
					bi.IdProject
					FROM PROJECTS p
					join BUDGET_INITIAL bi on bi.IdProject = p.Id
				WHERE 
					p.Code = IBI.ProjectCode and bi.IsValidated = 1
			)
			--CHECK the HoursQty, HoursVal, SalesVal as in UI
			OR (IBI.HoursQty IS NULL or IBI.HoursQty < 0) 
			OR (IBI.HoursVal IS NULL or IBI.HoursVal < 0)
			OR (IBI.SalesVal IS NULL)
			OR (IBI.TE is null or IBI.TE < 0)
			OR (IBI.ProtoParts is null or IBI.ProtoParts < 0)
			or (IBI.ProtoTooling is null or IBI.ProtoTooling < 0)
			or (IBI.Trials is null or IBI.Trials < 0)
			or (IBI.OtherExpenses is null or IBI.OtherExpenses < 0)

		)
		
	)	
	BEGIN
		CREATE TABLE #tempTable
		(
			IdImport int,
			IdRow int,
			Details varchar(500),
			Module char(3)
		)
		DECLARE @Module VARCHAR(50)
		DECLARE @Details varchar(500)
		
		--CHECK Country Code
		SELECT @Module = RTRIM(Code) FROM MODULES
		WHERE Name = N'Country'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		      'Country Code N/A!',
		       @Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE
		--NO Country Code
		ISNULL(IBI.CountryCode, '' ) = ''
		AND IBI.IdImport = @IdImport
		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		      'Country Code ''' + ISNULL( IBI.CountryCode, 'N/A' ) + ''' does not exist in Countries catalog.',
	 	      @Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE
		--NO CountryCode
		(NOT EXISTS
			(
				SELECT C.Id 
				FROM COUNTRIES C
				WHERE C.Code = IBI.CountryCode
			)
		)
		AND IBI.IdImport = @IdImport


		---- ########## CHECK 1
		SELECT @Module =  RTRIM(Code) FROM MODULES
		WHERE NAME =N'Cost Center'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Cost Center is N/A!'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE		
		-- NO cost center
		ISNULL(IBI.CostCenterCode, '' ) = ''
		AND IBI.IdImport = @IdImport
			
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,	
			'Cost Center '''  + ISNULL(IBI.CostCenterCode, 'N/A')  + ''' is not active or does not exists for Country Code ''' + ISNULL(IBI.CountryCode, 'N\A') + ''
			,@Module		
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE			
		-- NO cost center
		( NOT EXISTS
			(
				SELECT CC.Id 
				FROM COST_CENTERS CC 
				INNER JOIN INERGY_LOCATIONS IL 
				        ON CC.IdInergyLocation = IL.Id 
				INNER JOIN COUNTRIES C 
					ON IL.IdCountry = C.Id
				WHERE CC.CODE = IBI.CostCenterCode
				AND C.Code = IBI.CountryCode
				AND CC.IsActive = 1
				
			)
		)
		AND IBI.IdImport = @IdImport
	
		---- ########## CHECK 2
		SELECT @Module =  RTRIM(Code) FROM MODULES
		WHERE NAME =N'Project'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow, 
			'Project Code field is N/A!'
			,@Module	
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO project code
		ISNULL(IBI.ProjectCode, '' ) = ''
		AND IBI.IdImport = @IdImport
		
	
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Project Code '''  + ISNULL(IBI.ProjectCode,'N/A') + ''' does not exist in Projects catalog!',
			@Module			
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO project code
		( NOT EXISTS
			(
				SELECT Id 
				FROM PROJECTS 
				WHERE CODE=IBI.ProjectCode
			)
		)
		AND IBI.IdImport = @IdImport 
	
		
		---- ########## CHECK 3
		SELECT @Module =  RTRIM(Code) FROM MODULES 
		WHERE NAME =N'Work Package'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Work Package Code is N/A!'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO WP code
		ISNULL(IBI.WPCode, '' ) = ''
		AND IBI.IdImport = @IdImport			
		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Work Package Code '''  + ISNULL(IBI.WPCode,'N/A') + ''' does not exist or is inactive for Project Code ''' + ISNULL(IBI.ProjectCode,'N/A') + '''!'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO WP code
		( NOT EXISTS(
				SELECT TOP 1  WP.Code 
			      	FROM WORK_PACKAGES WP
			      	INNER JOIN PROJECTS P
			      		ON WP.IdProject = P.Id					
			     	WHERE WP.CODE = IBI.WPCode AND
				      Wp.IsActive = 1 AND	
				      P.Code = IBI.ProjectCode				      
			     )
		)				
		AND IBI.IdImport = @IdImport 
			
		---- ########## CHECK 4
		SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Associate'
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number is N/A!'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		ISNULL(IBI.AssociateNumber, '' ) = ''
		AND IBI.IdImport = @IdImport
				
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number '  + ISNULL(IBI.AssociateNumber,'N/A') + ' does not exist in Associates catalogue.'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO Associate Number
		( NOT EXISTS
			(
				SELECT Id 
				FROM ASSOCIATES 
				WHERE EmployeeNumber = IBI.AssociateNumber 
			)
		)
		AND IBI.IdImport = @IdImport 

		--AssociateNumber found in more than one country
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number '''  + ISNULL(IBI.AssociateNumber,'N/A') + ''' was found in ' +  
					(SELECT cast(count(Id) as varchar(3)) as AssociateCount
					 FROM ASSOCIATES 
					 WHERE EmployeeNumber = IBI.AssociateNumber
					 GROUP BY EmployeeNumber
					 HAVING count(*)>1)
				 + ' countries. Associate cannot be unique identified. Process cannot continue.'
			,@Module
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE   (SELECT Count(Id) 
			 FROM ASSOCIATES 
			 WHERE EmployeeNUmber = IBI.AssociateNumber) > 1 AND		
		IBI.IdImport = @IdImport
	
		---- ########## CHECK 5		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Currency Code is N/A!'
			,NULL
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO Currency Code
		ISNULL(IBI.CurrencyCode, '' ) = ''
		AND IBI.IdImport = @IdImport
				
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Currency Code '''  + ISNULL(IBI.CurrencyCode,'N/A') + ''' does not match the currency for Country code ''' + IBI.CountryCode + ''
			,NULL
		FROM IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE 
		--NO Currency Code
		( NOT EXISTS
			(
				SELECT * 
				FROM COUNTRIES C
				INNER JOIN CURRENCIES CURR
					ON C.IdCurrency = CURR.Id
				WHERE C.Code = IBI.CountryCode
		  		      AND CURR.Code = IBI.CurrencyCode										
			)
		) 
		AND IBI.IdImport = @IdImport 
		
		-- CHECK if the Projects are validated
		IF EXISTS
		(
				SELECT IBI.IdImport
				FROM IMPORT_BUDGET_REVISED_DETAILS IBI
				join Projects p on IBI.ProjectCode = p.Code
				left join BUDGET_INITIAL bi on bi.IdProject = p.Id
			WHERE 
				IBI.IdImport = @IdImport and (bi.IdProject is null or bi.IsValidated=0)
		)
			INSERT INTO #tempTable
			(IdImport, IdRow, Details, Module)
			SELECT distinct @IdImport, IBI.IdRow,
				'Project ' + IBI.ProjectCode + ' hasn''t an initial validated budget',NULL
			FROM IMPORT_BUDGET_REVISED_DETAILS IBI
			join Projects p on IBI.ProjectCode = p.Code
			left join BUDGET_INITIAL bi on bi.IdProject = p.Id 
			where IBI.IdImport = @IdImport and (bi.IdProject is null or bi.IsValidated=0)


		--CHECK if the project is ready for Revised Budget ( with explicit messages )
		IF EXISTS
		(
			SELECT IBI.IdImport				
			FROM IMPORT_BUDGET_REVISED_DETAILS IBI
			WHERE			
			NOT EXISTS
			(
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
				WHERE 
					P.CODE = IBI.ProjectCode 
					AND P.IsActive = 1
					AND WP.Code = IBI.WPCode
					AND WP.StartYearMonth IS NOT NULL 
					AND WP.EndYearMonth IS NOT NULL
				GROUP BY P.Id
			)
			AND IBI.IdImport = @IdImport	
		)
		BEGIN
			--CHECK IF THE PROJECT IS ACTIVE
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Revised Budget ( Project is not active ).',
				NULL
			FROM IMPORT_BUDGET_REVISED_DETAILS IBI
			WHERE
			EXISTS 
			(
				SELECT P.ID
				FROM PROJECTS P 
				WHERE P.Code = IBI.ProjectCode
				AND P.IsActive = 0
			)
			AND IBI.IdImport = @IdImport
			--CHECK IF THE WORK PACKAGE IS ACTIVE AND WITH DEFINED PERIOD
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Revised Budget ( Project does not have WPs with defined period ).',
				NULL
			FROM IMPORT_BUDGET_REVISED_DETAILS IBI
			WHERE
			(
				EXISTS 
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject							
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
						AND (WP.StartYearMonth IS NULL  OR WP.EndYearMonth IS NULL )
				)
				OR
				NOT EXISTS
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject							
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
				)
			)
			AND IBI.IdImport = @IdImport

			--CHECK IF THE PROJECT HAS INTERCO DEFINED
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Revised Budget ( Project has no interco defined ).',
				NULL
			FROM IMPORT_BUDGET_REVISED_DETAILS IBI
			WHERE
			(
				NOT EXISTS 
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
				)
			)			
		END								


		--CHECK If the Core Team is active and not a project reader
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Core Member with Associate number ''' + ISNULL( IBI.AssociateNumber, 'N/A' ) + ''' is not active or is a project reader.',
			NULL
		FROM
			IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE
		NOT EXISTS
		(
			SELECT 
				P.Id 
			FROM 
				PROJECTS P
				INNER JOIN PROJECT_CORE_TEAMS  PT 
					ON P.Id = PT.IdProject
				INNER JOIN ASSOCIATES A 
					ON PT.IdAssociate = A.Id
			WHERE 
				P.Code = IBI.ProjectCode
				AND A.EmployeeNumber  = IBI.AssociateNumber
				AND PT.IsActive = 1				
				AND dbo.fnIsAssociateProjectReader(P.Id, A.Id ) <> 1
		)
		AND IBI.IdImport = @IdImport
		

		--CHECK if the KEY( IdProject, IdAssociate, IdWorkPackage, IdCostCenter ) exists
		INSERT INTO #tempTable
		(
			idImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		       'The key (Project ''' + ISNULL(IBI.ProjectCode, 'N/A') + ''', AssociateNumber ''' + ISNULL(IBI.AssociateNumber, 'N/A') + ''', WPCode ''' + ISNULL(IBI.WPCode, 'N/A') + ''', CostCenterCode ''' + ISNULL(IBI.CostCenterCode, 'N/A') + ''' ) is duplicated in the imported file.',
			NULL
			from IMPORT_BUDGET_REVISED_DETAILS IBI
			join
			(
				SELECT  BID.ProjectCode, BID.WPCode, BID.AssociateNumber, BID.CountryCode, BID.CostCenterCode
				FROM IMPORT_BUDGET_REVISED_DETAILS BID 
				where IdImport = @IdImport
				group by  BID.ProjectCode, BID.WPCode, BID.AssociateNumber, BID.CountryCode, BID.CostCenterCode
				having count(*) > 1
			) BID on IBI.ProjectCode = BID.ProjectCode AND
					IBI.WPCode = BID.WPCode AND
					BID.AssociateNumber = IBI.AssociateNumber AND
					BID.CountryCode = IBI.CountryCode AND
					BID.CostCenterCode = IBI.CostCenterCode
		WHERE
			IBI.IdImport = @IdImport 


		--CHECK if HoursQty, HoursVal, SalesVal follow the same rules as in UI
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			case when  IBI.HoursQty is null or IBI.HoursQty <0 then 'HoursQty ''' + rtrim(ISNULL(CONVERT(char(20), IBI.HoursQty), 'N/A')) + ''' must be a non-empty, non-negative number.' else '' end  + case when IBI.HoursVal is null or IBI.HoursVal < 0 then 'HoursVal ''' +  rtrim(ISNULL(CONVERT(char(20),IBI.HoursVal), 'N/A')) + ''' must be a non-empty, non-negative number.' else '' end + case when IBI.SalesVal is null then 'Sales must be a not-empty number.' else '' end +  case when IBI.TE is null or IBI.ProtoParts is null or IBI.ProtoTooling is null or IBI.Trials is null  or IBI.OtherExpenses is null or IBI.TE < 0 or IBI.ProtoParts < 0 or IBI.ProtoTooling < 0 or IBI.Trials < 0 or IBI.OtherExpenses < 0 then 'T&E, Proto Parts, Proto Tooling, Trials, Other Expenses must be non-empty, non-negative numbers: ''' + rtrim(ISNULL(cast(IBI.TE as varchar), 'N/A')) + ''', ''' + rtrim(ISNULL(CONVERT(char(20), IBI.ProtoParts), 'N/A')) + ''', ''' + rtrim(ISNULL(CONVERT(char(20), IBI.ProtoTooling), 'N/A')) + ''', ''' + rtrim(ISNULL(CONVERT(char(20), IBI.Trials), 'N/A')) + ''', ''' + rtrim(ISNULL(CONVERT(char(20), IBI.OtherExpenses), 'N/A')) + '''' else '' end,
			NULL
		FROM
			IMPORT_BUDGET_REVISED_DETAILS IBI
		WHERE
			IBI.IdImport = @IdImport AND
			(IBI.HoursQty IS NULL or IBI.HoursQty < 0
			OR IBI.HoursVal IS NULL or IBI.HoursVal  < 0
			OR IBI.SalesVal IS NULL 
			OR IBI.TE is null or IBI.TE < 0
			OR IBI.ProtoParts is null or IBI.ProtoParts < 0
			or IBI.ProtoTooling is null or IBI.ProtoTooling < 0
			or IBI.Trials is null or IBI.Trials < 0
			or IBI.OtherExpenses is null or IBI.OtherExpenses < 0)


		SELECT TOP 1 @Details ='IdRow = ' + cast(IdRow as varchar) + ' ' + Details FROM #tempTable
		
		IF @@RowCount > 0
		BEGIN
			RAISERROR( @Details,16,1)
			RETURN -1
		END
	END		
	
	if @ForceDeleteExistingOpenBudget = 1
	-- Delete the existing InProgress version
	   begin
	    DECLARE @IdGenerationInProgress INT
		declare @IdProj int
		select top 1 @IdProj = p.Id 
		from IMPORT_BUDGET_REVISED_DETAILS a
		join PROJECTS p on a.ProjectCode = p.Code
		where a.IdImport = @IdImport

		SELECT  @IdGenerationInProgress = dbo.fnGetRevisedBudgetGeneration(@IdProj,'N')

		if @IdGenerationInProgress is not null
		   delete BUDGET_REVISED_DETAIL_COSTS where IdGeneration = @IdGenerationInProgress and IdProject = @IdProj
		   delete BUDGET_REVISED_DETAIL where IdGeneration = @IdGenerationInProgress and IdProject = @IdProj
		   delete from BUDGET_REVISED_STATES where IdProject = @IdProj and IdGeneration = @IdGenerationInProgress
		   delete from BUDGET_REVISED where IdProject = @IdProj and IdGeneration = @IdGenerationInProgress
	   end

	--Declare the cursor for import the data
	DECLARE RevisedBudgetData CURSOR FAST_FORWARD FOR
		SELECT
			IdRow,
			ProjectCode,
			WPCode,	
			AssociateNumber,
			CountryCode,
			CostCenterCode,
			HoursQty,
			HoursVal,
			SalesVal,
			TE,	
			ProtoParts,
			ProtoTooling,
			Trials,
			OtherExpenses,
			CurrencyCode
		FROM IMPORT_BUDGET_REVISED_DETAILS
		WHERE IdImport = @IdImport	
		order by AssociateNumber
	
	
	DECLARE @IdRow int	
	DECLARE @ProjectCode varchar(10)
	DECLARE @WPCode varchar(4)
	DECLARE @AssociateNumber varchar(15)
	DECLARE @CountryCode varchar(3)
	DECLARE @CostCenterCode varchar(10)
	DECLARE @HoursQty int
	DECLARE @HoursVal decimal(18,4)
	DECLARE @SalesVal decimal(18,4)
	DECLARE @TE decimal(18,4)
	DECLARE @ProtoParts decimal(18,4)
	DECLARE @ProtoTooling decimal(18,4)
	DECLARE @Trials decimal(18,4)
	DECLARE @OtherExpenses decimal(18,4)
	DECLARE @CurrencyCode varchar(3),
		@IdCountry INT

	DECLARE @IdTE int
	DECLARE @IdProtoParts int
	DECLARE @IdProtoTooling int
	DECLARE @IdTrials int
	DECLARE @IdOtherExpenses int
	
	DECLARE @RetVal int 
	DECLARE @IdCurrentProject int
	DECLARE @IdCurrentAssociate int
	DECLARE @IdGenerationNew INT = 0

	SET @IdCurrentProject   = -1
	SET @IdCurrentAssociate = -1

	--Getting the id's for BUDGET_COST_TYPES
	SELECT @IdTE = dbo.fnGetBudgetOtherCostType('T&E'),
	       @IdProtoParts = dbo.fnGetBudgetOtherCostType('Proto parts'),
	       @IdProtoTooling = dbo.fnGetBudgetOtherCostType('Proto tooling'),
	       @IdTrials = dbo.fnGetBudgetOtherCostType('Trials'),
	       @IdOtherExpenses = dbo.fnGetBudgetOtherCostType('Other expenses')
			
	OPEN RevisedBudgetData
	FETCH NEXT FROM RevisedBudgetData INTO @IdRow, @ProjectCode, @WPCode, @AssociateNumber, @CountryCode, 
		@CostCenterCode, @HoursQty, @HoursVal, @SalesVal, @TE, @ProtoParts, @ProtoTooling, @Trials, 
		@OtherExpenses, @CurrencyCode
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		DECLARE @IdPhase int
		DECLARE @IdWP int
		DECLARE @IdCostCenter int
		DECLARE @IdAssociate int
		DECLARE @YearMonth int		

		--transform usual code into Id
		SELECT @IdProject = Id 
		FROM PROJECTS P 
		WHERE P.Code = @ProjectCode
	
		SELECT  @IdPhase = IdPhase, 
			@IdWP = Id, 
			@YearMonth = StartYearMonth 
		FROM WORK_PACKAGES WP 
		WHERE WP.IdProject =@IdProject AND 
		      WP.Code = @WPCode

		SELECT @IdCountry = Id
		FROM COUNTRIES C
		WHERE   C.Code = @CountryCode
	
		SELECT @IdCostCenter = CC.Id 
		FROM COST_CENTERS CC 	
		INNER JOIN INERGY_LOCATIONS IL 
		        ON CC.IdInergyLocation = IL.Id 
		WHERE   IL.IdCountry = @IdCountry AND
			CC.Code = @CostCenterCode

		SELECT @IdAssociate = Id 
		FROM ASSOCIATES A 
		WHERE A.EmployeeNumber = @AssociateNumber
		
		--Prepare the Insertion
		IF ( @IdCurrentProject <> @IdProject )
		BEGIN 
			SET @IdCurrentProject = @IdProject
			select @IdGenerationNew = isnull(max(IdGeneration),0) + 1
									FROM BUDGET_REVISED TABLOCKX
									WHERE 	IdProject = @IdProject AND
									IsValidated = 1
			insert into BUDGET_REVISED
			select @IdProject, @IdGenerationNew, 0, getdate()
			IF ( @@ERROR <> 0 OR @RetVal < 0 )
			BEGIN
				CLOSE RevisedBudgetData
				DEALLOCATE RevisedBudgetData
				return -2
			END
		END
			
		IF ( @IdCurrentAssociate <> @IdAssociate )
		BEGIN
			SET @IdCurrentAssociate = @IdAssociate
			-- insert state
			INSERT INTO BUDGET_REVISED_STATES
				(IdProject, IdGeneration, IdAssociate, State, StateDate)
			VALUES 
				(@IdProject, @IdGenerationNew, @IdAssociate, 'U', GETDATE())

			IF( @@ERROR <> 0)
			BEGIN
				CLOSE RevisedBudgetData
				DEALLOCATE RevisedBudgetData
				return -3
			END
		END

		exec @RetVal = bgtInsertRevisedBudgetDetail @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -4
		END

		exec @RetVal = bgtUpdateRevisedBudgetDetailForUplodRevisedBudget @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @HoursQty, @SalesVal
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -5
		END

		exec @RetVal = bgtInsertRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTE
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN	
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -6
		END
			
		exec @RetVal = bgtUpdateRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTE, @TE
		IF (@@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -7
		END
		
		exec @RetVal = bgtInsertRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoParts
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -8
		END
		
		exec @RetVal = bgtUpdateRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoParts, @ProtoParts
		IF ( @@ERROR <> 0 OR @RetVal < 0 ) 
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -9
		END

		exec @RetVal = bgtInsertRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoTooling
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -10
		END
		
		exec @RetVal = bgtUpdateRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoTooling, @ProtoTooling
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -11
		END

		exec @RetVal = bgtInsertRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTrials
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -12
		END
		
		exec @RetVal = bgtUpdateRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTrials, @Trials
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -13
		END

		exec @RetVal = bgtInsertRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdOtherExpenses
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -14
		END
		
		exec @RetVal = bgtUpdateRevisedBudgetOtherCosts @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdOtherExpenses, @OtherExpenses
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			return -15
		END
		
		FETCH NEXT FROM RevisedBudgetData INTO @IdRow, @ProjectCode, @WPCode, @AssociateNumber, @CountryCode
		, @CostCenterCode, @HoursQty, @HoursVal, @SalesVal, @TE, @ProtoParts, @ProtoTooling, @Trials
		, @OtherExpenses, @CurrencyCode


	END
	CLOSE RevisedBudgetData
	DEALLOCATE RevisedBudgetData

	--Group by IdProject, IdPhase, IdWp
	CREATE TABLE #BudgetRevised
	(
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL ,
		IdWP INT NOT NULL,
		StartYearMonth int NULL,
		EndYearMonth int NULL
	)
	INSERT INTO #BudgetRevised(IdProject, IdPhase, IdWP, StartYearMonth, EndYearMonth)	
	SELECT 
		BId.IdProject,
		BId.IdPhase,
		BId.IdWorkPackage,
		NULL,
		NULL
	FROM 
		BUDGET_REVISED_DETAIL BId
	WHERE 
		BId.IdProject = @IdProject
	GROUP BY 
		BId.IdProject, 
		BId.IdPhase, 
		BId.IdWorkPackage
	
	UPDATE t
	SET StartYearMonth = wp.StartYearMonth,
	    EndYearMonth =  wp.EndYearMonth
	FROM #BudgetRevised t
	INNER JOIN WORK_PACKAGES wp
		on t.IdProject = wp.IdProject AND 
		   t.IdPhase = wp.IdPhase AND
		   t.IdWP = wp.Id
		
	--Prepare to split the data
	DECLARE RevisedBudgetData CURSOR FAST_FORWARD FOR
		SELECT
			IdProject,
			IdPhase,
			IdWP,
			StartYearMonth,
			EndYearMonth
		FROM #BudgetRevised	
	SET @IdProject = NULL
	SET @IdPhase = NULL
	SET @IdWp = NULL
	DECLARE @StartYearMonth int
	DECLARE @EndYearMonth int
		
	OPEN RevisedBudgetData	
	FETCH NEXT FROM RevisedBudgetData INTO @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
	WHILE @@FETCH_STATUS = 0
	BEGIN
		exec @RetVal = bgtUpdateRevisedWPPeriod @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE RevisedBudgetData
			DEALLOCATE RevisedBudgetData
			DROP TABLE #BudgetRevised
			return -16
		END	
		
		FETCH NEXT FROM RevisedBudgetData INTO @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
	END
	CLOSE RevisedBudgetData
	DEALLOCATE RevisedBudgetData	

	if @IdGenerationNew > 1
	   begin
		
			select a.IdAssociate 
			into #tenpAssociatesToBeNulledInNewVersion
			from
			(
	   			select IdAssociate 
				from BUDGET_REVISED_STATES a
				where IdGeneration=@IdGenerationNew - 1
				and IdProject=@IdProject
			) a
			left join
			(
	   			select IdAssociate
				from BUDGET_REVISED_STATES a
				where IdGeneration=@IdGenerationNew
				and IdProject=@IdProject
			) b on a.IdAssociate = b.IdAssociate
			where b.IdAssociate is  null

			insert into BUDGET_REVISED_DETAIL
			select IdProject, @IdGenerationNew, IdPhase, IdWorkPackage, IdCostCenter, a.IdAssociate, YearMonth,0,0,0,IdCountry,IdAccountHours,IdAccountSales
			from BUDGET_REVISED_DETAIL  a
			join #tenpAssociatesToBeNulledInNewVersion b on a.IdAssociate = b.IdAssociate
			where IdProject=@IdProject
			and IdGeneration = @IdGenerationNew - 1

			insert BUDGET_REVISED_DETAIL_COSTS
			select IdProject, @IdGenerationNew, IdPhase, IdWorkPackage, IdCostCenter, a.IdAssociate, YearMonth, IdCostType,0,IdCountry,IdAccount
			from BUDGET_REVISED_DETAIL_COSTS a 
			join #tenpAssociatesToBeNulledInNewVersion b on a.IdAssociate = b.IdAssociate
			where IdProject=@IdProject
			and IdGeneration = @IdGenerationNew - 1
	   end


GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE Id = object_id(N'dbo.impWriteToBudgetTable') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToBudgetTable
GO

CREATE PROCEDURE dbo.impWriteToBudgetTable
	@IdImport INT			-- Id of the import	
AS	

	DECLARE @errMsg varchar(255)

	--Verify if the IdImport exists
	IF NOT EXISTS(
		SELECT IBI.IdImport
		FROM IMPORT_BUDGET_INITIAL IBI
		WHERE IBI.IdImport = @IdImport
	)
	BEGIN		
		SET @errMsg ='Import with Id ' + cast (@IdImport as varchar(3)) + ' was not found.' 
		RAISERROR(@errMsg , 16, 1 )
		RETURN -17
	END

	-- Verify preconditions
	IF EXISTS
	(
		SELECT IdImport 
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE IBI.IdImport = @IdImport
		AND		
		(
			--NO Country Code
			(ISNULL(IBI.CountryCode, '' ) = ''
			OR NOT EXISTS
			(
				SELECT C.Id 
				FROM COUNTRIES C
				WHERE C.Code = IBI.CountryCode
			))
			
			-- NO cost center
			OR (ISNULL(IBI.CostCenterCode, '' ) = '' 
			OR NOT EXISTS
			(
				SELECT CC.Id 
				FROM COST_CENTERS CC 
				INNER JOIN INERGY_LOCATIONS IL 
					ON CC.IdInergyLocation = IL.Id 
				INNER JOIN Countries C 
					ON IL.IdCountry = C.Id
				WHERE CC.CODE=IBI.CostCenterCode 
				AND C.Code = IBI.CountryCode
				AND CC.IsActive = 1
			))
			--NO project code
			OR (ISNULL(IBI.ProjectCode, '' ) = '' 
				OR NOT EXISTS
				(
					SELECT Id 
					FROM PROJECTS 
					WHERE CODE=IBI.ProjectCode 
				)
			)
			--NO WP code
			OR (IBI.WPCode IS NULL  OR 
			NOT EXISTS(SELECT TOP 1  WP.Code 
				   FROM WORK_PACKAGES WP
			      	   INNER JOIN PROJECTS P
					ON P.Id	= WP.IdProject 
					AND P.Code = IBI.ProjectCode				
			  	   WHERE WP.CODE = IBI.WPCode AND
					 WP.IsActive = 1))		
			--NO match between Currency_Code and Cost_Center_Code
			OR ISNULL(IBI.CurrencyCode, '' ) = '' 
			OR NOT EXISTS
			(
				SELECT * 
				FROM COUNTRIES C
				INNER JOIN CURRENCIES CURR
					ON C.IdCurrency = CURR.Id
				WHERE C.Code = IBI.CountryCode
		  		      AND CURR.Code = IBI.CurrencyCode
			)	
			--NO Account Number
			OR (ISNULL(IBI.AssociateNumber, '' ) = ''   
			OR NOT EXISTS
			   (
				SELECT A.Id 
				FROM ASSOCIATES A 
				WHERE A.EmployeeNumber = IBI.AssociateNumber 
			    )
			  )
			--Employee Number is dupplicate
			OR 
			(
				(SELECT COUNT(A.Id) 
				FROM ASSOCIATES A 
				WHERE A.EmployeeNumber = IBI.AssociateNumber) > 1
			) 
			
			--NO Project ready for Initial Budget
			OR NOT EXISTS
			(
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
				WHERE 
					P.CODE = IBI.ProjectCode 
					AND P.IsActive = 1
					AND WP.Code = IBI.WPCode
					AND WP.IsActive = 1
					AND WP.StartYearMonth IS NOT NULL 
					AND WP.EndYearMonth IS NOT NULL
				GROUP BY P.Id
			)
			--CHECK IF THE KEY ( IdProject, IdAssociate, IdWorkPackage, IdCostCenter ) already exists 
			OR EXISTS
			(
				SELECT  BID.IdProject AS Id,
					BID.IdProject AS IdWorkPackage,
					BID.IdAssociate AS IdAssociate,
					BID.IdCostCenter AS IdCostCenter	 
				FROM BUDGET_INITIAL_DETAIL BID
				INNER JOIN PROJECTS P
					ON BID.IdProject = P.Id
				INNER JOIN WORK_PACKAGES WP 
					ON BID.IdProject = WP.IdProject AND
					   BID.IdPhase = WP.IdPhase AND
					   BID.IdWorkPackage = WP.Id
				INNER JOIN ASSOCIATES A 
					ON BID.IdAssociate = A.Id
				INNER JOIN COUNTRIES C
					ON BID.IdCountry = C.Id
				INNER JOIN COST_CENTERS CC
					ON BID.IdCostCenter = CC.Id
				WHERE	IBI.ProjectCode = P.Code AND
					IBI.WPCode = WP.Code AND
					A.EmployeeNumber = IBI.AssociateNumber AND
					C.Code = IBI.CountryCode AND
					CC.Code = IBI.CostCenterCode
			)
			OR NOT EXISTS
			(
				--CHECK CORE TEAM Members are active and not Project Readers
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN PROJECT_CORE_TEAMS  PT 
						ON P.Id = PT.IdProject
					INNER JOIN ASSOCIATES A 
						ON PT.IdAssociate = A.Id
				WHERE 
					P.Code = IBI.ProjectCode
					AND A.EmployeeNumber  = IBI.AssociateNumber
					AND PT.IsActive = 1  
					AND dbo.fnIsAssociateProjectReader(P.Id, A.Id ) <> 1
			)
			--CHECK the HoursQty, HoursVal, SalesVal as in UI
			OR (IBI.HoursQty IS NULL OR IBI.HoursQty < 0) 
			OR (IBI.HoursVal IS NULL OR IBI.HoursVal < 0)
			OR IBI.SalesVal IS NULL
		)
		
	)	
	BEGIN
		CREATE TABLE #tempTable
		(
			IdImport int,
			IdRow int,
			Details varchar(255),
			Module char(3)
		)
		DECLARE @Module VARCHAR(50)
		DECLARE @Details varchar(255)
		
		--CHECK Country Code
		SELECT @Module = RTRIM(Code) FROM MODULES
		WHERE Name = N'Country'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		       'Country Code N/A!',
		       @Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE
		--NO Country Code
		ISNULL(IBI.CountryCode, '' ) = ''
		AND IBI.IdImport = @IdImport
		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		      'Country Code ''' + ISNULL( IBI.CountryCode, 'N/A' ) + ''' does not exist in Countries catalog.',
	 	      @Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE
		--NO CountryCode
		(NOT EXISTS
			(
				SELECT C.Id 
				FROM COUNTRIES C
				WHERE C.Code = IBI.CountryCode
			)
		)
		AND IBI.IdImport = @IdImport


		---- ########## CHECK 1
		SELECT @Module =  RTRIM(Code) FROM MODULES
		WHERE NAME =N'Cost Center'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Cost Center is N/A!'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE		
		-- NO cost center
		ISNULL(IBI.CostCenterCode, '' ) = ''
		AND IBI.IdImport = @IdImport
			
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,	
			'Cost Center '''  + ISNULL(IBI.CostCenterCode, 'N/A')  + ''' is not active or does not exists for Country Code ''' + ISNULL(IBI.CountryCode, 'N\A') + ''
			,@Module		
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE			
		-- NO cost center
		( NOT EXISTS
			(
				SELECT CC.Id 
				FROM COST_CENTERS CC 
				INNER JOIN INERGY_LOCATIONS IL 
				        ON CC.IdInergyLocation = IL.Id 
				INNER JOIN COUNTRIES C 
					ON IL.IdCountry = C.Id
				WHERE CC.CODE = IBI.CostCenterCode
				AND C.Code = IBI.CountryCode
				AND CC.IsActive = 1
				
			)
		)
		AND IBI.IdImport = @IdImport
	
		---- ########## CHECK 2
		SELECT @Module =  RTRIM(Code) FROM MODULES
		WHERE NAME =N'Project'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow, 
			'Project Code field is N/A!'
			,@Module	
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO project code
		ISNULL(IBI.ProjectCode, '' ) = ''
		AND IBI.IdImport = @IdImport
		
	
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Project Code '''  + ISNULL(IBI.ProjectCode,'N/A') + ''' does not exist in Projects catalog!',
			@Module			
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO project code
		( NOT EXISTS
			(
				SELECT Id 
				FROM PROJECTS 
				WHERE CODE=IBI.ProjectCode
			)
		)
		AND IBI.IdImport = @IdImport 
	
		
		---- ########## CHECK 3
		SELECT @Module =  RTRIM(Code) FROM MODULES 
		WHERE NAME =N'Work Package'

		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Work Package Code is N/A!'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO WP code
		ISNULL(IBI.WPCode, '' ) = ''
		AND IBI.IdImport = @IdImport			
		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Work Package Code '''  + ISNULL(IBI.WPCode,'N/A') + ''' does not exist or is inactive for Project Code ''' + ISNULL(IBI.ProjectCode,'N/A') + '''!'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO WP code
		( NOT EXISTS(
				SELECT TOP 1  WP.Code 
			      	FROM WORK_PACKAGES WP
			      	INNER JOIN PROJECTS P
			      		ON WP.IdProject = P.Id					
			     	WHERE WP.CODE = IBI.WPCode AND
				      Wp.IsActive = 1 AND	
				      P.Code = IBI.ProjectCode				      
			     )
		)				
		AND IBI.IdImport = @IdImport 
			
		---- ########## CHECK 4
		SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Associate'
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number is N/A!'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		ISNULL(IBI.AssociateNumber, '' ) = ''
		AND IBI.IdImport = @IdImport
				
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number '  + ISNULL(IBI.AssociateNumber,'N/A') + ' does not exist in Associates catalogue.'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO Associate Number
		( NOT EXISTS
			(
				SELECT Id 
				FROM ASSOCIATES 
				WHERE EmployeeNumber = IBI.AssociateNumber 
			)
		)
		AND IBI.IdImport = @IdImport 

		--AssociateNumber found in more than one country
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Associate Number '''  + ISNULL(IBI.AssociateNumber,'N/A') + ''' was found in ' +  
					(SELECT cast(count(Id) as varchar(3)) as AssociateCount
					 FROM ASSOCIATES 
					 WHERE EmployeeNumber = IBI.AssociateNumber
					 GROUP BY EmployeeNumber
					 HAVING count(*)>1)
				 + ' countries. Associate cannot be unique identified. Process cannot continue.'
			,@Module
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE   (SELECT Count(Id) 
			 FROM ASSOCIATES 
			 WHERE EmployeeNUmber = IBI.AssociateNumber) > 1 AND		
		IBI.IdImport = @IdImport
	
		---- ########## CHECK 5		
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Currency Code is N/A!'
			,NULL
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO Currency Code
		ISNULL(IBI.CurrencyCode, '' ) = ''
		AND IBI.IdImport = @IdImport
				
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Currency Code '''  + ISNULL(IBI.CurrencyCode,'N/A') + ''' does not match the currency for Country code ''' + IBI.CountryCode + ''
			,NULL
		FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE 
		--NO Currency Code
		( NOT EXISTS
			(
				SELECT * 
				FROM COUNTRIES C
				INNER JOIN CURRENCIES CURR
					ON C.IdCurrency = CURR.Id
				WHERE C.Code = IBI.CountryCode
		  		      AND CURR.Code = IBI.CurrencyCode										
			)
		) 
		AND IBI.IdImport = @IdImport 
		
		--CHECK if the project is ready for Initial Budget ( with explicit messages )
		IF EXISTS
		(
			SELECT IBI.IdImport				
			FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
			WHERE			
			NOT EXISTS
			(
				SELECT 
					P.Id 
				FROM 
					PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
				WHERE 
					P.CODE = IBI.ProjectCode 
					AND P.IsActive = 1
					AND WP.Code = IBI.WPCode
					AND WP.StartYearMonth IS NOT NULL 
					AND WP.EndYearMonth IS NOT NULL
				GROUP BY P.Id
			)
			AND IBI.IdImport = @IdImport	
		)
		BEGIN
			--CHECK IF THE PROJECT IS ACTIVE
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Initial Budget ( Project is not active ).',
				NULL
			FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
			WHERE
			EXISTS 
			(
				SELECT P.ID
				FROM PROJECTS P 
				WHERE P.Code = IBI.ProjectCode
				AND P.IsActive = 0
			)
			AND IBI.IdImport = @IdImport
			--CHECK IF THE WORK PACKAGE IS ACTIVE AND WITH DEFINED PERIOD
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Initial Budget ( Project does not have WPs with defined period ).',
				NULL
			FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
			WHERE
			(
				EXISTS 
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject							
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
						AND (WP.StartYearMonth IS NULL  OR WP.EndYearMonth IS NULL )
				)
				OR
				NOT EXISTS
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject							
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
				)
			)
			AND IBI.IdImport = @IdImport

			--CHECK IF THE PROJECT HAS INTERCO DEFINED
			INSERT INTO #tempTable
			(
				IdImport, IdRow, Details, Module
			)
			SELECT @IdImport, IBI.IdRow,
				'Project code ''' + ISNULL(IBI.ProjectCode, 'N/A' ) + ''' is not ready for Initial Budget ( Project has no interco defined ).',
				NULL
			FROM IMPORT_BUDGET_INITIAL_DETAILS IBI
			WHERE
			(
				NOT EXISTS 
				(
					SELECT  P.Id 
					FROM PROJECTS P
					INNER JOIN WORK_PACKAGES WP 
						ON P.Id =  WP.IdProject
					INNER JOIN PROJECTS_INTERCO PIN 
						ON P.Id = PIN.IdProject
					WHERE 
						P.CODE = IBI.ProjectCode 
						AND P.IsActive = 1
						AND WP.Code = IBI.WPCode
				)
			)			
		END								

		--CHECK If the Core Team is active and not a project reader
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'Core Member with Associate number ''' + ISNULL( IBI.AssociateNumber, 'N/A' ) + ''' is not active or is a project reader.',
			NULL
		FROM
			IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE
		NOT EXISTS
		(
			SELECT 
				P.Id 
			FROM 
				PROJECTS P
				INNER JOIN PROJECT_CORE_TEAMS  PT 
					ON P.Id = PT.IdProject
				INNER JOIN ASSOCIATES A 
					ON PT.IdAssociate = A.Id
			WHERE 
				P.Code = IBI.ProjectCode
				AND A.EmployeeNumber  = IBI.AssociateNumber
				AND PT.IsActive = 1				
				AND dbo.fnIsAssociateProjectReader(P.Id, A.Id ) <> 1
		)
		AND IBI.IdImport = @IdImport
		
		--CHECK if the KEY( IdProject, IdAssociate, IdWorkPackage, IdCostCenter ) exists
		INSERT INTO #tempTable
		(
			idImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
		       'The key (Project ''' + ISNULL(IBI.ProjectCode, 'N/A') + ''', AssociateNumber ''' + ISNULL(IBI.AssociateNumber, 'N/A') + ''', WPCode ''' + ISNULL(IBI.WPCode, 'N/A') + ''', CostCenterCode ''' + ISNULL(IBI.CostCenterCode, 'N/A') + ''' ) already exists in the budget table.',
			NULL
		FROM 
			IMPORT_BUDGET_INITIAL_DETAILS IBI
			INNER JOIN PROJECTS P 
				ON P.Code = IBI.ProjectCode
			INNER JOIN WORK_PACKAGES WP 
				ON P.Id = WP.IdProject  
				AND WP.Code = IBI.WPCode
			INNER JOIN ASSOCIATES A 
				ON A.EmployeeNumber = IBI.AssociateNumber
			INNER JOIN COUNTRIES C 
				ON C.Code = IBI.CountryCode
			INNER JOIN COST_CENTERS CC 
				ON CC.Code = IBI.CostCenterCode
			INNER JOIN BUDGET_INITIAL_DETAIL BId 
				ON P.Id = BId.IdProject AND
				   WP.IdPhase = BId.IdPhase AND
				   WP.Id = BId.IdWorkPackage AND
				   A.Id = BId.IdAssociate AND
				   CC.Id = BId.IdCostCenter
		WHERE
			IBI.IdImport = @IdImport 

		--CHECK if HoursQty, HoursVal, SalesVal follow the same rules as in UI
		INSERT INTO #tempTable
		(
			IdImport, IdRow, Details, Module
		)
		SELECT @IdImport, IBI.IdRow,
			'HoursQty ''' + ISNULL(CONVERT(char(20), IBI.HoursQty), 'N/A') + ''' must be a non-empty positive number. HoursVal ''' + ISNULL(CONVERT(char(20),IBI.HoursVal), 'N/A') + ''' must be a non-empty positive number. SalesVal ''' + ISNULL(CONVERT(char(20),IBI.SalesVal), 'N/A' + ''' must be a non-empty number.'),
			NULL
		FROM
			IMPORT_BUDGET_INITIAL_DETAILS IBI
		WHERE
			IBI.IdImport = @IdImport AND
			((IBI.HoursQty IS NULL OR IBI.HoursQty < 0) 
			OR (IBI.HoursVal IS NULL OR IBI.HoursVal < 0)
			OR IBI.SalesVal IS NULL )
		
		SELECT TOP 1 @Details =Details FROM #tempTable
		
		IF @@RowCount > 0
		BEGIN
			RAISERROR( @Details,16,1)
			RETURN -1
		END
	END		
	
	--Declare the cursor for import the data
	DECLARE InitialBudgetData CURSOR FAST_FORWARD FOR
		SELECT
			IdRow,
			ProjectCode,
			WPCode,	
			AssociateNumber,
			CountryCode,
			CostCenterCode,
			HoursQty,
			HoursVal,
			SalesVal,
			TE,	
			ProtoParts,
			ProtoTooling,
			Trials,
			OtherExpenses,
			CurrencyCode
		FROM IMPORT_BUDGET_INITIAL_DETAILS
		WHERE IdImport = @IdImport	
	
	
	DECLARE @IdRow int	
	DECLARE @ProjectCode varchar(10)
	DECLARE @WPCode varchar(4)
	DECLARE @AssociateNumber varchar(15)
	DECLARE @CountryCode varchar(3)
	DECLARE @CostCenterCode varchar(10)
	DECLARE @HoursQty int
	DECLARE @HoursVal decimal(18,4)
	DECLARE @SalesVal decimal(18,4)
	DECLARE @TE decimal(18,4)
	DECLARE @ProtoParts decimal(18,4)
	DECLARE @ProtoTooling decimal(18,4)
	DECLARE @Trials decimal(18,4)
	DECLARE @OtherExpenses decimal(18,4)
	DECLARE @CurrencyCode varchar(3),
		@IdCountry INT

	DECLARE @IdTE int
	DECLARE @IdProtoParts int
	DECLARE @IdProtoTooling int
	DECLARE @IdTrials int
	DECLARE @IdOtherExpenses int
	
	DECLARE @RetVal int 
	DECLARE @IdCurrentProject int
	DECLARE @IdCurrentAssociate int
	SET @IdCurrentProject   = -1
	SET @IdCurrentAssociate = -1

	--Getting the id's for BUDGET_COST_TYPES
	SELECT @IdTE = dbo.fnGetBudgetOtherCostType('T&E'),
	       @IdProtoParts = dbo.fnGetBudgetOtherCostType('Proto parts'),
	       @IdProtoTooling = dbo.fnGetBudgetOtherCostType('Proto tooling'),
	       @IdTrials = dbo.fnGetBudgetOtherCostType('Trials'),
	       @IdOtherExpenses = dbo.fnGetBudgetOtherCostType('Other expenses')
			
	OPEN InitialBudgetData
	FETCH NEXT FROM InitialBudgetData INTO @IdRow, @ProjectCode, @WPCode, @AssociateNumber, @CountryCode, 
		@CostCenterCode, @HoursQty, @HoursVal, @SalesVal, @TE, @ProtoParts, @ProtoTooling, @Trials, 
		@OtherExpenses, @CurrencyCode
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		DECLARE @IdProject int
		DECLARE @IdPhase int
		DECLARE @IdWP int
		DECLARE @IdCostCenter int
		DECLARE @IdAssociate int
		DECLARE @YearMonth int		

		--transform usual code into Id
		SELECT @IdProject = Id 
		FROM PROJECTS P 
		WHERE P.Code = @ProjectCode
	
		SELECT  @IdPhase = IdPhase, 
			@IdWP = Id, 
			@YearMonth = StartYearMonth 
		FROM WORK_PACKAGES WP 
		WHERE WP.IdProject =@IdProject AND 
		      WP.Code = @WPCode

		SELECT @IdCountry = Id
		FROM COUNTRIES C
		WHERE   C.Code = @CountryCode
	
		SELECT @IdCostCenter = CC.Id 
		FROM COST_CENTERS CC 	
		INNER JOIN INERGY_LOCATIONS IL 
		        ON CC.IdInergyLocation = IL.Id 
		WHERE   IL.IdCountry = @IdCountry AND
			CC.Code = @CostCenterCode

		SELECT @IdAssociate = Id 
		FROM ASSOCIATES A 
		WHERE A.EmployeeNumber = @AssociateNumber
		
		--Prepare the Insertion
		IF ( @IdCurrentProject <> @IdProject )
		BEGIN 
			SET @IdCurrentProject = @IdProject
			exec @RetVal = bgtInsertInitialBudget @IdProject
			IF ( @@ERROR <> 0 OR @RetVal < 0 )
			BEGIN
				CLOSE InitialBudgetData
				DEALLOCATE InitialBudgetData
				return -2
			END
		END
		
		IF ( @IdCurrentAssociate <> @IdAssociate )
		BEGIN
			SET @IdCurrentAssociate = @IdAssociate
			exec @RetVal = bgtUpdateInitialBudgetStates @IdProject, @IdAssociate, 'U'
			IF( @@ERROR <> 0 OR @RetVal < 0 )
			BEGIN
				CLOSE InitialBudgetData
				DEALLOCATE InitialBudgetData
				return -3
			END
		END

		exec @RetVal = bgtInsertInitialBudgetDetail @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -4
		END
		exec @RetVal = bgtUpdateInitialBudgetDetail @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @HoursQty, @HoursVal, @SalesVal
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -5
		END

		exec @RetVal = bgtInsertInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTE
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN	
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -6
		END
			
		exec @RetVal = bgtUpdateInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTE, @TE
		IF (@@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -7
		END
		
		exec @RetVal = bgtInsertInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoParts
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -8
		END
		
		exec @RetVal = bgtUpdateInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoParts, @ProtoParts
		IF ( @@ERROR <> 0 OR @RetVal < 0 ) 
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -9
		END

		exec @RetVal = bgtInsertInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoTooling
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -10
		END
		
		exec @RetVal = bgtUpdateInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdProtoTooling, @ProtoTooling
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -11
		END

		exec @RetVal = bgtInsertInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTrials
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -12
		END
		
		exec @RetVal = bgtUpdateInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdTrials, @Trials
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -13
		END

		exec @RetVal = bgtInsertInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdOtherExpenses
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -14
		END
		
		exec @RetVal = bgtUpdateInitialBudgetOtherCost @IdProject, @IdPhase, @IdWP, @IdCostCenter, @IdAssociate, @YearMonth, @IdOtherExpenses, @OtherExpenses
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			return -15
		END
		
		FETCH NEXT FROM InitialBudgetData INTO @IdRow, @ProjectCode, @WPCode, @AssociateNumber, @CountryCode
		, @CostCenterCode, @HoursQty, @HoursVal, @SalesVal, @TE, @ProtoParts, @ProtoTooling, @Trials
		, @OtherExpenses, @CurrencyCode
	END
	CLOSE InitialBudgetData
	DEALLOCATE InitialBudgetData

	--Group by IdProject, IdPhase, IdWp
	CREATE TABLE #BudgetInitial
	(
		IdProject INT NOT NULL,
		IdPhase INT NOT NULL ,
		IdWP INT NOT NULL,
		StartYearMonth int NULL,
		EndYearMonth int NULL
	)
	INSERT INTO #BudgetInitial(IdProject, IdPhase, IdWP, StartYearMonth, EndYearMonth)	
	SELECT 
		BId.IdProject,
		BId.IdPhase,
		BId.IdWorkPackage,
		NULL,
		NULL
	FROM 
		BUDGET_INITIAL_DETAIL BId
	WHERE 
		BId.IdProject = @IdProject
	GROUP BY 
		BId.IdProject, 
		BId.IdPhase, 
		BId.IdWorkPackage
	
	UPDATE t
	SET StartYearMonth = wp.StartYearMonth,
	    EndYearMonth =  wp.EndYearMonth
	FROM #BudgetInitial t
	INNER JOIN WORK_PACKAGES wp
		on t.IdProject = wp.IdProject AND 
		   t.IdPhase = wp.IdPhase AND
		   t.IdWP = wp.Id
		
	--Prepare to split the data
	DECLARE InitialBudgetData CURSOR FAST_FORWARD FOR
		SELECT
			IdProject,
			IdPhase,
			IdWP,
			StartYearMonth,
			EndYearMonth
		FROM #BudgetInitial	
	SET @IdProject = NULL
	SET @IdPhase = NULL
	SET @IdWp = NULL
	DECLARE @StartYearMonth int
	DECLARE @EndYearMonth int
		
	OPEN InitialBudgetData	
	FETCH NEXT FROM InitialBudgetData INTO @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
	WHILE @@FETCH_STATUS = 0
	BEGIN
		exec @RetVal = bgtUpdateInitialWPPeriod @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
		IF ( @@ERROR <> 0 OR @RetVal < 0 )
		BEGIN
			CLOSE InitialBudgetData
			DEALLOCATE InitialBudgetData
			DROP TABLE #BudgetInitial
			return -16
		END	
		
		FETCH NEXT FROM InitialBudgetData INTO @IdProject, @IdPhase, @IdWp, @StartYearMonth, @EndYearMonth
	END
	CLOSE InitialBudgetData
	DEALLOCATE InitialBudgetData	


GO

--Drops the Procedure impWriteToImportTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToImportTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToImportTable
GO

--sp_helptext impWRiteToImportTable
--impWriteToImportTable 'D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\XLSROM012007.csv',4, 10
CREATE    PROCEDURE impWriteToImportTable
	@fileName 	nvarchar(400), 	--The name of the file
	@IdAssociate INT		--ID of the associate
	
AS

DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

	
-- create tempporary table
	DECLARE @SQL varchar(2000)
	CREATE TABLE #tempTable 
	(		
		[Country] varchar(3), 
		[Year] varchar(4), 
		[Month]	varchar(2), 
		[CostCenter]	varchar(10), 
		[ProjectCode] 	varchar(10), 
		[WPCode]	varchar(4), 
		[AccountNumber]	varchar(10), 
		[AssociateNumber]	varchar(15), 
		[Quantity]	varchar(15), 
		[UnitQty]	varchar(4), 
		[Value]	varchar(19), 
		[CurrencyCode]	varchar(3), 
		[Date]	varchar(8) 		
	)

	

	DECLARE @RealFileName nvarchar(100)
	Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)
-- 	PRINT @RealFileName
	
	
	--HACK for network -- to be removed--replace @FileNameNoPath with @fileName
	DECLARE @UNCPath nvarchar(400)
	--SET @UNCPath = '\\zdgh\UploadDirectories\InProcess\'+ @FileNameNoPath
	SET @UNCPath = @fileName

	--fill the temporary table from file
	SET @SQL = 'BULK INSERT #tempTable FROM '''+ @UNCPath +
	''' WITH (FIELDTERMINATOR  = '';'',ROWTERMINATOR = ''\n'',FIRSTROW = 1,CODEPAGE = 1252,TABLOCK)
	ALTER TABLE #tempTable ADD  [IdRow] int Identity'
	EXEC(@SQL)

-- CREATE INDEX IndexCostCenter on #tempTable (Country, CostCenter)
-- CREATE INDEX IndexGLAccounts on #tempTable (Country, AccountNumber)
DECLARE @COMMAND NVARCHAR(2000)
SET @COMMAND = 'CREATE INDEX IndexCostCenter_'+CAST(@@SPID as varchar(10)) + ' on #tempTable (Country, CostCenter);'
SET @COMMAND = @COMMAND + 'CREATE INDEX IndexGLAccounts_' + CAST(@@SPID as varchar(10)) + '  on #tempTable (Country, AccountNumber)'
EXEC(@COMMAND) 

-- #####   GET RIDD OF THE RECORDS FROM EXCLUSION TABLES #######
			
	DELETE #tempTable
	FROM #tempTable t
	INNER JOIN ACTUAL_DATA_EXCLUSION_COST_CENTERS AEC
		ON t.Country = AEC.CountryCode AND
		   t.CostCenter = AEC.CostCenterCode
	SET @ROWCOUNTDELETED_CC = @@ROWCOUNT
-- PRINT @@ROWCOUNT

	DELETE #tempTable
	FROM #tempTable t
	INNER JOIN  ACTUAL_DATA_EXCLUSION_GL_ACCOUNTS AEG
		ON t.Country = AEG.CountryCode AND
		   t.AccountNumber = AEG.GLAccountCode

	SET @ROWCOUNTDELETED_GL = @@ROWCOUNT
-- PRINT @@ROWCOUNT

-- 	############################################################

	--fill imports/import_logs/import_details table
	DECLARE @IdImport 	INT,
		@IDSOURCE	INT,
		@YEARMONTH 	INT

	SELECT @IDSOURCE = dbo.fnGetIdSourceFromFileName(@fileName)

	-- set @fileName = 'D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\XLSROM052007.csv'
	SET @YEARMONTH=SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),3,4) + 
		       SUBSTRING(SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName))-1),7,6),1,2)

	SELECT @IdImport = ISNULL(MAX(IdImport),0)+1 
	FROM IMPORTS (TABLOCKX)

	
	INSERT INTO [IMPORTS]
		([IdImport], [ImportDate], [FileName], [IdAssociate], 
			ExclusionCostCenterRowsNo, ExclusionGlAccountsRowsNo)
	VALUES	(@IdImport,  GETDATE(),	   @RealFileName , @IdAssociate,
			@ROWCOUNTDELETED_CC, @ROWCOUNTDELETED_GL)

	INSERT INTO [IMPORT_LOGS]
		([IdImport], [IdSource], [YearMonth], [Validation])
	VALUES (@IdImport, @IDSOURCE, @YEARMONTH, 'R')

	INSERT INTO [IMPORT_DETAILS]
		( [IdImport], [IdRow], [Country]
		, [Year] ,[Month], [CostCenter]
		, [ProjectCode], [WPCode],[AccountNumber]
		, [AssociateNumber], [Quantity], [UnitQty]
		 ,[Value], [CurrencyCode], [Date])

	SELECT @IdImport, [IdRow],RTRIM(LTRIM([Country])) 
		,RTRIM(LTRIM([Year])), RTRIM(LTRIM([Month])),RTRIM(LTRIM([CostCenter]))
		,RTRIM(LTRIM([ProjectCode])),RTRIM(LTRIM([WPCode])), RTRIM(LTRIM([AccountNumber]))
		,RTRIM(LTRIM([AssociateNumber])),RTRIM(LTRIM([Quantity])),RTRIM(LTRIM([UnitQty])), 
		RTRIM(LTRIM([Value])), RTRIM(LTRIM([CurrencyCode])), RTRIM(LTRIM([Date]))
	FROM #tempTable

	RETURN @IdImport
	
GO

--Drops the Procedure impWriteToBudgetInitialImportTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToInitialBudgetImportTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToInitialBudgetImportTable
GO

CREATE PROCEDURE impWriteToInitialBudgetImportTable
	@fileName 	nvarchar(400),
	@IdAssociate	int
	
AS

DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

	
-- create tempporary table
	DECLARE @SQL varchar(2000)
	CREATE TABLE #tempTable 
	(		
		ProjectCode varchar(10) NOT NULL,
		WPCode varchar(4) NOT NULL,
		AssociateNumber varchar(15) NOT NULL,
		CountryCode varchar(3) NOT NULL,
		CostCenterCode varchar(10) NOT NULL,
		HoursQty int,
		HoursVal decimal(18,4),
		SalesVal decimal(18,4),
		TE decimal(18,4),
		ProtoParts decimal(18,4),
		ProtoTooling decimal(18,4),
		Trials decimal(18,4),
		OtherExpenses decimal(18,4),
		CurrencyCode varchar(3) NOT NULL
	)	

	DECLARE @RealFileName nvarchar(100)
	Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)


	--fill the temporary table from file
	SET @SQL = 'BULK INSERT #tempTable FROM '''+ @FileName +
	''' WITH (FIELDTERMINATOR  = '';'',ROWTERMINATOR = ''\n'',FIRSTROW = 1,CODEPAGE = 1252,TABLOCK)
	ALTER TABLE #tempTable ADD  [IdRow] int Identity '
	EXEC(@SQL)
	

	--CHECK if the content of the file have the same ProjectCode as FileName
	DECLARE @Start int
	DECLARE @End int
	SET @Start = 0
	SET @End = 0
	DECLARE @ProjectCode varchar(200)
	
	SET @Start = PATINDEX('%InitialBudget%', @RealFileName) + LEN('InitialBudget')
	SET @End = PATINDEX('%.csv%', @RealFileName)
	
	IF( @Start > 0 AND @End > 0 AND @Start < @End )		
		SET @ProjectCode = SUBSTRING(@RealFileName, @Start, @End-@Start )
	
	IF ISNULL( @ProjectCode, '' ) = '' 
	BEGIN
		RAISERROR( 'The name of the file is invalid.', 16, 1)
		RETURN -1
	END

	IF EXISTS
	(
		SELECT * 
		FROM #tempTable 
		WHERE ProjectCode <> @ProjectCode
	)
	BEGIN
		DECLARE @Message varchar(200)
		SET @Message = 'This file must contain only data for the Project Code:' + CONVERT(varchar(200), @ProjectCode)
		RAISERROR( @Message, 16, 1)
		RETURN -1
	END

	--fill imports table
	DECLARE @IDIMPORT INT
	SELECT @IDIMPORT  = ISNULL(MAX(IdImport),0)+1 
	FROM IMPORT_BUDGET_INITIAL (TABLOCKX)

	INSERT INTO IMPORT_BUDGET_INITIAL
		( IdImport,  ImportDate, FileName, idAssociate )
	VALUES( @IdImport, GETDATE(), @RealFileName, @IdAssociate )	

	INSERT INTO IMPORT_BUDGET_INITIAL_DETAILS
		( IdImport, IdRow, ProjectCode, WPCode, AssociateNumber, CostCenterCode, 
		  CountryCode, HoursQty, HoursVal, SalesVal, TE, ProtoParts, ProtoTooling, 
		  Trials, OtherExpenses, CurrencyCode)
	
	SELECT @IdImport, IdRow, RTRIM(LTRIM(ProjectCode)) 
		,RTRIM(LTRIM(WPCode)), RTRIM(LTRIM(AssociateNumber)), RTRIM(LTRIM(CostCenterCode))
		,RTRIM(LTRIM(CountryCode)), RTRIM(LTRIM(HoursQty)), RTRIM(LTRIM(HoursVal)) 
		,RTRIM(LTRIM(SalesVal)), RTRIM(LTRIM(TE)), RTRIM(LTRIM(ProtoParts))
  		,RTRIM(LTRIM(ProtoTooling)), RTRIM(LTRIM(Trials))
		,RTRIM(LTRIM(OtherExpenses)), RTRIM(LTRIM(CurrencyCode))
	FROM #tempTable	
	
	DROP table #tempTable

	RETURN @IDIMPORT
GO


--Drops the Procedure impWriteToLogAnnualTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToLogAnnualTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToLogAnnualTables
GO


CREATE  PROCEDURE impWriteToLogAnnualTables
	@fileName 	nvarchar(400), 	--The name of the file		
	@IDImport INT			-- id of the import	
	
AS

DECLARE @Module VARCHAR(50),
	@RowCount INT

	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected!',16,1)		
		RETURN -1
	END
DECLARE @Year INT
--#############BECAUSE THE FILENAME IS FIXED FORM WE CAN AFFORD TO TAKE THE YEAR FROM IT
-- 	DECLARE @fileName 	nvarchar(400)
-- 	SET @filename = 'D:\Work\INDEV3\Source\Indev3WebSite\Indev3WebSite\UploadDirectories\InProcess\FRA2007_1_2007_9_4.csv'
	SET @Year=SUBSTRING(RIGHT(@fileName,CHARINDEX('\',REVERSE(@fileName)) -1),4,4)
-- 	PRINT @YEAR
--#############################################################################################	



	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS]
		( [IdImport],[Year], [Validation] )
	VALUES (@IDImport, @Year, 'O')
	----------------------------------------------

	SELECT @Module = RTRIM(Code) FROM MODULES WHERE NAME =N'Country'

	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	-- ########## CHECK F1
	
	SELECT @IDImport, IMD.IdRow,
		'Country field is N/A!'
		, @Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	-- no country
	(IMD.Country IS NULL)
	AND IMD.IDImport = @IDImport
	

	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	-- ########## CHECK F1
	
	SELECT @IDImport, IMD.IdRow,
		'Country code: '  + ISNULL(IMD.Country,'N/A') + ' does not exist in Country catalogue!'
		, @Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	-- no country
	(NOT EXISTS(SELECT ID FROM COUNTRIES WHERE CODE =IMD.Country) )
	AND IMD.IDImport = @IDImport 

	
	-- ########## CHECK F3
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Year field is N/A!'		
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	-- NO YEAR
	( IMD.Year IS NULL) AND IMD.IDImport = @IDImport
-- 	##################### CHECK if year in 1900 - 2079 interval
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Year field: ' + CAST(IMD.Year as VARCHAR(9))+ ' is not in (1900 - 2079) interval'
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 	
		( IMD.Year NOT BETWEEN 1900 AND 2079) AND 
		IMD.IDImport = @IDImport

	---- ########## CHECK F5
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Cost Center'
	
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Cost Center is N/A!'
		,@Module		
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 		
	-- NO cost center
	(IMD.CostCenter IS NULL)
		
	AND IMD.IDImport = @IDImport
	

	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Cost Center '''  + ISNULL(IMD.CostCenter,'N/A') + ''' for country ''' + ISNULL(IMD.Country,'N/A') + ''' does not exists in Cost Center catalogue!'
		,@Module		
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 		
	-- NO cost center
	( NOT EXISTS
		(
			SELECT CC.Id 
			FROM COST_CENTERS CC 
			INNER JOIN INERGY_LOCATIONS IL 
			        ON CC.IdInergyLocation = IL.ID 
			INNER JOIN COUNTRIES C 
				ON IL.IdCountry = C.Id     
			WHERE CC.CODE = IMD.CostCenter AND
			      C.Code = IMD.Country
		)
	)
	
	AND IMD.IDImport = @IDImport 
	

	---- ########## CHECK F6

	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Project'
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow, 
		'Project Code field is N/A!'
		,@Module	
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO project code
		(IMD.ProjectCode IS NULL)
	AND IMD.IDImport = @IDImport



	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Project Code: '  + ISNULL(IMD.ProjectCode,'N/A') + ' does not exist in Projects catalog!',
		@Module			
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO project code
		(NOT EXISTS(SELECT ID FROM PROJECTS WHERE CODE=IMD.ProjectCode))
	AND IMD.IDImport = @IDImport 


	--INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	--(
	--	[IdImport], [IdRow], [Details], [Module]
	--)
	--SELECT @IDImport, IMD.IdRow,
	--	'Project Code: '  + ISNULL(IMD.ProjectCode,'N/A') + ' is not of type C,R,A,I,N!',
	--	@Module			
	--FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	--WHERE 
	----project code exist but is not of type CRAIN
	--IMD.ProjectCode is not null
	--AND left(IMD.ProjectCode,1) not in ('C','R','A','I','N')
	--AND	(EXISTS(SELECT ID FROM PROJECTS WHERE CODE=IMD.ProjectCode))
	--AND IMD.IDImport = @IDImport 


	---- ########## CHECK F7
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code is N/A!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO WP code
	(IMD.WPCode IS NULL) 
	AND IMD.IDImport = @IDImport

	
	
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code: '  + ISNULL(IMD.WPCode,'N/A') + ' does not exist for Project Code: ' + ISNULL(IMD.ProjectCode,'N/A') + '!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO WP code
	( NOT EXISTS(
			SELECT TOP 1  WP.Code 
		      	FROM WORK_PACKAGES WP							
		      	INNER JOIN PROJECTS P
		      		ON WP.IdProject = P.Id					
		     	WHERE WP.CODE = IMD.WPCode AND
			P.Code = IMD.ProjectCode
		     )
	)	    
	AND IMD.IDImport = @IDImport 



	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code: '  + IMD.WPCode + ' starts with 0 and Project Code: ' + ISNULL(IMD.ProjectCode,'N/A') + ' is not of type Z,R,A,I,N!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	IMD.WPCode like '0%'
	AND IMD.ProjectCode is not null
	AND left(IMD.ProjectCode,1) not in ('Z','R','A','I','N')
	--WP code exists
	AND (EXISTS(
			SELECT TOP 1  WP.Code 
		      	FROM WORK_PACKAGES WP							
		      	INNER JOIN PROJECTS P
		      		ON WP.IdProject = P.Id					
		     	WHERE WP.CODE = IMD.WPCode AND
			P.Code = IMD.ProjectCode
		     )
	)	    
	AND IMD.IDImport = @IDImport 

	/*
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code: '  + IMD.WPCode + ' is not 000 and Project Code: ' + ISNULL(IMD.ProjectCode,'N/A') + ' is of type R,A,I,N!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	IMD.WPCode <> '000'
	AND IMD.ProjectCode is not null
	AND left(IMD.ProjectCode,1) in ('R','A','I','N')
	--WP code exists
	AND (EXISTS(
			SELECT TOP 1  WP.Code 
		      	FROM WORK_PACKAGES WP							
		      	INNER JOIN PROJECTS P
		      		ON WP.IdProject = P.Id					
		     	WHERE WP.CODE = IMD.WPCode AND
			P.Code = IMD.ProjectCode
		     )
	)	    
	AND IMD.IDImport = @IDImport 
	*/
	
	---- ########## CHECK F8
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'G/L Account'
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Account Number Code is N/A!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO Account Number
		(IMD.AccountNumber IS NULL)
	AND IMD.IDImport = @IDImport

	
	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Account Number Code: '  + ISNULL(IMD.AccountNumber,'N/A') + ' does not exists in G/L Accounts catalogue for country:' + ISNULL(IMD.Country,'N/A') + '!'
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE 
	--NO Account Number
		(NOT EXISTS(SELECT GL.ID 
				FROM GL_ACCOUNTS GL 
				INNER JOIN COUNTRIES C
					ON GL.IdCountry = C.Id
				WHERE Account = IMD.AccountNumber AND
				C.Code = IMD.Country))
	AND IMD.IDImport = @IDImport 
		

	INSERT INTO [ANNUAL_BUDGET_IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		left('Account Number Code is not 10000000 and '
		+ case when isnull(quantity1,0) <> 0 then ' Quantity1 <> 0' else '' end
		+ case when isnull(quantity2,0) <> 0 then ' Quantity2 <> 0' else '' end
		+ case when isnull(quantity3,0) <> 0 then ' Quantity3 <> 0' else '' end
		+ case when isnull(quantity4,0) <> 0 then ' Quantity4 <> 0' else '' end
		+ case when isnull(quantity5,0) <> 0 then ' Quantity5 <> 0' else '' end
		+ case when isnull(quantity6,0) <> 0 then ' Quantity6 <> 0' else '' end
		+ case when isnull(quantity7,0) <> 0 then ' Quantity7 <> 0' else '' end
		+ case when isnull(quantity8,0) <> 0 then ' Quantity8 <> 0' else '' end
		+ case when isnull(quantity9,0) <> 0 then ' Quantity9 <> 0' else '' end
		+ case when isnull(quantity10,0) <> 0 then ' Quantity10 <> 0' else '' end
		+ case when isnull(quantity11,0) <> 0 then ' Quantity11 <> 0' else '' end
		+ case when isnull(quantity12,0) <> 0 then ' Quantity12 <> 0' else '' end, 255)
		,@Module
	FROM ANNUAL_BUDGET_IMPORT_DETAILS IMD
	WHERE IMD.IDImport = @IDImport and
	IMD.AccountNumber <> '10000000' and 
	(isnull(Quantity1,0) <> 0 or isnull(Quantity2,0) <> 0 or isnull(Quantity3,0) <> 0 or isnull(Quantity4,0) <> 0
	 or isnull(Quantity5,0) <> 0 or isnull(Quantity6,0) <> 0 or isnull(Quantity7,0) <> 0 or isnull(Quantity8,0) <> 0
	 or isnull(Quantity9,0) <> 0 or isnull(Quantity10,0) <> 0 or isnull(Quantity11,0) <> 0 or isnull(Quantity12,0) <> 0)

GO

--Drops the Procedure impWriteToLogTables if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToLogTables]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToLogTables
GO


CREATE    PROCEDURE impWriteToLogTables
	@IdImport 	INT,		-- id of the import
	@IdAssociate 	INT		-- id of the associate	
AS

	DECLARE @Module VARCHAR(50), 		
		@IdSource INT,
		@SourceName varchar(100)
	
	-- update the state in IMPORT_LOGS	
	UPDATE IMPORT_LOGS
	SET Validation = 'O'
	WHERE IdImport = @IdImport

	----------------------------------------------

	SELECT @Module = RTRIM(Code) 
	FROM MODULES 
	WHERE NAME =N'Country'

	SELECT @IdSource = IL.IdSource, 
 	       @SourceName= IMS.SourceName
	FROM IMPORT_LOGS IL
	INNER JOIN IMPORT_SOURCES IMS
		ON IL.IdSource = IMS.Id
	WHERE IL.IdImport = @IdImport

	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	-- ########## CHECK F1
	
	SELECT @IDImport, IMD.IdRow,
		'Country field is N/A!'
		, @Module			
	FROM Import_details IMD
	WHERE 
	-- no country
	(IMD.Country IS NULL)
	AND IMD.IDImport = @IDImport
	

	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	-- ########## CHECK F1
	
	SELECT @IDImport, IMD.IdRow,
		'Country code: ' + ISNULL(IMD.Country,'N/A') + ' does not exist in Country catalogue!'
		, @Module
	FROM Import_details IMD
	WHERE 
	-- no country
	(NOT EXISTS(SELECT ID FROM COUNTRIES WHERE CODE =IMD.Country) )
	AND IMD.IDImport = @IDImport 

	
	-- ########## Check if the imported Country belongs to IMPORT_SOURCES
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT IMD.IdImport, 
		   IMD.IdRow,
		   'Country ''' + ISNULL(IMD.Country,'N/A') + ''' does not belong to Import Source ''' + @SourceName + '''.',
		   null
	FROM IMPORT_DETAILS IMD
	INNER JOIN IMPORT_LOGS IML
		ON IMD.IdImport = IML.IdImport
	INNER JOIN IMPORT_SOURCES IMS
		ON IML.IdSource = IMS.Id
	INNER JOIN COUNTRIES C
		ON IMD.Country = C.Code
	WHERE IMD.IdImport = @IdImport AND
		  C.Id NOT IN 
			(SELECT IdCountry
			FROM IMPORT_SOURCES_COUNTRIES ISC
			WHERE ISC.IdImportSource = @IdSource)
	UNION
	SELECT IMD.IdImport, 
		   IMD.IdRow,
		   'Country ''' + ISNULL(IMD.Country,'N/A') + ''' does not belong to Import Source ''' + @SourceName + '''.',
		   null
	FROM IMPORT_DETAILS IMD
	LEFT JOIN COUNTRIES C
		ON IMD.Country = C.Code
	WHERE IMD.IdImport = @IdImport AND
	      C.Id IS NULL

	-- ########## CHECK F3
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Year field is N/A!'		
	FROM Import_details IMD
	WHERE 
	-- NO YEAR
	( IMD.Year IS NULL) AND IMD.IDImport = @IDImport
-- 	############ CHECK if year is valid

	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Year field: ' + CAST(IMD.Year as VARCHAR(9)) + ' is not in (1900 - 2079) interval!'
	FROM Import_details IMD
	WHERE 
	
	( IMD.Year NOT BETWEEN 1900 AND 2079) AND IMD.IDImport = @IDImport

	---- ########## CHECK F4
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Month field is N/A!'			
	FROM Import_details IMD
	WHERE 
	
	--NO MONTH
	(IMD.Month IS NULL) AND IMD.IDImport = @IDImport


	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Month field: ' + CAST(IMD.Month AS VARCHAR(9)) + ' is not in (1 - 12) interval!'			
	FROM Import_details IMD
	WHERE 
	
	--NO MONTH
	(IMD.Month NOT BETWEEN 1 AND 12) AND IMD.IDImport = @IDImport


	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Cost Center'

	---- ########## CHECK F5
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Cost Center is N/A!'
		,@Module		
	FROM Import_details IMD
	WHERE 		
	-- NO cost center
	(IMD.CostCenter IS NULL)
		
	AND IMD.IDImport = @IDImport


	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Cost Center '''  + ISNULL(IMD.CostCenter,'N/A') + ''' for country ''' + ISNULL(IMD.Country,'N/A') + ''' does not exists in Cost Center catalogue!'
		,@Module		
	FROM Import_details IMD
	WHERE 		
	-- NO cost center
	( NOT EXISTS
		(
			SELECT CC.Id 
			FROM COST_CENTERS CC 
			INNER JOIN INERGY_LOCATIONS IL 
			        ON CC.IdInergyLocation = IL.ID 
			INNER JOIN COUNTRIES C 
				ON IL.IdCountry = C.Id     
			WHERE CC.CODE = IMD.CostCenter AND
			      C.Code = IMD.Country
		)
	)
	
	AND IMD.IDImport = @IDImport 

	---- ########## CHECK F6

	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Project'
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow, 
		'Project Code field is N/A!'
		,@Module	
	FROM Import_details IMD
	WHERE 
	--NO project code
		(IMD.ProjectCode IS NULL)
	AND IMD.IDImport = @IDImport




	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Project Code: '  + ISNULL(IMD.ProjectCode,'N/A') + ' does not exist in Projects catalog!',
		@Module			
	FROM Import_details IMD
	WHERE 
	--NO project code
		(NOT EXISTS(SELECT ID FROM PROJECTS WHERE CODE=IMD.ProjectCode))
	AND IMD.IDImport = @IDImport 



	---- ########## CHECK F7
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Work Package'
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code is N/A!'
		,@Module
	FROM Import_details IMD
	WHERE 
	--NO WP code
	(IMD.WPCode IS NULL) 
	AND IMD.IDImport = @IDImport


	
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,
		'Work Package Code: '  + ISNULL(IMD.WPCode,'N/A') + ' does not exist in Project Code:' + ISNULL(IMD.ProjectCode,'N/A') + '!'
		,@Module
	FROM Import_details IMD
	WHERE 
	--NO WP code
	
	( NOT EXISTS(
			SELECT TOP 1  WP.Code 
		      	FROM WORK_PACKAGES WP 
-- 				INNER JOIN Project_Phases PP
-- 					ON WP.IdPhase = PP.Id					
		      	INNER JOIN PROJECTS P
		      		ON WP.IdProject = P.Id					
		     	WHERE WP.CODE = IMD.WPCode
-- 			AND PP.Code = SUBSTRING(ISNULL(IMD.WPCode,''), 1, 1)
			AND P.Code = IMD.ProjectCode
		     )
	)	    
		
	AND IMD.IDImport = @IDImport 

	
	---- ########## CHECK F8
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'G/L Account'
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Account Number Code is N/A!'
		,@Module
	FROM Import_details IMD
	WHERE 
	--NO Account Number
		(IMD.AccountNumber IS NULL)
	AND IMD.IDImport = @IDImport


	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Account Number Code: '  + ISNULL(IMD.AccountNumber,'N/A') + ' does not exists in G/L Accounts catalogue for country:' + ISNULL(IMD.Country,'N/A') + '!'
		,@Module
	FROM Import_details IMD
	WHERE 
	--NO Account Number
		(NOT EXISTS(	SELECT GL.ID 
				FROM GL_ACCOUNTS GL INNER JOIN COUNTRIES C
				ON GL.IdCountry = C.Id
				WHERE Account = IMD.AccountNumber AND
				C.Code = IMD.Country))
	AND IMD.IDImport = @IDImport 




	-------#######CHECK QUANTITY

	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details]
	)
	SELECT @IDImport, IMD.IdRow,	
		'Quantity is N/A!'				
	FROM IMPORT_DETAILS IMD
	WHERE 
	--NO Quantity
		(IMD.Quantity IS NULL) AND IMD.IDImport = @IDImport
		
	
	
	
	-----#######CHECK HOURLY RATES
	SELECT @Module =  RTRIM(Code) FROM MODULES WHERE NAME =N'Hourly Rate'
	INSERT INTO [IMPORT_LOGS_DETAILS]
	(
		[IdImport], [IdRow], [Details], [Module]
	)
	SELECT @IdImport, IMD.IdRow,
			'Hourly rate for Cost Center ' + ISNULL(IMD.CostCenter, 'N/A') + ' and period ' + CAST((IMD.[Month]) as VARCHAR(2)) + '/' + CAST((IMD.[Year]) as VARCHAR(4)) + ' does not exist!'
			,@Module
	FROM IMPORT_DETAILS IMD
	WHERE
		(NOT EXISTS(SELECT HourlyRate 
					FROM HOURLY_RATES AS HR
					INNER JOIN COST_CENTERS CC
							ON HR.IdCostCenter = CC.Id
					WHERE 	IMD.CostCenter = CC.Code AND
						    HR.YearMonth = IMD.[Year]*100+IMD.[Month])
		)
		AND IMD.IDImport = @IDImport 

GO

	--Drops the Procedure impWriteToBudgetRevisedImportTable if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[impWriteToRevisedBudgetImportTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE impWriteToRevisedBudgetImportTable
GO

CREATE PROCEDURE impWriteToRevisedBudgetImportTable
	@fileName 	nvarchar(400),
	@IdAssociate	int
	
AS

DECLARE @ROWCOUNTDELETED_CC INT,
	@ROWCOUNTDELETED_GL INT

	IF (@fileName is null )
	BEGIN 
		RAISERROR('No file has been selected',16,1)		
		RETURN -1
	END

	
-- create tempporary table
	DECLARE @SQL varchar(2000)
	CREATE TABLE #tempTable 
	(		
		ProjectCode varchar(10) NOT NULL,
		WPCode varchar(4) NOT NULL,
		AssociateNumber varchar(15) NOT NULL,
		CountryCode varchar(3) NOT NULL,
		CostCenterCode varchar(10) NOT NULL,
		HoursQty int,
		HoursVal decimal(18,4),
		SalesVal decimal(18,4),
		TE decimal(18,4),
		ProtoParts decimal(18,4),
		ProtoTooling decimal(18,4),
		Trials decimal(18,4),
		OtherExpenses decimal(18,4),
		CurrencyCode varchar(3) NOT NULL
	)	

	DECLARE @RealFileName nvarchar(100)
	Select @RealFileName = dbo.fnGetFileNameFromPath(@FileName)


	--fill the temporary table from file
	SET @SQL = 'BULK INSERT #tempTable FROM '''+ @FileName +
	''' WITH (FIELDTERMINATOR  = '';'',ROWTERMINATOR = ''\n'',FIRSTROW = 1,CODEPAGE = 1252,TABLOCK)
	ALTER TABLE #tempTable ADD  [IdRow] int Identity '
	EXEC(@SQL)
	

	--CHECK if the content of the file have the same ProjectCode as FileName
	DECLARE @Start int
	DECLARE @End int
	SET @Start = 0
	SET @End = 0
	DECLARE @ProjectCode varchar(200)
	
	SET @Start = PATINDEX('%RevisedBudget%', @RealFileName) + LEN('RevisedBudget')
	SET @End = PATINDEX('%.csv%', @RealFileName)
	
	IF( @Start > 0 AND @End > 0 AND @Start < @End )		
		SET @ProjectCode = SUBSTRING(@RealFileName, @Start, @End-@Start )
	
	IF ISNULL( @ProjectCode, '' ) = '' 
	BEGIN
		RAISERROR( 'The name of the file is invalid.', 16, 1)
		RETURN -1
	END

	IF EXISTS
	(
		SELECT * 
		FROM #tempTable 
		WHERE ProjectCode <> @ProjectCode
	)
	BEGIN
		DECLARE @Message varchar(200)
		SET @Message = 'This file must contain only data for the Project Code:' + CONVERT(varchar(200), @ProjectCode)
		RAISERROR( @Message, 16, 1)
		RETURN -1
	END

	--fill imports table
	DECLARE @IDIMPORT INT
	SELECT @IDIMPORT  = ISNULL(MAX(IdImport),0)+1 
	FROM IMPORT_BUDGET_REVISED (TABLOCKX)

	INSERT INTO IMPORT_BUDGET_REVISED
		( IdImport,  ImportDate, FileName, idAssociate )
	VALUES( @IdImport, GETDATE(), @RealFileName, @IdAssociate )	

	INSERT INTO IMPORT_BUDGET_REVISED_DETAILS
		( IdImport, IdRow, ProjectCode, WPCode, AssociateNumber, CostCenterCode, 
		  CountryCode, HoursQty, HoursVal, SalesVal, TE, ProtoParts, ProtoTooling, 
		  Trials, OtherExpenses, CurrencyCode)
	
	SELECT @IdImport, IdRow, RTRIM(LTRIM(ProjectCode)) 
		,RTRIM(LTRIM(WPCode)), RTRIM(LTRIM(AssociateNumber)), RTRIM(LTRIM(CostCenterCode))
		,RTRIM(LTRIM(CountryCode)), RTRIM(LTRIM(HoursQty)), RTRIM(LTRIM(HoursVal)) 
		,RTRIM(LTRIM(SalesVal)), RTRIM(LTRIM(TE)), RTRIM(LTRIM(ProtoParts))
  		,RTRIM(LTRIM(ProtoTooling)), RTRIM(LTRIM(Trials))
		,RTRIM(LTRIM(OtherExpenses)), RTRIM(LTRIM(CurrencyCode))
	FROM #tempTable	
	
	DROP table #tempTable

	RETURN @IDIMPORT
GO


--Drops the Procedure [logInsertITrackingActivity]if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[logInsertITrackingActivity]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE logInsertITrackingActivity
GO


create  PROCEDURE [dbo].[logInsertITrackingActivity]
@IdAssociate int,
@IdMemberImpersonated int,
@IdProjectFunctionImpersonated int,
@IdProject int,
@IdAction int,
@IdGeneration int
	
AS
declare @IdRole int
select @IdRole = IdRole from ASSOCIATE_ROLES where IdAssociate = @IdAssociate
declare @ProjectCode varchar(10)

BEGIN
	if @IdMemberImpersonated <= 0
	   set @IdMemberImpersonated = null
	
	if @IdProject <= 0
		begin
			set @IdProject = null
		end

	if @IdAction <= 0
	   set @IdAction = null

	if @IdGeneration <= 0
		set @IdGeneration = null

	if @IdProjectFunctionImpersonated <= 0
		set @IdProjectFunctionImpersonated = null


	INSERT INTO TRACKING_ACTIVITY_LOG 
		(IdAssociate, IdRole, IdMemberImpersonated, IdFunctionImpersonated,  IdProject, IdAction, IdGeneration, LogDate)
		VALUES	(@IdAssociate, @IdRole, @IdMemberImpersonated, @IdProjectFunctionImpersonated, @IdProject, @IdAction, @IdGeneration, GETDATE())
END

go--Drops the Procedure catUpdateCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[olapUpdateOlapPeriods]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE olapUpdateOlapPeriods
GO
CREATE PROCEDURE olapUpdateOlapPeriods
AS
	DECLARE @PeriodsMaxYM INT
	DECLARE @PeriodsMaxYear INT

	SELECT 	@PeriodsMaxYM = ISNULL(MAX(YearMonthKey), 200201)
	FROM	OLAP_PERIODS	
	
	SET @PeriodsMaxYear = @PeriodsMaxYM / 100

	IF (@PeriodsMaxYear <> Year(GETDATE())+2)
	BEGIN
		DELETE FROM OLAP_PERIODS
		
		INSERT INTO OLAP_PERIODS (YearMonthKey, Month, Year, MonthName)
		SELECT 	Years.Year*100+Months.Month,
			Months.Month,
			Years.Year,
			Months.MonthName + ' ' + CAST(Years.Year AS Char(4))
		FROM OLAP_YEARS Years
		CROSS JOIN
		OLAP_MONTHS Months
		WHERE Year >= 2002 AND
		Year <= Year(GETDATE())+2
		ORDER BY Years.Year, Months.Month 
	END
GO

--Drops the Procedure testVerifyProcedureName if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[testVerifyProcedureName]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE testVerifyProcedureName
GO
CREATE PROCEDURE testVerifyProcedureName
	@Name AS VARCHAR(100) 	--The Name of the supposed stored procedure
AS

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(@Name) and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	SELECT 1
ELSE 
	SELECT 0
GO

--Drops the Procedure catUpdateCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[usrInsertOrUpdateUserSettings]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE usrInsertOrUpdateUserSettings
GO
CREATE PROCEDURE usrInsertOrUpdateUserSettings
(
	@AssociateId	INT,		--The Id of the Associated User
	@AmountScaleOption INT,		--The Id of Enum Scale option you want to Insert
 	@NumberOfRecordsPerPage	INT,	--The Number of records an user wants to see on page
					-- you want to Insert
	@CurrencyRepresentation	INT	--the currency an user wants to see budget figures
)
AS
DECLARE @ErrorMessage		VARCHAR(200),
	@LogicalKey		VARCHAR(20)
	
	SET @LogicalKey = 'AssociateId'

	IF(@AssociateId IS NULL OR 
	   @AmountScaleOption IS NULL OR 
	   @NumberOfRecordsPerPage IS NULL OR 
	   @CurrencyRepresentation IS NULL)
	BEGIN 
		EXEC auxSelectErrorMessage_0 @Code = 'VERIFY_MANDATORY_COLUMN_0',@IdLanguage = 1, @Message = @ErrorMessage OUTPUT
		RAISERROR(@ErrorMessage,16,1)
		RETURN -2		
	END

	IF EXISTS( 
		SELECT *
		FROM USER_SETTINGS AS U
		WHERE 	U.AssociateId = @AssociateId
	)
	BEGIN 
		UPDATE USER_SETTINGS
		SET
			[AmountScaleOption] = @AmountScaleOption,
			[NumberOfRecordsPerPage] = @NumberOfRecordsPerPage,
			[CurrencyRepresentation] = @CurrencyRepresentation
		WHERE  [AssociateId] = @AssociateId
		
	END
	ELSE
	BEGIN
		INSERT INTO USER_SETTINGS	([AssociateId],[AmountScaleOption],[NumberOfRecordsPerPage],[CurrencyRepresentation])
			VALUES		     	(@AssociateId, @AmountScaleOption ,@NumberOfRecordsPerPage, @CurrencyRepresentation)
	END
GO
--Drops the Procedure catUpdateCurrency if it exists
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE ID = object_id(N'[dbo].[usrSelectUserSettings]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE usrSelectUserSettings
GO
CREATE PROCEDURE usrSelectUserSettings
(
	@AssociateId AS INT 	--The Id of the selected Asociate
)
AS
	SELECT 	[AssociateId]	AS 'AssociateId',
		[AmountScaleOption] AS 'AmountScaleOption',
		[NumberOfRecordsPerPage]	AS 'NumberOfRecordsPerPage',
		[CurrencyRepresentation]	AS 'CurrencyRepresentation'
	FROM USER_SETTINGS
	WHERE AssociateId = @AssociateId

GO

